// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'restful_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$RestfulFailureTearOff {
  const _$RestfulFailureTearOff();

// ignore: unused_element
  _SearchStringTest<T> searchStringTest<T>({String searchString}) {
    return _SearchStringTest<T>(
      searchString: searchString,
    );
  }

// ignore: unused_element
  _HttpFailure<T> httpFailure<T>(
      {int statusCode, String errorType, T failedValue}) {
    return _HttpFailure<T>(
      statusCode: statusCode,
      errorType: errorType,
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _UnknownFailure<T> unknownFailure<T>({@required T failedValue}) {
    return _UnknownFailure<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _NoInternet<T> noInternet<T>({@required T failedValue}) {
    return _NoInternet<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _NoType<T> noType<T>({@required T failedValue}) {
    return _NoType<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _NoId<T> noId<T>({@required T failedValue}) {
    return _NoId<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _NoVid<T> noVid<T>({@required T failedValue}) {
    return _NoVid<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _IdDoesNotMatchResource<T> idDoesNotMatchResource<T>(
      {@required T failedValue}) {
    return _IdDoesNotMatchResource<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _NoBundle<T> noBundle<T>(
      {@required T failedValue, @required String batchOrTransaction}) {
    return _NoBundle<T>(
      failedValue: failedValue,
      batchOrTransaction: batchOrTransaction,
    );
  }

// ignore: unused_element
  _NotABatchBundle<T> notABatchBundle<T>({@required T failedValue}) {
    return _NotABatchBundle<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _NotATransactionBundle<T> notATransactionBundle<T>(
      {@required T failedValue}) {
    return _NotATransactionBundle<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _MissingEntryRequest<T> missingEntryRequest<T>({@required T failedValue}) {
    return _MissingEntryRequest<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _MissingRequestMethod<T> missingRequestMethod<T>({@required T failedValue}) {
    return _MissingRequestMethod<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _PrimitiveFailure<T> primitiveFailure<T>(
      {@required String parameter, @required T failedValue}) {
    return _PrimitiveFailure<T>(
      parameter: parameter,
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _SearchParameterFailure<T> searchParameterFailure<T>(
      {@required String parameter, @required T failedValue}) {
    return _SearchParameterFailure<T>(
      parameter: parameter,
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  _EmptySearchParameters<T> emptySearchParameters<T>(
      {@required String parameter}) {
    return _EmptySearchParameters<T>(
      parameter: parameter,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $RestfulFailure = _$RestfulFailureTearOff();

/// @nodoc
mixin _$RestfulFailure<T> {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  });
}

/// @nodoc
abstract class $RestfulFailureCopyWith<T, $Res> {
  factory $RestfulFailureCopyWith(
          RestfulFailure<T> value, $Res Function(RestfulFailure<T>) then) =
      _$RestfulFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$RestfulFailureCopyWithImpl<T, $Res>
    implements $RestfulFailureCopyWith<T, $Res> {
  _$RestfulFailureCopyWithImpl(this._value, this._then);

  final RestfulFailure<T> _value;
  // ignore: unused_field
  final $Res Function(RestfulFailure<T>) _then;
}

/// @nodoc
abstract class _$SearchStringTestCopyWith<T, $Res> {
  factory _$SearchStringTestCopyWith(_SearchStringTest<T> value,
          $Res Function(_SearchStringTest<T>) then) =
      __$SearchStringTestCopyWithImpl<T, $Res>;
  $Res call({String searchString});
}

/// @nodoc
class __$SearchStringTestCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$SearchStringTestCopyWith<T, $Res> {
  __$SearchStringTestCopyWithImpl(
      _SearchStringTest<T> _value, $Res Function(_SearchStringTest<T>) _then)
      : super(_value, (v) => _then(v as _SearchStringTest<T>));

  @override
  _SearchStringTest<T> get _value => super._value as _SearchStringTest<T>;

  @override
  $Res call({
    Object searchString = freezed,
  }) {
    return _then(_SearchStringTest<T>(
      searchString: searchString == freezed
          ? _value.searchString
          : searchString as String,
    ));
  }
}

/// @nodoc
class _$_SearchStringTest<T> extends _SearchStringTest<T> {
  const _$_SearchStringTest({this.searchString}) : super._();

  @override
  final String searchString;

  @override
  String toString() {
    return 'RestfulFailure<$T>.searchStringTest(searchString: $searchString)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SearchStringTest<T> &&
            (identical(other.searchString, searchString) ||
                const DeepCollectionEquality()
                    .equals(other.searchString, searchString)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(searchString);

  @override
  _$SearchStringTestCopyWith<T, _SearchStringTest<T>> get copyWith =>
      __$SearchStringTestCopyWithImpl<T, _SearchStringTest<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return searchStringTest(searchString);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (searchStringTest != null) {
      return searchStringTest(searchString);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return searchStringTest(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (searchStringTest != null) {
      return searchStringTest(this);
    }
    return orElse();
  }
}

abstract class _SearchStringTest<T> extends RestfulFailure<T> {
  const _SearchStringTest._() : super._();
  const factory _SearchStringTest({String searchString}) =
      _$_SearchStringTest<T>;

  String get searchString;
  _$SearchStringTestCopyWith<T, _SearchStringTest<T>> get copyWith;
}

/// @nodoc
abstract class _$HttpFailureCopyWith<T, $Res> {
  factory _$HttpFailureCopyWith(
          _HttpFailure<T> value, $Res Function(_HttpFailure<T>) then) =
      __$HttpFailureCopyWithImpl<T, $Res>;
  $Res call({int statusCode, String errorType, T failedValue});
}

/// @nodoc
class __$HttpFailureCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$HttpFailureCopyWith<T, $Res> {
  __$HttpFailureCopyWithImpl(
      _HttpFailure<T> _value, $Res Function(_HttpFailure<T>) _then)
      : super(_value, (v) => _then(v as _HttpFailure<T>));

  @override
  _HttpFailure<T> get _value => super._value as _HttpFailure<T>;

  @override
  $Res call({
    Object statusCode = freezed,
    Object errorType = freezed,
    Object failedValue = freezed,
  }) {
    return _then(_HttpFailure<T>(
      statusCode: statusCode == freezed ? _value.statusCode : statusCode as int,
      errorType: errorType == freezed ? _value.errorType : errorType as String,
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_HttpFailure<T> extends _HttpFailure<T> {
  const _$_HttpFailure({this.statusCode, this.errorType, this.failedValue})
      : super._();

  @override
  final int statusCode;
  @override
  final String errorType;
  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.httpFailure(statusCode: $statusCode, errorType: $errorType, failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _HttpFailure<T> &&
            (identical(other.statusCode, statusCode) ||
                const DeepCollectionEquality()
                    .equals(other.statusCode, statusCode)) &&
            (identical(other.errorType, errorType) ||
                const DeepCollectionEquality()
                    .equals(other.errorType, errorType)) &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(statusCode) ^
      const DeepCollectionEquality().hash(errorType) ^
      const DeepCollectionEquality().hash(failedValue);

  @override
  _$HttpFailureCopyWith<T, _HttpFailure<T>> get copyWith =>
      __$HttpFailureCopyWithImpl<T, _HttpFailure<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return httpFailure(statusCode, errorType, failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (httpFailure != null) {
      return httpFailure(statusCode, errorType, failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return httpFailure(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (httpFailure != null) {
      return httpFailure(this);
    }
    return orElse();
  }
}

abstract class _HttpFailure<T> extends RestfulFailure<T> {
  const _HttpFailure._() : super._();
  const factory _HttpFailure(
      {int statusCode, String errorType, T failedValue}) = _$_HttpFailure<T>;

  int get statusCode;
  String get errorType;
  T get failedValue;
  _$HttpFailureCopyWith<T, _HttpFailure<T>> get copyWith;
}

/// @nodoc
abstract class _$UnknownFailureCopyWith<T, $Res> {
  factory _$UnknownFailureCopyWith(
          _UnknownFailure<T> value, $Res Function(_UnknownFailure<T>) then) =
      __$UnknownFailureCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$UnknownFailureCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$UnknownFailureCopyWith<T, $Res> {
  __$UnknownFailureCopyWithImpl(
      _UnknownFailure<T> _value, $Res Function(_UnknownFailure<T>) _then)
      : super(_value, (v) => _then(v as _UnknownFailure<T>));

  @override
  _UnknownFailure<T> get _value => super._value as _UnknownFailure<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_UnknownFailure<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_UnknownFailure<T> extends _UnknownFailure<T> {
  const _$_UnknownFailure({@required this.failedValue})
      : assert(failedValue != null),
        super._();

  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.unknownFailure(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UnknownFailure<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$UnknownFailureCopyWith<T, _UnknownFailure<T>> get copyWith =>
      __$UnknownFailureCopyWithImpl<T, _UnknownFailure<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return unknownFailure(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unknownFailure != null) {
      return unknownFailure(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return unknownFailure(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (unknownFailure != null) {
      return unknownFailure(this);
    }
    return orElse();
  }
}

abstract class _UnknownFailure<T> extends RestfulFailure<T> {
  const _UnknownFailure._() : super._();
  const factory _UnknownFailure({@required T failedValue}) =
      _$_UnknownFailure<T>;

  T get failedValue;
  _$UnknownFailureCopyWith<T, _UnknownFailure<T>> get copyWith;
}

/// @nodoc
abstract class _$NoInternetCopyWith<T, $Res> {
  factory _$NoInternetCopyWith(
          _NoInternet<T> value, $Res Function(_NoInternet<T>) then) =
      __$NoInternetCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$NoInternetCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$NoInternetCopyWith<T, $Res> {
  __$NoInternetCopyWithImpl(
      _NoInternet<T> _value, $Res Function(_NoInternet<T>) _then)
      : super(_value, (v) => _then(v as _NoInternet<T>));

  @override
  _NoInternet<T> get _value => super._value as _NoInternet<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_NoInternet<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_NoInternet<T> extends _NoInternet<T> {
  const _$_NoInternet({@required this.failedValue})
      : assert(failedValue != null),
        super._();

  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.noInternet(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _NoInternet<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NoInternetCopyWith<T, _NoInternet<T>> get copyWith =>
      __$NoInternetCopyWithImpl<T, _NoInternet<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return noInternet(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noInternet != null) {
      return noInternet(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return noInternet(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noInternet != null) {
      return noInternet(this);
    }
    return orElse();
  }
}

abstract class _NoInternet<T> extends RestfulFailure<T> {
  const _NoInternet._() : super._();
  const factory _NoInternet({@required T failedValue}) = _$_NoInternet<T>;

  T get failedValue;
  _$NoInternetCopyWith<T, _NoInternet<T>> get copyWith;
}

/// @nodoc
abstract class _$NoTypeCopyWith<T, $Res> {
  factory _$NoTypeCopyWith(_NoType<T> value, $Res Function(_NoType<T>) then) =
      __$NoTypeCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$NoTypeCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$NoTypeCopyWith<T, $Res> {
  __$NoTypeCopyWithImpl(_NoType<T> _value, $Res Function(_NoType<T>) _then)
      : super(_value, (v) => _then(v as _NoType<T>));

  @override
  _NoType<T> get _value => super._value as _NoType<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_NoType<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_NoType<T> extends _NoType<T> {
  const _$_NoType({@required this.failedValue})
      : assert(failedValue != null),
        super._();

  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.noType(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _NoType<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NoTypeCopyWith<T, _NoType<T>> get copyWith =>
      __$NoTypeCopyWithImpl<T, _NoType<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return noType(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noType != null) {
      return noType(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return noType(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noType != null) {
      return noType(this);
    }
    return orElse();
  }
}

abstract class _NoType<T> extends RestfulFailure<T> {
  const _NoType._() : super._();
  const factory _NoType({@required T failedValue}) = _$_NoType<T>;

  T get failedValue;
  _$NoTypeCopyWith<T, _NoType<T>> get copyWith;
}

/// @nodoc
abstract class _$NoIdCopyWith<T, $Res> {
  factory _$NoIdCopyWith(_NoId<T> value, $Res Function(_NoId<T>) then) =
      __$NoIdCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$NoIdCopyWithImpl<T, $Res> extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$NoIdCopyWith<T, $Res> {
  __$NoIdCopyWithImpl(_NoId<T> _value, $Res Function(_NoId<T>) _then)
      : super(_value, (v) => _then(v as _NoId<T>));

  @override
  _NoId<T> get _value => super._value as _NoId<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_NoId<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_NoId<T> extends _NoId<T> {
  const _$_NoId({@required this.failedValue})
      : assert(failedValue != null),
        super._();

  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.noId(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _NoId<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NoIdCopyWith<T, _NoId<T>> get copyWith =>
      __$NoIdCopyWithImpl<T, _NoId<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return noId(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noId != null) {
      return noId(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return noId(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noId != null) {
      return noId(this);
    }
    return orElse();
  }
}

abstract class _NoId<T> extends RestfulFailure<T> {
  const _NoId._() : super._();
  const factory _NoId({@required T failedValue}) = _$_NoId<T>;

  T get failedValue;
  _$NoIdCopyWith<T, _NoId<T>> get copyWith;
}

/// @nodoc
abstract class _$NoVidCopyWith<T, $Res> {
  factory _$NoVidCopyWith(_NoVid<T> value, $Res Function(_NoVid<T>) then) =
      __$NoVidCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$NoVidCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$NoVidCopyWith<T, $Res> {
  __$NoVidCopyWithImpl(_NoVid<T> _value, $Res Function(_NoVid<T>) _then)
      : super(_value, (v) => _then(v as _NoVid<T>));

  @override
  _NoVid<T> get _value => super._value as _NoVid<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_NoVid<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_NoVid<T> extends _NoVid<T> {
  const _$_NoVid({@required this.failedValue})
      : assert(failedValue != null),
        super._();

  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.noVid(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _NoVid<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NoVidCopyWith<T, _NoVid<T>> get copyWith =>
      __$NoVidCopyWithImpl<T, _NoVid<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return noVid(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noVid != null) {
      return noVid(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return noVid(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noVid != null) {
      return noVid(this);
    }
    return orElse();
  }
}

abstract class _NoVid<T> extends RestfulFailure<T> {
  const _NoVid._() : super._();
  const factory _NoVid({@required T failedValue}) = _$_NoVid<T>;

  T get failedValue;
  _$NoVidCopyWith<T, _NoVid<T>> get copyWith;
}

/// @nodoc
abstract class _$IdDoesNotMatchResourceCopyWith<T, $Res> {
  factory _$IdDoesNotMatchResourceCopyWith(_IdDoesNotMatchResource<T> value,
          $Res Function(_IdDoesNotMatchResource<T>) then) =
      __$IdDoesNotMatchResourceCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$IdDoesNotMatchResourceCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$IdDoesNotMatchResourceCopyWith<T, $Res> {
  __$IdDoesNotMatchResourceCopyWithImpl(_IdDoesNotMatchResource<T> _value,
      $Res Function(_IdDoesNotMatchResource<T>) _then)
      : super(_value, (v) => _then(v as _IdDoesNotMatchResource<T>));

  @override
  _IdDoesNotMatchResource<T> get _value =>
      super._value as _IdDoesNotMatchResource<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_IdDoesNotMatchResource<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_IdDoesNotMatchResource<T> extends _IdDoesNotMatchResource<T> {
  const _$_IdDoesNotMatchResource({@required this.failedValue})
      : assert(failedValue != null),
        super._();

  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.idDoesNotMatchResource(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _IdDoesNotMatchResource<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$IdDoesNotMatchResourceCopyWith<T, _IdDoesNotMatchResource<T>>
      get copyWith =>
          __$IdDoesNotMatchResourceCopyWithImpl<T, _IdDoesNotMatchResource<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return idDoesNotMatchResource(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (idDoesNotMatchResource != null) {
      return idDoesNotMatchResource(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return idDoesNotMatchResource(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (idDoesNotMatchResource != null) {
      return idDoesNotMatchResource(this);
    }
    return orElse();
  }
}

abstract class _IdDoesNotMatchResource<T> extends RestfulFailure<T> {
  const _IdDoesNotMatchResource._() : super._();
  const factory _IdDoesNotMatchResource({@required T failedValue}) =
      _$_IdDoesNotMatchResource<T>;

  T get failedValue;
  _$IdDoesNotMatchResourceCopyWith<T, _IdDoesNotMatchResource<T>> get copyWith;
}

/// @nodoc
abstract class _$NoBundleCopyWith<T, $Res> {
  factory _$NoBundleCopyWith(
          _NoBundle<T> value, $Res Function(_NoBundle<T>) then) =
      __$NoBundleCopyWithImpl<T, $Res>;
  $Res call({T failedValue, String batchOrTransaction});
}

/// @nodoc
class __$NoBundleCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$NoBundleCopyWith<T, $Res> {
  __$NoBundleCopyWithImpl(
      _NoBundle<T> _value, $Res Function(_NoBundle<T>) _then)
      : super(_value, (v) => _then(v as _NoBundle<T>));

  @override
  _NoBundle<T> get _value => super._value as _NoBundle<T>;

  @override
  $Res call({
    Object failedValue = freezed,
    Object batchOrTransaction = freezed,
  }) {
    return _then(_NoBundle<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
      batchOrTransaction: batchOrTransaction == freezed
          ? _value.batchOrTransaction
          : batchOrTransaction as String,
    ));
  }
}

/// @nodoc
class _$_NoBundle<T> extends _NoBundle<T> {
  const _$_NoBundle(
      {@required this.failedValue, @required this.batchOrTransaction})
      : assert(failedValue != null),
        assert(batchOrTransaction != null),
        super._();

  @override
  final T failedValue;
  @override
  final String batchOrTransaction;

  @override
  String toString() {
    return 'RestfulFailure<$T>.noBundle(failedValue: $failedValue, batchOrTransaction: $batchOrTransaction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _NoBundle<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)) &&
            (identical(other.batchOrTransaction, batchOrTransaction) ||
                const DeepCollectionEquality()
                    .equals(other.batchOrTransaction, batchOrTransaction)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedValue) ^
      const DeepCollectionEquality().hash(batchOrTransaction);

  @override
  _$NoBundleCopyWith<T, _NoBundle<T>> get copyWith =>
      __$NoBundleCopyWithImpl<T, _NoBundle<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return noBundle(failedValue, batchOrTransaction);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noBundle != null) {
      return noBundle(failedValue, batchOrTransaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return noBundle(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noBundle != null) {
      return noBundle(this);
    }
    return orElse();
  }
}

abstract class _NoBundle<T> extends RestfulFailure<T> {
  const _NoBundle._() : super._();
  const factory _NoBundle(
      {@required T failedValue,
      @required String batchOrTransaction}) = _$_NoBundle<T>;

  T get failedValue;
  String get batchOrTransaction;
  _$NoBundleCopyWith<T, _NoBundle<T>> get copyWith;
}

/// @nodoc
abstract class _$NotABatchBundleCopyWith<T, $Res> {
  factory _$NotABatchBundleCopyWith(
          _NotABatchBundle<T> value, $Res Function(_NotABatchBundle<T>) then) =
      __$NotABatchBundleCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$NotABatchBundleCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$NotABatchBundleCopyWith<T, $Res> {
  __$NotABatchBundleCopyWithImpl(
      _NotABatchBundle<T> _value, $Res Function(_NotABatchBundle<T>) _then)
      : super(_value, (v) => _then(v as _NotABatchBundle<T>));

  @override
  _NotABatchBundle<T> get _value => super._value as _NotABatchBundle<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_NotABatchBundle<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_NotABatchBundle<T> extends _NotABatchBundle<T> {
  const _$_NotABatchBundle({@required this.failedValue})
      : assert(failedValue != null),
        super._();

  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.notABatchBundle(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _NotABatchBundle<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NotABatchBundleCopyWith<T, _NotABatchBundle<T>> get copyWith =>
      __$NotABatchBundleCopyWithImpl<T, _NotABatchBundle<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return notABatchBundle(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (notABatchBundle != null) {
      return notABatchBundle(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return notABatchBundle(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (notABatchBundle != null) {
      return notABatchBundle(this);
    }
    return orElse();
  }
}

abstract class _NotABatchBundle<T> extends RestfulFailure<T> {
  const _NotABatchBundle._() : super._();
  const factory _NotABatchBundle({@required T failedValue}) =
      _$_NotABatchBundle<T>;

  T get failedValue;
  _$NotABatchBundleCopyWith<T, _NotABatchBundle<T>> get copyWith;
}

/// @nodoc
abstract class _$NotATransactionBundleCopyWith<T, $Res> {
  factory _$NotATransactionBundleCopyWith(_NotATransactionBundle<T> value,
          $Res Function(_NotATransactionBundle<T>) then) =
      __$NotATransactionBundleCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$NotATransactionBundleCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$NotATransactionBundleCopyWith<T, $Res> {
  __$NotATransactionBundleCopyWithImpl(_NotATransactionBundle<T> _value,
      $Res Function(_NotATransactionBundle<T>) _then)
      : super(_value, (v) => _then(v as _NotATransactionBundle<T>));

  @override
  _NotATransactionBundle<T> get _value =>
      super._value as _NotATransactionBundle<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_NotATransactionBundle<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_NotATransactionBundle<T> extends _NotATransactionBundle<T> {
  const _$_NotATransactionBundle({@required this.failedValue})
      : assert(failedValue != null),
        super._();

  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.notATransactionBundle(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _NotATransactionBundle<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$NotATransactionBundleCopyWith<T, _NotATransactionBundle<T>> get copyWith =>
      __$NotATransactionBundleCopyWithImpl<T, _NotATransactionBundle<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return notATransactionBundle(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (notATransactionBundle != null) {
      return notATransactionBundle(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return notATransactionBundle(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (notATransactionBundle != null) {
      return notATransactionBundle(this);
    }
    return orElse();
  }
}

abstract class _NotATransactionBundle<T> extends RestfulFailure<T> {
  const _NotATransactionBundle._() : super._();
  const factory _NotATransactionBundle({@required T failedValue}) =
      _$_NotATransactionBundle<T>;

  T get failedValue;
  _$NotATransactionBundleCopyWith<T, _NotATransactionBundle<T>> get copyWith;
}

/// @nodoc
abstract class _$MissingEntryRequestCopyWith<T, $Res> {
  factory _$MissingEntryRequestCopyWith(_MissingEntryRequest<T> value,
          $Res Function(_MissingEntryRequest<T>) then) =
      __$MissingEntryRequestCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$MissingEntryRequestCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$MissingEntryRequestCopyWith<T, $Res> {
  __$MissingEntryRequestCopyWithImpl(_MissingEntryRequest<T> _value,
      $Res Function(_MissingEntryRequest<T>) _then)
      : super(_value, (v) => _then(v as _MissingEntryRequest<T>));

  @override
  _MissingEntryRequest<T> get _value => super._value as _MissingEntryRequest<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_MissingEntryRequest<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_MissingEntryRequest<T> extends _MissingEntryRequest<T> {
  const _$_MissingEntryRequest({@required this.failedValue})
      : assert(failedValue != null),
        super._();

  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.missingEntryRequest(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MissingEntryRequest<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$MissingEntryRequestCopyWith<T, _MissingEntryRequest<T>> get copyWith =>
      __$MissingEntryRequestCopyWithImpl<T, _MissingEntryRequest<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return missingEntryRequest(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (missingEntryRequest != null) {
      return missingEntryRequest(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return missingEntryRequest(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (missingEntryRequest != null) {
      return missingEntryRequest(this);
    }
    return orElse();
  }
}

abstract class _MissingEntryRequest<T> extends RestfulFailure<T> {
  const _MissingEntryRequest._() : super._();
  const factory _MissingEntryRequest({@required T failedValue}) =
      _$_MissingEntryRequest<T>;

  T get failedValue;
  _$MissingEntryRequestCopyWith<T, _MissingEntryRequest<T>> get copyWith;
}

/// @nodoc
abstract class _$MissingRequestMethodCopyWith<T, $Res> {
  factory _$MissingRequestMethodCopyWith(_MissingRequestMethod<T> value,
          $Res Function(_MissingRequestMethod<T>) then) =
      __$MissingRequestMethodCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class __$MissingRequestMethodCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$MissingRequestMethodCopyWith<T, $Res> {
  __$MissingRequestMethodCopyWithImpl(_MissingRequestMethod<T> _value,
      $Res Function(_MissingRequestMethod<T>) _then)
      : super(_value, (v) => _then(v as _MissingRequestMethod<T>));

  @override
  _MissingRequestMethod<T> get _value =>
      super._value as _MissingRequestMethod<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_MissingRequestMethod<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_MissingRequestMethod<T> extends _MissingRequestMethod<T> {
  const _$_MissingRequestMethod({@required this.failedValue})
      : assert(failedValue != null),
        super._();

  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.missingRequestMethod(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MissingRequestMethod<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  _$MissingRequestMethodCopyWith<T, _MissingRequestMethod<T>> get copyWith =>
      __$MissingRequestMethodCopyWithImpl<T, _MissingRequestMethod<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return missingRequestMethod(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (missingRequestMethod != null) {
      return missingRequestMethod(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return missingRequestMethod(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (missingRequestMethod != null) {
      return missingRequestMethod(this);
    }
    return orElse();
  }
}

abstract class _MissingRequestMethod<T> extends RestfulFailure<T> {
  const _MissingRequestMethod._() : super._();
  const factory _MissingRequestMethod({@required T failedValue}) =
      _$_MissingRequestMethod<T>;

  T get failedValue;
  _$MissingRequestMethodCopyWith<T, _MissingRequestMethod<T>> get copyWith;
}

/// @nodoc
abstract class _$PrimitiveFailureCopyWith<T, $Res> {
  factory _$PrimitiveFailureCopyWith(_PrimitiveFailure<T> value,
          $Res Function(_PrimitiveFailure<T>) then) =
      __$PrimitiveFailureCopyWithImpl<T, $Res>;
  $Res call({String parameter, T failedValue});
}

/// @nodoc
class __$PrimitiveFailureCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$PrimitiveFailureCopyWith<T, $Res> {
  __$PrimitiveFailureCopyWithImpl(
      _PrimitiveFailure<T> _value, $Res Function(_PrimitiveFailure<T>) _then)
      : super(_value, (v) => _then(v as _PrimitiveFailure<T>));

  @override
  _PrimitiveFailure<T> get _value => super._value as _PrimitiveFailure<T>;

  @override
  $Res call({
    Object parameter = freezed,
    Object failedValue = freezed,
  }) {
    return _then(_PrimitiveFailure<T>(
      parameter: parameter == freezed ? _value.parameter : parameter as String,
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_PrimitiveFailure<T> extends _PrimitiveFailure<T> {
  const _$_PrimitiveFailure(
      {@required this.parameter, @required this.failedValue})
      : assert(parameter != null),
        assert(failedValue != null),
        super._();

  @override
  final String parameter;
  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.primitiveFailure(parameter: $parameter, failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PrimitiveFailure<T> &&
            (identical(other.parameter, parameter) ||
                const DeepCollectionEquality()
                    .equals(other.parameter, parameter)) &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(parameter) ^
      const DeepCollectionEquality().hash(failedValue);

  @override
  _$PrimitiveFailureCopyWith<T, _PrimitiveFailure<T>> get copyWith =>
      __$PrimitiveFailureCopyWithImpl<T, _PrimitiveFailure<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return primitiveFailure(parameter, failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (primitiveFailure != null) {
      return primitiveFailure(parameter, failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return primitiveFailure(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (primitiveFailure != null) {
      return primitiveFailure(this);
    }
    return orElse();
  }
}

abstract class _PrimitiveFailure<T> extends RestfulFailure<T> {
  const _PrimitiveFailure._() : super._();
  const factory _PrimitiveFailure(
      {@required String parameter,
      @required T failedValue}) = _$_PrimitiveFailure<T>;

  String get parameter;
  T get failedValue;
  _$PrimitiveFailureCopyWith<T, _PrimitiveFailure<T>> get copyWith;
}

/// @nodoc
abstract class _$SearchParameterFailureCopyWith<T, $Res> {
  factory _$SearchParameterFailureCopyWith(_SearchParameterFailure<T> value,
          $Res Function(_SearchParameterFailure<T>) then) =
      __$SearchParameterFailureCopyWithImpl<T, $Res>;
  $Res call({String parameter, T failedValue});
}

/// @nodoc
class __$SearchParameterFailureCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$SearchParameterFailureCopyWith<T, $Res> {
  __$SearchParameterFailureCopyWithImpl(_SearchParameterFailure<T> _value,
      $Res Function(_SearchParameterFailure<T>) _then)
      : super(_value, (v) => _then(v as _SearchParameterFailure<T>));

  @override
  _SearchParameterFailure<T> get _value =>
      super._value as _SearchParameterFailure<T>;

  @override
  $Res call({
    Object parameter = freezed,
    Object failedValue = freezed,
  }) {
    return _then(_SearchParameterFailure<T>(
      parameter: parameter == freezed ? _value.parameter : parameter as String,
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$_SearchParameterFailure<T> extends _SearchParameterFailure<T> {
  const _$_SearchParameterFailure(
      {@required this.parameter, @required this.failedValue})
      : assert(parameter != null),
        assert(failedValue != null),
        super._();

  @override
  final String parameter;
  @override
  final T failedValue;

  @override
  String toString() {
    return 'RestfulFailure<$T>.searchParameterFailure(parameter: $parameter, failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SearchParameterFailure<T> &&
            (identical(other.parameter, parameter) ||
                const DeepCollectionEquality()
                    .equals(other.parameter, parameter)) &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(parameter) ^
      const DeepCollectionEquality().hash(failedValue);

  @override
  _$SearchParameterFailureCopyWith<T, _SearchParameterFailure<T>>
      get copyWith =>
          __$SearchParameterFailureCopyWithImpl<T, _SearchParameterFailure<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return searchParameterFailure(parameter, failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (searchParameterFailure != null) {
      return searchParameterFailure(parameter, failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return searchParameterFailure(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (searchParameterFailure != null) {
      return searchParameterFailure(this);
    }
    return orElse();
  }
}

abstract class _SearchParameterFailure<T> extends RestfulFailure<T> {
  const _SearchParameterFailure._() : super._();
  const factory _SearchParameterFailure(
      {@required String parameter,
      @required T failedValue}) = _$_SearchParameterFailure<T>;

  String get parameter;
  T get failedValue;
  _$SearchParameterFailureCopyWith<T, _SearchParameterFailure<T>> get copyWith;
}

/// @nodoc
abstract class _$EmptySearchParametersCopyWith<T, $Res> {
  factory _$EmptySearchParametersCopyWith(_EmptySearchParameters<T> value,
          $Res Function(_EmptySearchParameters<T>) then) =
      __$EmptySearchParametersCopyWithImpl<T, $Res>;
  $Res call({String parameter});
}

/// @nodoc
class __$EmptySearchParametersCopyWithImpl<T, $Res>
    extends _$RestfulFailureCopyWithImpl<T, $Res>
    implements _$EmptySearchParametersCopyWith<T, $Res> {
  __$EmptySearchParametersCopyWithImpl(_EmptySearchParameters<T> _value,
      $Res Function(_EmptySearchParameters<T>) _then)
      : super(_value, (v) => _then(v as _EmptySearchParameters<T>));

  @override
  _EmptySearchParameters<T> get _value =>
      super._value as _EmptySearchParameters<T>;

  @override
  $Res call({
    Object parameter = freezed,
  }) {
    return _then(_EmptySearchParameters<T>(
      parameter: parameter == freezed ? _value.parameter : parameter as String,
    ));
  }
}

/// @nodoc
class _$_EmptySearchParameters<T> extends _EmptySearchParameters<T> {
  const _$_EmptySearchParameters({@required this.parameter})
      : assert(parameter != null),
        super._();

  @override
  final String parameter;

  @override
  String toString() {
    return 'RestfulFailure<$T>.emptySearchParameters(parameter: $parameter)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EmptySearchParameters<T> &&
            (identical(other.parameter, parameter) ||
                const DeepCollectionEquality()
                    .equals(other.parameter, parameter)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(parameter);

  @override
  _$EmptySearchParametersCopyWith<T, _EmptySearchParameters<T>> get copyWith =>
      __$EmptySearchParametersCopyWithImpl<T, _EmptySearchParameters<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result searchStringTest(String searchString),
    @required
        Result httpFailure(int statusCode, String errorType, T failedValue),
    @required Result unknownFailure(T failedValue),
    @required Result noInternet(T failedValue),
    @required Result noType(T failedValue),
    @required Result noId(T failedValue),
    @required Result noVid(T failedValue),
    @required Result idDoesNotMatchResource(T failedValue),
    @required Result noBundle(T failedValue, String batchOrTransaction),
    @required Result notABatchBundle(T failedValue),
    @required Result notATransactionBundle(T failedValue),
    @required Result missingEntryRequest(T failedValue),
    @required Result missingRequestMethod(T failedValue),
    @required Result primitiveFailure(String parameter, T failedValue),
    @required Result searchParameterFailure(String parameter, T failedValue),
    @required Result emptySearchParameters(String parameter),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return emptySearchParameters(parameter);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result searchStringTest(String searchString),
    Result httpFailure(int statusCode, String errorType, T failedValue),
    Result unknownFailure(T failedValue),
    Result noInternet(T failedValue),
    Result noType(T failedValue),
    Result noId(T failedValue),
    Result noVid(T failedValue),
    Result idDoesNotMatchResource(T failedValue),
    Result noBundle(T failedValue, String batchOrTransaction),
    Result notABatchBundle(T failedValue),
    Result notATransactionBundle(T failedValue),
    Result missingEntryRequest(T failedValue),
    Result missingRequestMethod(T failedValue),
    Result primitiveFailure(String parameter, T failedValue),
    Result searchParameterFailure(String parameter, T failedValue),
    Result emptySearchParameters(String parameter),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emptySearchParameters != null) {
      return emptySearchParameters(parameter);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result searchStringTest(_SearchStringTest<T> value),
    @required Result httpFailure(_HttpFailure<T> value),
    @required Result unknownFailure(_UnknownFailure<T> value),
    @required Result noInternet(_NoInternet<T> value),
    @required Result noType(_NoType<T> value),
    @required Result noId(_NoId<T> value),
    @required Result noVid(_NoVid<T> value),
    @required Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    @required Result noBundle(_NoBundle<T> value),
    @required Result notABatchBundle(_NotABatchBundle<T> value),
    @required Result notATransactionBundle(_NotATransactionBundle<T> value),
    @required Result missingEntryRequest(_MissingEntryRequest<T> value),
    @required Result missingRequestMethod(_MissingRequestMethod<T> value),
    @required Result primitiveFailure(_PrimitiveFailure<T> value),
    @required Result searchParameterFailure(_SearchParameterFailure<T> value),
    @required Result emptySearchParameters(_EmptySearchParameters<T> value),
  }) {
    assert(searchStringTest != null);
    assert(httpFailure != null);
    assert(unknownFailure != null);
    assert(noInternet != null);
    assert(noType != null);
    assert(noId != null);
    assert(noVid != null);
    assert(idDoesNotMatchResource != null);
    assert(noBundle != null);
    assert(notABatchBundle != null);
    assert(notATransactionBundle != null);
    assert(missingEntryRequest != null);
    assert(missingRequestMethod != null);
    assert(primitiveFailure != null);
    assert(searchParameterFailure != null);
    assert(emptySearchParameters != null);
    return emptySearchParameters(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result searchStringTest(_SearchStringTest<T> value),
    Result httpFailure(_HttpFailure<T> value),
    Result unknownFailure(_UnknownFailure<T> value),
    Result noInternet(_NoInternet<T> value),
    Result noType(_NoType<T> value),
    Result noId(_NoId<T> value),
    Result noVid(_NoVid<T> value),
    Result idDoesNotMatchResource(_IdDoesNotMatchResource<T> value),
    Result noBundle(_NoBundle<T> value),
    Result notABatchBundle(_NotABatchBundle<T> value),
    Result notATransactionBundle(_NotATransactionBundle<T> value),
    Result missingEntryRequest(_MissingEntryRequest<T> value),
    Result missingRequestMethod(_MissingRequestMethod<T> value),
    Result primitiveFailure(_PrimitiveFailure<T> value),
    Result searchParameterFailure(_SearchParameterFailure<T> value),
    Result emptySearchParameters(_EmptySearchParameters<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (emptySearchParameters != null) {
      return emptySearchParameters(this);
    }
    return orElse();
  }
}

abstract class _EmptySearchParameters<T> extends RestfulFailure<T> {
  const _EmptySearchParameters._() : super._();
  const factory _EmptySearchParameters({@required String parameter}) =
      _$_EmptySearchParameters<T>;

  String get parameter;
  _$EmptySearchParametersCopyWith<T, _EmptySearchParameters<T>> get copyWith;
}

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'search_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$SearchFailureTearOff {
  const _$SearchFailureTearOff();

// ignore: unused_element
  InvalidSearchNumber<T> invalidSearchNumber<T>({@required T failedValue}) {
    return InvalidSearchNumber<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSearchDate<T> invalidSearchDate<T>({@required T failedValue}) {
    return InvalidSearchDate<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSearchString<T> invalidSearchString<T>({@required T failedValue}) {
    return InvalidSearchString<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSearchToken<T> invalidSearchToken<T>({@required T failedValue}) {
    return InvalidSearchToken<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSearchReference<T> invalidSearchReference<T>(
      {@required T failedValue}) {
    return InvalidSearchReference<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSearchComposite<T> invalidSearchComposite<T>(
      {@required T failedValue}) {
    return InvalidSearchComposite<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSearchQuantity<T> invalidSearchQuantity<T>({@required T failedValue}) {
    return InvalidSearchQuantity<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSearchUri<T> invalidSearchUri<T>({@required T failedValue}) {
    return InvalidSearchUri<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSearchSpecial<T> invalidSearchSpecial<T>({@required T failedValue}) {
    return InvalidSearchSpecial<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidType<T> invalidType<T>({@required T failedValue}) {
    return InvalidType<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidReference<T> invalidReference<T>({@required T failedValue}) {
    return InvalidReference<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $SearchFailure = _$SearchFailureTearOff();

/// @nodoc
mixin _$SearchFailure<T> {
  T get failedValue;

  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  });

  $SearchFailureCopyWith<T, SearchFailure<T>> get copyWith;
}

/// @nodoc
abstract class $SearchFailureCopyWith<T, $Res> {
  factory $SearchFailureCopyWith(
          SearchFailure<T> value, $Res Function(SearchFailure<T>) then) =
      _$SearchFailureCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$SearchFailureCopyWithImpl<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  _$SearchFailureCopyWithImpl(this._value, this._then);

  final SearchFailure<T> _value;
  // ignore: unused_field
  final $Res Function(SearchFailure<T>) _then;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
abstract class $InvalidSearchNumberCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidSearchNumberCopyWith(InvalidSearchNumber<T> value,
          $Res Function(InvalidSearchNumber<T>) then) =
      _$InvalidSearchNumberCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidSearchNumberCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidSearchNumberCopyWith<T, $Res> {
  _$InvalidSearchNumberCopyWithImpl(InvalidSearchNumber<T> _value,
      $Res Function(InvalidSearchNumber<T>) _then)
      : super(_value, (v) => _then(v as InvalidSearchNumber<T>));

  @override
  InvalidSearchNumber<T> get _value => super._value as InvalidSearchNumber<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSearchNumber<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidSearchNumber<T> implements InvalidSearchNumber<T> {
  const _$InvalidSearchNumber({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidSearchNumber(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSearchNumber<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidSearchNumberCopyWith<T, InvalidSearchNumber<T>> get copyWith =>
      _$InvalidSearchNumberCopyWithImpl<T, InvalidSearchNumber<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchNumber(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchNumber != null) {
      return invalidSearchNumber(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchNumber(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchNumber != null) {
      return invalidSearchNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidSearchNumber<T> implements SearchFailure<T> {
  const factory InvalidSearchNumber({@required T failedValue}) =
      _$InvalidSearchNumber<T>;

  @override
  T get failedValue;
  @override
  $InvalidSearchNumberCopyWith<T, InvalidSearchNumber<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSearchDateCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidSearchDateCopyWith(InvalidSearchDate<T> value,
          $Res Function(InvalidSearchDate<T>) then) =
      _$InvalidSearchDateCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidSearchDateCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidSearchDateCopyWith<T, $Res> {
  _$InvalidSearchDateCopyWithImpl(
      InvalidSearchDate<T> _value, $Res Function(InvalidSearchDate<T>) _then)
      : super(_value, (v) => _then(v as InvalidSearchDate<T>));

  @override
  InvalidSearchDate<T> get _value => super._value as InvalidSearchDate<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSearchDate<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidSearchDate<T> implements InvalidSearchDate<T> {
  const _$InvalidSearchDate({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidSearchDate(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSearchDate<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidSearchDateCopyWith<T, InvalidSearchDate<T>> get copyWith =>
      _$InvalidSearchDateCopyWithImpl<T, InvalidSearchDate<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchDate(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchDate != null) {
      return invalidSearchDate(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchDate(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchDate != null) {
      return invalidSearchDate(this);
    }
    return orElse();
  }
}

abstract class InvalidSearchDate<T> implements SearchFailure<T> {
  const factory InvalidSearchDate({@required T failedValue}) =
      _$InvalidSearchDate<T>;

  @override
  T get failedValue;
  @override
  $InvalidSearchDateCopyWith<T, InvalidSearchDate<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSearchStringCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidSearchStringCopyWith(InvalidSearchString<T> value,
          $Res Function(InvalidSearchString<T>) then) =
      _$InvalidSearchStringCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidSearchStringCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidSearchStringCopyWith<T, $Res> {
  _$InvalidSearchStringCopyWithImpl(InvalidSearchString<T> _value,
      $Res Function(InvalidSearchString<T>) _then)
      : super(_value, (v) => _then(v as InvalidSearchString<T>));

  @override
  InvalidSearchString<T> get _value => super._value as InvalidSearchString<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSearchString<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidSearchString<T> implements InvalidSearchString<T> {
  const _$InvalidSearchString({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidSearchString(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSearchString<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidSearchStringCopyWith<T, InvalidSearchString<T>> get copyWith =>
      _$InvalidSearchStringCopyWithImpl<T, InvalidSearchString<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchString(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchString != null) {
      return invalidSearchString(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchString(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchString != null) {
      return invalidSearchString(this);
    }
    return orElse();
  }
}

abstract class InvalidSearchString<T> implements SearchFailure<T> {
  const factory InvalidSearchString({@required T failedValue}) =
      _$InvalidSearchString<T>;

  @override
  T get failedValue;
  @override
  $InvalidSearchStringCopyWith<T, InvalidSearchString<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSearchTokenCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidSearchTokenCopyWith(InvalidSearchToken<T> value,
          $Res Function(InvalidSearchToken<T>) then) =
      _$InvalidSearchTokenCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidSearchTokenCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidSearchTokenCopyWith<T, $Res> {
  _$InvalidSearchTokenCopyWithImpl(
      InvalidSearchToken<T> _value, $Res Function(InvalidSearchToken<T>) _then)
      : super(_value, (v) => _then(v as InvalidSearchToken<T>));

  @override
  InvalidSearchToken<T> get _value => super._value as InvalidSearchToken<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSearchToken<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidSearchToken<T> implements InvalidSearchToken<T> {
  const _$InvalidSearchToken({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidSearchToken(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSearchToken<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidSearchTokenCopyWith<T, InvalidSearchToken<T>> get copyWith =>
      _$InvalidSearchTokenCopyWithImpl<T, InvalidSearchToken<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchToken(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchToken != null) {
      return invalidSearchToken(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchToken(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchToken != null) {
      return invalidSearchToken(this);
    }
    return orElse();
  }
}

abstract class InvalidSearchToken<T> implements SearchFailure<T> {
  const factory InvalidSearchToken({@required T failedValue}) =
      _$InvalidSearchToken<T>;

  @override
  T get failedValue;
  @override
  $InvalidSearchTokenCopyWith<T, InvalidSearchToken<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSearchReferenceCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidSearchReferenceCopyWith(InvalidSearchReference<T> value,
          $Res Function(InvalidSearchReference<T>) then) =
      _$InvalidSearchReferenceCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidSearchReferenceCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidSearchReferenceCopyWith<T, $Res> {
  _$InvalidSearchReferenceCopyWithImpl(InvalidSearchReference<T> _value,
      $Res Function(InvalidSearchReference<T>) _then)
      : super(_value, (v) => _then(v as InvalidSearchReference<T>));

  @override
  InvalidSearchReference<T> get _value =>
      super._value as InvalidSearchReference<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSearchReference<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidSearchReference<T> implements InvalidSearchReference<T> {
  const _$InvalidSearchReference({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidSearchReference(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSearchReference<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidSearchReferenceCopyWith<T, InvalidSearchReference<T>> get copyWith =>
      _$InvalidSearchReferenceCopyWithImpl<T, InvalidSearchReference<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchReference(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchReference != null) {
      return invalidSearchReference(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchReference(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchReference != null) {
      return invalidSearchReference(this);
    }
    return orElse();
  }
}

abstract class InvalidSearchReference<T> implements SearchFailure<T> {
  const factory InvalidSearchReference({@required T failedValue}) =
      _$InvalidSearchReference<T>;

  @override
  T get failedValue;
  @override
  $InvalidSearchReferenceCopyWith<T, InvalidSearchReference<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSearchCompositeCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidSearchCompositeCopyWith(InvalidSearchComposite<T> value,
          $Res Function(InvalidSearchComposite<T>) then) =
      _$InvalidSearchCompositeCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidSearchCompositeCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidSearchCompositeCopyWith<T, $Res> {
  _$InvalidSearchCompositeCopyWithImpl(InvalidSearchComposite<T> _value,
      $Res Function(InvalidSearchComposite<T>) _then)
      : super(_value, (v) => _then(v as InvalidSearchComposite<T>));

  @override
  InvalidSearchComposite<T> get _value =>
      super._value as InvalidSearchComposite<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSearchComposite<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidSearchComposite<T> implements InvalidSearchComposite<T> {
  const _$InvalidSearchComposite({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidSearchComposite(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSearchComposite<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidSearchCompositeCopyWith<T, InvalidSearchComposite<T>> get copyWith =>
      _$InvalidSearchCompositeCopyWithImpl<T, InvalidSearchComposite<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchComposite(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchComposite != null) {
      return invalidSearchComposite(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchComposite(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchComposite != null) {
      return invalidSearchComposite(this);
    }
    return orElse();
  }
}

abstract class InvalidSearchComposite<T> implements SearchFailure<T> {
  const factory InvalidSearchComposite({@required T failedValue}) =
      _$InvalidSearchComposite<T>;

  @override
  T get failedValue;
  @override
  $InvalidSearchCompositeCopyWith<T, InvalidSearchComposite<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSearchQuantityCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidSearchQuantityCopyWith(InvalidSearchQuantity<T> value,
          $Res Function(InvalidSearchQuantity<T>) then) =
      _$InvalidSearchQuantityCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidSearchQuantityCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidSearchQuantityCopyWith<T, $Res> {
  _$InvalidSearchQuantityCopyWithImpl(InvalidSearchQuantity<T> _value,
      $Res Function(InvalidSearchQuantity<T>) _then)
      : super(_value, (v) => _then(v as InvalidSearchQuantity<T>));

  @override
  InvalidSearchQuantity<T> get _value =>
      super._value as InvalidSearchQuantity<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSearchQuantity<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidSearchQuantity<T> implements InvalidSearchQuantity<T> {
  const _$InvalidSearchQuantity({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidSearchQuantity(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSearchQuantity<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidSearchQuantityCopyWith<T, InvalidSearchQuantity<T>> get copyWith =>
      _$InvalidSearchQuantityCopyWithImpl<T, InvalidSearchQuantity<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchQuantity(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchQuantity != null) {
      return invalidSearchQuantity(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchQuantity(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchQuantity != null) {
      return invalidSearchQuantity(this);
    }
    return orElse();
  }
}

abstract class InvalidSearchQuantity<T> implements SearchFailure<T> {
  const factory InvalidSearchQuantity({@required T failedValue}) =
      _$InvalidSearchQuantity<T>;

  @override
  T get failedValue;
  @override
  $InvalidSearchQuantityCopyWith<T, InvalidSearchQuantity<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSearchUriCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidSearchUriCopyWith(
          InvalidSearchUri<T> value, $Res Function(InvalidSearchUri<T>) then) =
      _$InvalidSearchUriCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidSearchUriCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidSearchUriCopyWith<T, $Res> {
  _$InvalidSearchUriCopyWithImpl(
      InvalidSearchUri<T> _value, $Res Function(InvalidSearchUri<T>) _then)
      : super(_value, (v) => _then(v as InvalidSearchUri<T>));

  @override
  InvalidSearchUri<T> get _value => super._value as InvalidSearchUri<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSearchUri<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidSearchUri<T> implements InvalidSearchUri<T> {
  const _$InvalidSearchUri({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidSearchUri(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSearchUri<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidSearchUriCopyWith<T, InvalidSearchUri<T>> get copyWith =>
      _$InvalidSearchUriCopyWithImpl<T, InvalidSearchUri<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchUri(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchUri != null) {
      return invalidSearchUri(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchUri(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchUri != null) {
      return invalidSearchUri(this);
    }
    return orElse();
  }
}

abstract class InvalidSearchUri<T> implements SearchFailure<T> {
  const factory InvalidSearchUri({@required T failedValue}) =
      _$InvalidSearchUri<T>;

  @override
  T get failedValue;
  @override
  $InvalidSearchUriCopyWith<T, InvalidSearchUri<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSearchSpecialCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidSearchSpecialCopyWith(InvalidSearchSpecial<T> value,
          $Res Function(InvalidSearchSpecial<T>) then) =
      _$InvalidSearchSpecialCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidSearchSpecialCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidSearchSpecialCopyWith<T, $Res> {
  _$InvalidSearchSpecialCopyWithImpl(InvalidSearchSpecial<T> _value,
      $Res Function(InvalidSearchSpecial<T>) _then)
      : super(_value, (v) => _then(v as InvalidSearchSpecial<T>));

  @override
  InvalidSearchSpecial<T> get _value => super._value as InvalidSearchSpecial<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSearchSpecial<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidSearchSpecial<T> implements InvalidSearchSpecial<T> {
  const _$InvalidSearchSpecial({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidSearchSpecial(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSearchSpecial<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidSearchSpecialCopyWith<T, InvalidSearchSpecial<T>> get copyWith =>
      _$InvalidSearchSpecialCopyWithImpl<T, InvalidSearchSpecial<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchSpecial(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchSpecial != null) {
      return invalidSearchSpecial(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidSearchSpecial(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidSearchSpecial != null) {
      return invalidSearchSpecial(this);
    }
    return orElse();
  }
}

abstract class InvalidSearchSpecial<T> implements SearchFailure<T> {
  const factory InvalidSearchSpecial({@required T failedValue}) =
      _$InvalidSearchSpecial<T>;

  @override
  T get failedValue;
  @override
  $InvalidSearchSpecialCopyWith<T, InvalidSearchSpecial<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidTypeCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidTypeCopyWith(
          InvalidType<T> value, $Res Function(InvalidType<T>) then) =
      _$InvalidTypeCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidTypeCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidTypeCopyWith<T, $Res> {
  _$InvalidTypeCopyWithImpl(
      InvalidType<T> _value, $Res Function(InvalidType<T>) _then)
      : super(_value, (v) => _then(v as InvalidType<T>));

  @override
  InvalidType<T> get _value => super._value as InvalidType<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidType<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidType<T> implements InvalidType<T> {
  const _$InvalidType({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidType(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidType<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidTypeCopyWith<T, InvalidType<T>> get copyWith =>
      _$InvalidTypeCopyWithImpl<T, InvalidType<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidType(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidType != null) {
      return invalidType(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidType(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidType != null) {
      return invalidType(this);
    }
    return orElse();
  }
}

abstract class InvalidType<T> implements SearchFailure<T> {
  const factory InvalidType({@required T failedValue}) = _$InvalidType<T>;

  @override
  T get failedValue;
  @override
  $InvalidTypeCopyWith<T, InvalidType<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidReferenceCopyWith<T, $Res>
    implements $SearchFailureCopyWith<T, $Res> {
  factory $InvalidReferenceCopyWith(
          InvalidReference<T> value, $Res Function(InvalidReference<T>) then) =
      _$InvalidReferenceCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidReferenceCopyWithImpl<T, $Res>
    extends _$SearchFailureCopyWithImpl<T, $Res>
    implements $InvalidReferenceCopyWith<T, $Res> {
  _$InvalidReferenceCopyWithImpl(
      InvalidReference<T> _value, $Res Function(InvalidReference<T>) _then)
      : super(_value, (v) => _then(v as InvalidReference<T>));

  @override
  InvalidReference<T> get _value => super._value as InvalidReference<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidReference<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$InvalidReference<T> implements InvalidReference<T> {
  const _$InvalidReference({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'SearchFailure<$T>.invalidReference(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidReference<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidReferenceCopyWith<T, InvalidReference<T>> get copyWith =>
      _$InvalidReferenceCopyWithImpl<T, InvalidReference<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result invalidSearchNumber(T failedValue),
    @required Result invalidSearchDate(T failedValue),
    @required Result invalidSearchString(T failedValue),
    @required Result invalidSearchToken(T failedValue),
    @required Result invalidSearchReference(T failedValue),
    @required Result invalidSearchComposite(T failedValue),
    @required Result invalidSearchQuantity(T failedValue),
    @required Result invalidSearchUri(T failedValue),
    @required Result invalidSearchSpecial(T failedValue),
    @required Result invalidType(T failedValue),
    @required Result invalidReference(T failedValue),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidReference(failedValue);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result invalidSearchNumber(T failedValue),
    Result invalidSearchDate(T failedValue),
    Result invalidSearchString(T failedValue),
    Result invalidSearchToken(T failedValue),
    Result invalidSearchReference(T failedValue),
    Result invalidSearchComposite(T failedValue),
    Result invalidSearchQuantity(T failedValue),
    Result invalidSearchUri(T failedValue),
    Result invalidSearchSpecial(T failedValue),
    Result invalidType(T failedValue),
    Result invalidReference(T failedValue),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidReference != null) {
      return invalidReference(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result invalidSearchNumber(InvalidSearchNumber<T> value),
    @required Result invalidSearchDate(InvalidSearchDate<T> value),
    @required Result invalidSearchString(InvalidSearchString<T> value),
    @required Result invalidSearchToken(InvalidSearchToken<T> value),
    @required Result invalidSearchReference(InvalidSearchReference<T> value),
    @required Result invalidSearchComposite(InvalidSearchComposite<T> value),
    @required Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    @required Result invalidSearchUri(InvalidSearchUri<T> value),
    @required Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    @required Result invalidType(InvalidType<T> value),
    @required Result invalidReference(InvalidReference<T> value),
  }) {
    assert(invalidSearchNumber != null);
    assert(invalidSearchDate != null);
    assert(invalidSearchString != null);
    assert(invalidSearchToken != null);
    assert(invalidSearchReference != null);
    assert(invalidSearchComposite != null);
    assert(invalidSearchQuantity != null);
    assert(invalidSearchUri != null);
    assert(invalidSearchSpecial != null);
    assert(invalidType != null);
    assert(invalidReference != null);
    return invalidReference(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result invalidSearchNumber(InvalidSearchNumber<T> value),
    Result invalidSearchDate(InvalidSearchDate<T> value),
    Result invalidSearchString(InvalidSearchString<T> value),
    Result invalidSearchToken(InvalidSearchToken<T> value),
    Result invalidSearchReference(InvalidSearchReference<T> value),
    Result invalidSearchComposite(InvalidSearchComposite<T> value),
    Result invalidSearchQuantity(InvalidSearchQuantity<T> value),
    Result invalidSearchUri(InvalidSearchUri<T> value),
    Result invalidSearchSpecial(InvalidSearchSpecial<T> value),
    Result invalidType(InvalidType<T> value),
    Result invalidReference(InvalidReference<T> value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidReference != null) {
      return invalidReference(this);
    }
    return orElse();
  }
}

abstract class InvalidReference<T> implements SearchFailure<T> {
  const factory InvalidReference({@required T failedValue}) =
      _$InvalidReference<T>;

  @override
  T get failedValue;
  @override
  $InvalidReferenceCopyWith<T, InvalidReference<T>> get copyWith;
}

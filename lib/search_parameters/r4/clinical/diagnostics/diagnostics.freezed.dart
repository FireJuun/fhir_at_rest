// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'diagnostics.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$DiagnosticReportSearchTearOff {
  const _$DiagnosticReportSearchTearOff();

// ignore: unused_element
  _DiagnosticReportSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      List<SearchReference> based_on,
      List<SearchToken> category,
      List<SearchToken> conclusion,
      List<SearchDate> issued,
      List<SearchReference> media,
      List<SearchReference> performer,
      List<SearchReference> result,
      List<SearchReference> results_interpreter,
      List<SearchReference> specimen,
      List<SearchToken> status,
      List<SearchReference> subject}) {
    return _DiagnosticReportSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      code: code,
      date: date,
      identifier: identifier,
      patient: patient,
      encounter: encounter,
      based_on: based_on,
      category: category,
      conclusion: conclusion,
      issued: issued,
      media: media,
      performer: performer,
      result: result,
      results_interpreter: results_interpreter,
      specimen: specimen,
      status: status,
      subject: subject,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $DiagnosticReportSearch = _$DiagnosticReportSearchTearOff();

/// @nodoc
mixin _$DiagnosticReportSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  List<SearchReference> get encounter;
  List<SearchReference> get based_on;
  List<SearchToken> get category;
  List<SearchToken> get conclusion;
  List<SearchDate> get issued;
  List<SearchReference> get media;
  List<SearchReference> get performer;
  List<SearchReference> get result;
  List<SearchReference> get results_interpreter;
  List<SearchReference> get specimen;
  List<SearchToken> get status;
  List<SearchReference> get subject;

  $DiagnosticReportSearchCopyWith<DiagnosticReportSearch> get copyWith;
}

/// @nodoc
abstract class $DiagnosticReportSearchCopyWith<$Res> {
  factory $DiagnosticReportSearchCopyWith(DiagnosticReportSearch value,
          $Res Function(DiagnosticReportSearch) then) =
      _$DiagnosticReportSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      List<SearchReference> based_on,
      List<SearchToken> category,
      List<SearchToken> conclusion,
      List<SearchDate> issued,
      List<SearchReference> media,
      List<SearchReference> performer,
      List<SearchReference> result,
      List<SearchReference> results_interpreter,
      List<SearchReference> specimen,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class _$DiagnosticReportSearchCopyWithImpl<$Res>
    implements $DiagnosticReportSearchCopyWith<$Res> {
  _$DiagnosticReportSearchCopyWithImpl(this._value, this._then);

  final DiagnosticReportSearch _value;
  // ignore: unused_field
  final $Res Function(DiagnosticReportSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object encounter = freezed,
    Object based_on = freezed,
    Object category = freezed,
    Object conclusion = freezed,
    Object issued = freezed,
    Object media = freezed,
    Object performer = freezed,
    Object result = freezed,
    Object results_interpreter = freezed,
    Object specimen = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      based_on: based_on == freezed
          ? _value.based_on
          : based_on as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      conclusion: conclusion == freezed
          ? _value.conclusion
          : conclusion as List<SearchToken>,
      issued: issued == freezed ? _value.issued : issued as List<SearchDate>,
      media: media == freezed ? _value.media : media as List<SearchReference>,
      performer: performer == freezed
          ? _value.performer
          : performer as List<SearchReference>,
      result:
          result == freezed ? _value.result : result as List<SearchReference>,
      results_interpreter: results_interpreter == freezed
          ? _value.results_interpreter
          : results_interpreter as List<SearchReference>,
      specimen: specimen == freezed
          ? _value.specimen
          : specimen as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$DiagnosticReportSearchCopyWith<$Res>
    implements $DiagnosticReportSearchCopyWith<$Res> {
  factory _$DiagnosticReportSearchCopyWith(_DiagnosticReportSearch value,
          $Res Function(_DiagnosticReportSearch) then) =
      __$DiagnosticReportSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      List<SearchReference> based_on,
      List<SearchToken> category,
      List<SearchToken> conclusion,
      List<SearchDate> issued,
      List<SearchReference> media,
      List<SearchReference> performer,
      List<SearchReference> result,
      List<SearchReference> results_interpreter,
      List<SearchReference> specimen,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class __$DiagnosticReportSearchCopyWithImpl<$Res>
    extends _$DiagnosticReportSearchCopyWithImpl<$Res>
    implements _$DiagnosticReportSearchCopyWith<$Res> {
  __$DiagnosticReportSearchCopyWithImpl(_DiagnosticReportSearch _value,
      $Res Function(_DiagnosticReportSearch) _then)
      : super(_value, (v) => _then(v as _DiagnosticReportSearch));

  @override
  _DiagnosticReportSearch get _value => super._value as _DiagnosticReportSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object encounter = freezed,
    Object based_on = freezed,
    Object category = freezed,
    Object conclusion = freezed,
    Object issued = freezed,
    Object media = freezed,
    Object performer = freezed,
    Object result = freezed,
    Object results_interpreter = freezed,
    Object specimen = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_DiagnosticReportSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      based_on: based_on == freezed
          ? _value.based_on
          : based_on as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      conclusion: conclusion == freezed
          ? _value.conclusion
          : conclusion as List<SearchToken>,
      issued: issued == freezed ? _value.issued : issued as List<SearchDate>,
      media: media == freezed ? _value.media : media as List<SearchReference>,
      performer: performer == freezed
          ? _value.performer
          : performer as List<SearchReference>,
      result:
          result == freezed ? _value.result : result as List<SearchReference>,
      results_interpreter: results_interpreter == freezed
          ? _value.results_interpreter
          : results_interpreter as List<SearchReference>,
      specimen: specimen == freezed
          ? _value.specimen
          : specimen as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

/// @nodoc
class _$_DiagnosticReportSearch extends _DiagnosticReportSearch {
  _$_DiagnosticReportSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.code,
      this.date,
      this.identifier,
      this.patient,
      this.encounter,
      this.based_on,
      this.category,
      this.conclusion,
      this.issued,
      this.media,
      this.performer,
      this.result,
      this.results_interpreter,
      this.specimen,
      this.status,
      this.subject})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> encounter;
  @override
  final List<SearchReference> based_on;
  @override
  final List<SearchToken> category;
  @override
  final List<SearchToken> conclusion;
  @override
  final List<SearchDate> issued;
  @override
  final List<SearchReference> media;
  @override
  final List<SearchReference> performer;
  @override
  final List<SearchReference> result;
  @override
  final List<SearchReference> results_interpreter;
  @override
  final List<SearchReference> specimen;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;

  @override
  String toString() {
    return 'DiagnosticReportSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, code: $code, date: $date, identifier: $identifier, patient: $patient, encounter: $encounter, based_on: $based_on, category: $category, conclusion: $conclusion, issued: $issued, media: $media, performer: $performer, result: $result, results_interpreter: $results_interpreter, specimen: $specimen, status: $status, subject: $subject)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DiagnosticReportSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.based_on, based_on) ||
                const DeepCollectionEquality()
                    .equals(other.based_on, based_on)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.conclusion, conclusion) ||
                const DeepCollectionEquality()
                    .equals(other.conclusion, conclusion)) &&
            (identical(other.issued, issued) ||
                const DeepCollectionEquality().equals(other.issued, issued)) &&
            (identical(other.media, media) ||
                const DeepCollectionEquality().equals(other.media, media)) &&
            (identical(other.performer, performer) ||
                const DeepCollectionEquality()
                    .equals(other.performer, performer)) &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.results_interpreter, results_interpreter) ||
                const DeepCollectionEquality()
                    .equals(other.results_interpreter, results_interpreter)) &&
            (identical(other.specimen, specimen) ||
                const DeepCollectionEquality()
                    .equals(other.specimen, specimen)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality().equals(other.subject, subject)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(based_on) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(conclusion) ^
      const DeepCollectionEquality().hash(issued) ^
      const DeepCollectionEquality().hash(media) ^
      const DeepCollectionEquality().hash(performer) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(results_interpreter) ^
      const DeepCollectionEquality().hash(specimen) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject);

  @override
  _$DiagnosticReportSearchCopyWith<_DiagnosticReportSearch> get copyWith =>
      __$DiagnosticReportSearchCopyWithImpl<_DiagnosticReportSearch>(
          this, _$identity);
}

abstract class _DiagnosticReportSearch extends DiagnosticReportSearch {
  _DiagnosticReportSearch._() : super._();
  factory _DiagnosticReportSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      List<SearchReference> based_on,
      List<SearchToken> category,
      List<SearchToken> conclusion,
      List<SearchDate> issued,
      List<SearchReference> media,
      List<SearchReference> performer,
      List<SearchReference> result,
      List<SearchReference> results_interpreter,
      List<SearchReference> specimen,
      List<SearchToken> status,
      List<SearchReference> subject}) = _$_DiagnosticReportSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get encounter;
  @override
  List<SearchReference> get based_on;
  @override
  List<SearchToken> get category;
  @override
  List<SearchToken> get conclusion;
  @override
  List<SearchDate> get issued;
  @override
  List<SearchReference> get media;
  @override
  List<SearchReference> get performer;
  @override
  List<SearchReference> get result;
  @override
  List<SearchReference> get results_interpreter;
  @override
  List<SearchReference> get specimen;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  _$DiagnosticReportSearchCopyWith<_DiagnosticReportSearch> get copyWith;
}

/// @nodoc
class _$ObservationSearchTearOff {
  const _$ObservationSearchTearOff();

// ignore: unused_element
  _ObservationSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      List<SearchReference> based_on,
      List<SearchToken> category,
      List<SearchToken> combo_code,
      List<SearchToken> combo_data_absent_reason,
      List<SearchToken> combo_value_concept,
      List<SearchQuantity> combo_value_quantity,
      List<SearchToken> component_code,
      List<SearchToken> component_data_absent_reason,
      List<SearchToken> component_value_concept,
      List<SearchQuantity> component_value_quantity,
      List<SearchToken> data_absent_reason,
      List<SearchReference> derived_from,
      List<SearchReference> device,
      List<SearchReference> focus,
      List<SearchReference> has_member,
      List<SearchToken> method,
      List<SearchReference> part_of,
      List<SearchReference> performer,
      List<SearchReference> specimen,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> value_concept,
      List<SearchDate> value_date,
      List<SearchQuantity> value_quantity,
      List<SearchString> value_string,
      List<SearchComposite> code_value_concept,
      List<SearchComposite> code_value_date,
      List<SearchComposite> code_value_quantity,
      List<SearchComposite> code_value_string,
      List<SearchComposite> combo_code_value_concept,
      List<SearchComposite> combo_code_value_quantity,
      List<SearchComposite> component_code_value_concept,
      List<SearchComposite> component_code_value_quantity}) {
    return _ObservationSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      code: code,
      date: date,
      identifier: identifier,
      patient: patient,
      encounter: encounter,
      based_on: based_on,
      category: category,
      combo_code: combo_code,
      combo_data_absent_reason: combo_data_absent_reason,
      combo_value_concept: combo_value_concept,
      combo_value_quantity: combo_value_quantity,
      component_code: component_code,
      component_data_absent_reason: component_data_absent_reason,
      component_value_concept: component_value_concept,
      component_value_quantity: component_value_quantity,
      data_absent_reason: data_absent_reason,
      derived_from: derived_from,
      device: device,
      focus: focus,
      has_member: has_member,
      method: method,
      part_of: part_of,
      performer: performer,
      specimen: specimen,
      status: status,
      subject: subject,
      value_concept: value_concept,
      value_date: value_date,
      value_quantity: value_quantity,
      value_string: value_string,
      code_value_concept: code_value_concept,
      code_value_date: code_value_date,
      code_value_quantity: code_value_quantity,
      code_value_string: code_value_string,
      combo_code_value_concept: combo_code_value_concept,
      combo_code_value_quantity: combo_code_value_quantity,
      component_code_value_concept: component_code_value_concept,
      component_code_value_quantity: component_code_value_quantity,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ObservationSearch = _$ObservationSearchTearOff();

/// @nodoc
mixin _$ObservationSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  List<SearchReference> get encounter;
  List<SearchReference> get based_on;
  List<SearchToken> get category;
  List<SearchToken> get combo_code;
  List<SearchToken> get combo_data_absent_reason;
  List<SearchToken> get combo_value_concept;
  List<SearchQuantity> get combo_value_quantity;
  List<SearchToken> get component_code;
  List<SearchToken> get component_data_absent_reason;
  List<SearchToken> get component_value_concept;
  List<SearchQuantity> get component_value_quantity;
  List<SearchToken> get data_absent_reason;
  List<SearchReference> get derived_from;
  List<SearchReference> get device;
  List<SearchReference> get focus;
  List<SearchReference> get has_member;
  List<SearchToken> get method;
  List<SearchReference> get part_of;
  List<SearchReference> get performer;
  List<SearchReference> get specimen;
  List<SearchToken> get status;
  List<SearchReference> get subject;
  List<SearchToken> get value_concept;
  List<SearchDate> get value_date;
  List<SearchQuantity> get value_quantity;
  List<SearchString> get value_string;
  List<SearchComposite> get code_value_concept;
  List<SearchComposite> get code_value_date;
  List<SearchComposite> get code_value_quantity;
  List<SearchComposite> get code_value_string;
  List<SearchComposite> get combo_code_value_concept;
  List<SearchComposite> get combo_code_value_quantity;
  List<SearchComposite> get component_code_value_concept;
  List<SearchComposite> get component_code_value_quantity;

  $ObservationSearchCopyWith<ObservationSearch> get copyWith;
}

/// @nodoc
abstract class $ObservationSearchCopyWith<$Res> {
  factory $ObservationSearchCopyWith(
          ObservationSearch value, $Res Function(ObservationSearch) then) =
      _$ObservationSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      List<SearchReference> based_on,
      List<SearchToken> category,
      List<SearchToken> combo_code,
      List<SearchToken> combo_data_absent_reason,
      List<SearchToken> combo_value_concept,
      List<SearchQuantity> combo_value_quantity,
      List<SearchToken> component_code,
      List<SearchToken> component_data_absent_reason,
      List<SearchToken> component_value_concept,
      List<SearchQuantity> component_value_quantity,
      List<SearchToken> data_absent_reason,
      List<SearchReference> derived_from,
      List<SearchReference> device,
      List<SearchReference> focus,
      List<SearchReference> has_member,
      List<SearchToken> method,
      List<SearchReference> part_of,
      List<SearchReference> performer,
      List<SearchReference> specimen,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> value_concept,
      List<SearchDate> value_date,
      List<SearchQuantity> value_quantity,
      List<SearchString> value_string,
      List<SearchComposite> code_value_concept,
      List<SearchComposite> code_value_date,
      List<SearchComposite> code_value_quantity,
      List<SearchComposite> code_value_string,
      List<SearchComposite> combo_code_value_concept,
      List<SearchComposite> combo_code_value_quantity,
      List<SearchComposite> component_code_value_concept,
      List<SearchComposite> component_code_value_quantity});
}

/// @nodoc
class _$ObservationSearchCopyWithImpl<$Res>
    implements $ObservationSearchCopyWith<$Res> {
  _$ObservationSearchCopyWithImpl(this._value, this._then);

  final ObservationSearch _value;
  // ignore: unused_field
  final $Res Function(ObservationSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object encounter = freezed,
    Object based_on = freezed,
    Object category = freezed,
    Object combo_code = freezed,
    Object combo_data_absent_reason = freezed,
    Object combo_value_concept = freezed,
    Object combo_value_quantity = freezed,
    Object component_code = freezed,
    Object component_data_absent_reason = freezed,
    Object component_value_concept = freezed,
    Object component_value_quantity = freezed,
    Object data_absent_reason = freezed,
    Object derived_from = freezed,
    Object device = freezed,
    Object focus = freezed,
    Object has_member = freezed,
    Object method = freezed,
    Object part_of = freezed,
    Object performer = freezed,
    Object specimen = freezed,
    Object status = freezed,
    Object subject = freezed,
    Object value_concept = freezed,
    Object value_date = freezed,
    Object value_quantity = freezed,
    Object value_string = freezed,
    Object code_value_concept = freezed,
    Object code_value_date = freezed,
    Object code_value_quantity = freezed,
    Object code_value_string = freezed,
    Object combo_code_value_concept = freezed,
    Object combo_code_value_quantity = freezed,
    Object component_code_value_concept = freezed,
    Object component_code_value_quantity = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      based_on: based_on == freezed
          ? _value.based_on
          : based_on as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      combo_code: combo_code == freezed
          ? _value.combo_code
          : combo_code as List<SearchToken>,
      combo_data_absent_reason: combo_data_absent_reason == freezed
          ? _value.combo_data_absent_reason
          : combo_data_absent_reason as List<SearchToken>,
      combo_value_concept: combo_value_concept == freezed
          ? _value.combo_value_concept
          : combo_value_concept as List<SearchToken>,
      combo_value_quantity: combo_value_quantity == freezed
          ? _value.combo_value_quantity
          : combo_value_quantity as List<SearchQuantity>,
      component_code: component_code == freezed
          ? _value.component_code
          : component_code as List<SearchToken>,
      component_data_absent_reason: component_data_absent_reason == freezed
          ? _value.component_data_absent_reason
          : component_data_absent_reason as List<SearchToken>,
      component_value_concept: component_value_concept == freezed
          ? _value.component_value_concept
          : component_value_concept as List<SearchToken>,
      component_value_quantity: component_value_quantity == freezed
          ? _value.component_value_quantity
          : component_value_quantity as List<SearchQuantity>,
      data_absent_reason: data_absent_reason == freezed
          ? _value.data_absent_reason
          : data_absent_reason as List<SearchToken>,
      derived_from: derived_from == freezed
          ? _value.derived_from
          : derived_from as List<SearchReference>,
      device:
          device == freezed ? _value.device : device as List<SearchReference>,
      focus: focus == freezed ? _value.focus : focus as List<SearchReference>,
      has_member: has_member == freezed
          ? _value.has_member
          : has_member as List<SearchReference>,
      method: method == freezed ? _value.method : method as List<SearchToken>,
      part_of: part_of == freezed
          ? _value.part_of
          : part_of as List<SearchReference>,
      performer: performer == freezed
          ? _value.performer
          : performer as List<SearchReference>,
      specimen: specimen == freezed
          ? _value.specimen
          : specimen as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      value_concept: value_concept == freezed
          ? _value.value_concept
          : value_concept as List<SearchToken>,
      value_date: value_date == freezed
          ? _value.value_date
          : value_date as List<SearchDate>,
      value_quantity: value_quantity == freezed
          ? _value.value_quantity
          : value_quantity as List<SearchQuantity>,
      value_string: value_string == freezed
          ? _value.value_string
          : value_string as List<SearchString>,
      code_value_concept: code_value_concept == freezed
          ? _value.code_value_concept
          : code_value_concept as List<SearchComposite>,
      code_value_date: code_value_date == freezed
          ? _value.code_value_date
          : code_value_date as List<SearchComposite>,
      code_value_quantity: code_value_quantity == freezed
          ? _value.code_value_quantity
          : code_value_quantity as List<SearchComposite>,
      code_value_string: code_value_string == freezed
          ? _value.code_value_string
          : code_value_string as List<SearchComposite>,
      combo_code_value_concept: combo_code_value_concept == freezed
          ? _value.combo_code_value_concept
          : combo_code_value_concept as List<SearchComposite>,
      combo_code_value_quantity: combo_code_value_quantity == freezed
          ? _value.combo_code_value_quantity
          : combo_code_value_quantity as List<SearchComposite>,
      component_code_value_concept: component_code_value_concept == freezed
          ? _value.component_code_value_concept
          : component_code_value_concept as List<SearchComposite>,
      component_code_value_quantity: component_code_value_quantity == freezed
          ? _value.component_code_value_quantity
          : component_code_value_quantity as List<SearchComposite>,
    ));
  }
}

/// @nodoc
abstract class _$ObservationSearchCopyWith<$Res>
    implements $ObservationSearchCopyWith<$Res> {
  factory _$ObservationSearchCopyWith(
          _ObservationSearch value, $Res Function(_ObservationSearch) then) =
      __$ObservationSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      List<SearchReference> based_on,
      List<SearchToken> category,
      List<SearchToken> combo_code,
      List<SearchToken> combo_data_absent_reason,
      List<SearchToken> combo_value_concept,
      List<SearchQuantity> combo_value_quantity,
      List<SearchToken> component_code,
      List<SearchToken> component_data_absent_reason,
      List<SearchToken> component_value_concept,
      List<SearchQuantity> component_value_quantity,
      List<SearchToken> data_absent_reason,
      List<SearchReference> derived_from,
      List<SearchReference> device,
      List<SearchReference> focus,
      List<SearchReference> has_member,
      List<SearchToken> method,
      List<SearchReference> part_of,
      List<SearchReference> performer,
      List<SearchReference> specimen,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> value_concept,
      List<SearchDate> value_date,
      List<SearchQuantity> value_quantity,
      List<SearchString> value_string,
      List<SearchComposite> code_value_concept,
      List<SearchComposite> code_value_date,
      List<SearchComposite> code_value_quantity,
      List<SearchComposite> code_value_string,
      List<SearchComposite> combo_code_value_concept,
      List<SearchComposite> combo_code_value_quantity,
      List<SearchComposite> component_code_value_concept,
      List<SearchComposite> component_code_value_quantity});
}

/// @nodoc
class __$ObservationSearchCopyWithImpl<$Res>
    extends _$ObservationSearchCopyWithImpl<$Res>
    implements _$ObservationSearchCopyWith<$Res> {
  __$ObservationSearchCopyWithImpl(
      _ObservationSearch _value, $Res Function(_ObservationSearch) _then)
      : super(_value, (v) => _then(v as _ObservationSearch));

  @override
  _ObservationSearch get _value => super._value as _ObservationSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object encounter = freezed,
    Object based_on = freezed,
    Object category = freezed,
    Object combo_code = freezed,
    Object combo_data_absent_reason = freezed,
    Object combo_value_concept = freezed,
    Object combo_value_quantity = freezed,
    Object component_code = freezed,
    Object component_data_absent_reason = freezed,
    Object component_value_concept = freezed,
    Object component_value_quantity = freezed,
    Object data_absent_reason = freezed,
    Object derived_from = freezed,
    Object device = freezed,
    Object focus = freezed,
    Object has_member = freezed,
    Object method = freezed,
    Object part_of = freezed,
    Object performer = freezed,
    Object specimen = freezed,
    Object status = freezed,
    Object subject = freezed,
    Object value_concept = freezed,
    Object value_date = freezed,
    Object value_quantity = freezed,
    Object value_string = freezed,
    Object code_value_concept = freezed,
    Object code_value_date = freezed,
    Object code_value_quantity = freezed,
    Object code_value_string = freezed,
    Object combo_code_value_concept = freezed,
    Object combo_code_value_quantity = freezed,
    Object component_code_value_concept = freezed,
    Object component_code_value_quantity = freezed,
  }) {
    return _then(_ObservationSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      based_on: based_on == freezed
          ? _value.based_on
          : based_on as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      combo_code: combo_code == freezed
          ? _value.combo_code
          : combo_code as List<SearchToken>,
      combo_data_absent_reason: combo_data_absent_reason == freezed
          ? _value.combo_data_absent_reason
          : combo_data_absent_reason as List<SearchToken>,
      combo_value_concept: combo_value_concept == freezed
          ? _value.combo_value_concept
          : combo_value_concept as List<SearchToken>,
      combo_value_quantity: combo_value_quantity == freezed
          ? _value.combo_value_quantity
          : combo_value_quantity as List<SearchQuantity>,
      component_code: component_code == freezed
          ? _value.component_code
          : component_code as List<SearchToken>,
      component_data_absent_reason: component_data_absent_reason == freezed
          ? _value.component_data_absent_reason
          : component_data_absent_reason as List<SearchToken>,
      component_value_concept: component_value_concept == freezed
          ? _value.component_value_concept
          : component_value_concept as List<SearchToken>,
      component_value_quantity: component_value_quantity == freezed
          ? _value.component_value_quantity
          : component_value_quantity as List<SearchQuantity>,
      data_absent_reason: data_absent_reason == freezed
          ? _value.data_absent_reason
          : data_absent_reason as List<SearchToken>,
      derived_from: derived_from == freezed
          ? _value.derived_from
          : derived_from as List<SearchReference>,
      device:
          device == freezed ? _value.device : device as List<SearchReference>,
      focus: focus == freezed ? _value.focus : focus as List<SearchReference>,
      has_member: has_member == freezed
          ? _value.has_member
          : has_member as List<SearchReference>,
      method: method == freezed ? _value.method : method as List<SearchToken>,
      part_of: part_of == freezed
          ? _value.part_of
          : part_of as List<SearchReference>,
      performer: performer == freezed
          ? _value.performer
          : performer as List<SearchReference>,
      specimen: specimen == freezed
          ? _value.specimen
          : specimen as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      value_concept: value_concept == freezed
          ? _value.value_concept
          : value_concept as List<SearchToken>,
      value_date: value_date == freezed
          ? _value.value_date
          : value_date as List<SearchDate>,
      value_quantity: value_quantity == freezed
          ? _value.value_quantity
          : value_quantity as List<SearchQuantity>,
      value_string: value_string == freezed
          ? _value.value_string
          : value_string as List<SearchString>,
      code_value_concept: code_value_concept == freezed
          ? _value.code_value_concept
          : code_value_concept as List<SearchComposite>,
      code_value_date: code_value_date == freezed
          ? _value.code_value_date
          : code_value_date as List<SearchComposite>,
      code_value_quantity: code_value_quantity == freezed
          ? _value.code_value_quantity
          : code_value_quantity as List<SearchComposite>,
      code_value_string: code_value_string == freezed
          ? _value.code_value_string
          : code_value_string as List<SearchComposite>,
      combo_code_value_concept: combo_code_value_concept == freezed
          ? _value.combo_code_value_concept
          : combo_code_value_concept as List<SearchComposite>,
      combo_code_value_quantity: combo_code_value_quantity == freezed
          ? _value.combo_code_value_quantity
          : combo_code_value_quantity as List<SearchComposite>,
      component_code_value_concept: component_code_value_concept == freezed
          ? _value.component_code_value_concept
          : component_code_value_concept as List<SearchComposite>,
      component_code_value_quantity: component_code_value_quantity == freezed
          ? _value.component_code_value_quantity
          : component_code_value_quantity as List<SearchComposite>,
    ));
  }
}

/// @nodoc
class _$_ObservationSearch extends _ObservationSearch {
  _$_ObservationSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.code,
      this.date,
      this.identifier,
      this.patient,
      this.encounter,
      this.based_on,
      this.category,
      this.combo_code,
      this.combo_data_absent_reason,
      this.combo_value_concept,
      this.combo_value_quantity,
      this.component_code,
      this.component_data_absent_reason,
      this.component_value_concept,
      this.component_value_quantity,
      this.data_absent_reason,
      this.derived_from,
      this.device,
      this.focus,
      this.has_member,
      this.method,
      this.part_of,
      this.performer,
      this.specimen,
      this.status,
      this.subject,
      this.value_concept,
      this.value_date,
      this.value_quantity,
      this.value_string,
      this.code_value_concept,
      this.code_value_date,
      this.code_value_quantity,
      this.code_value_string,
      this.combo_code_value_concept,
      this.combo_code_value_quantity,
      this.component_code_value_concept,
      this.component_code_value_quantity})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> encounter;
  @override
  final List<SearchReference> based_on;
  @override
  final List<SearchToken> category;
  @override
  final List<SearchToken> combo_code;
  @override
  final List<SearchToken> combo_data_absent_reason;
  @override
  final List<SearchToken> combo_value_concept;
  @override
  final List<SearchQuantity> combo_value_quantity;
  @override
  final List<SearchToken> component_code;
  @override
  final List<SearchToken> component_data_absent_reason;
  @override
  final List<SearchToken> component_value_concept;
  @override
  final List<SearchQuantity> component_value_quantity;
  @override
  final List<SearchToken> data_absent_reason;
  @override
  final List<SearchReference> derived_from;
  @override
  final List<SearchReference> device;
  @override
  final List<SearchReference> focus;
  @override
  final List<SearchReference> has_member;
  @override
  final List<SearchToken> method;
  @override
  final List<SearchReference> part_of;
  @override
  final List<SearchReference> performer;
  @override
  final List<SearchReference> specimen;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;
  @override
  final List<SearchToken> value_concept;
  @override
  final List<SearchDate> value_date;
  @override
  final List<SearchQuantity> value_quantity;
  @override
  final List<SearchString> value_string;
  @override
  final List<SearchComposite> code_value_concept;
  @override
  final List<SearchComposite> code_value_date;
  @override
  final List<SearchComposite> code_value_quantity;
  @override
  final List<SearchComposite> code_value_string;
  @override
  final List<SearchComposite> combo_code_value_concept;
  @override
  final List<SearchComposite> combo_code_value_quantity;
  @override
  final List<SearchComposite> component_code_value_concept;
  @override
  final List<SearchComposite> component_code_value_quantity;

  @override
  String toString() {
    return 'ObservationSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, code: $code, date: $date, identifier: $identifier, patient: $patient, encounter: $encounter, based_on: $based_on, category: $category, combo_code: $combo_code, combo_data_absent_reason: $combo_data_absent_reason, combo_value_concept: $combo_value_concept, combo_value_quantity: $combo_value_quantity, component_code: $component_code, component_data_absent_reason: $component_data_absent_reason, component_value_concept: $component_value_concept, component_value_quantity: $component_value_quantity, data_absent_reason: $data_absent_reason, derived_from: $derived_from, device: $device, focus: $focus, has_member: $has_member, method: $method, part_of: $part_of, performer: $performer, specimen: $specimen, status: $status, subject: $subject, value_concept: $value_concept, value_date: $value_date, value_quantity: $value_quantity, value_string: $value_string, code_value_concept: $code_value_concept, code_value_date: $code_value_date, code_value_quantity: $code_value_quantity, code_value_string: $code_value_string, combo_code_value_concept: $combo_code_value_concept, combo_code_value_quantity: $combo_code_value_quantity, component_code_value_concept: $component_code_value_concept, component_code_value_quantity: $component_code_value_quantity)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ObservationSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.based_on, based_on) ||
                const DeepCollectionEquality()
                    .equals(other.based_on, based_on)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.combo_code, combo_code) ||
                const DeepCollectionEquality()
                    .equals(other.combo_code, combo_code)) &&
            (identical(other.combo_data_absent_reason, combo_data_absent_reason) ||
                const DeepCollectionEquality().equals(
                    other.combo_data_absent_reason,
                    combo_data_absent_reason)) &&
            (identical(other.combo_value_concept, combo_value_concept) ||
                const DeepCollectionEquality()
                    .equals(other.combo_value_concept, combo_value_concept)) &&
            (identical(other.combo_value_quantity, combo_value_quantity) ||
                const DeepCollectionEquality().equals(
                    other.combo_value_quantity, combo_value_quantity)) &&
            (identical(other.component_code, component_code) ||
                const DeepCollectionEquality()
                    .equals(other.component_code, component_code)) &&
            (identical(other.component_data_absent_reason, component_data_absent_reason) ||
                const DeepCollectionEquality().equals(
                    other.component_data_absent_reason, component_data_absent_reason)) &&
            (identical(other.component_value_concept, component_value_concept) || const DeepCollectionEquality().equals(other.component_value_concept, component_value_concept)) &&
            (identical(other.component_value_quantity, component_value_quantity) || const DeepCollectionEquality().equals(other.component_value_quantity, component_value_quantity)) &&
            (identical(other.data_absent_reason, data_absent_reason) || const DeepCollectionEquality().equals(other.data_absent_reason, data_absent_reason)) &&
            (identical(other.derived_from, derived_from) || const DeepCollectionEquality().equals(other.derived_from, derived_from)) &&
            (identical(other.device, device) || const DeepCollectionEquality().equals(other.device, device)) &&
            (identical(other.focus, focus) || const DeepCollectionEquality().equals(other.focus, focus)) &&
            (identical(other.has_member, has_member) || const DeepCollectionEquality().equals(other.has_member, has_member)) &&
            (identical(other.method, method) || const DeepCollectionEquality().equals(other.method, method)) &&
            (identical(other.part_of, part_of) || const DeepCollectionEquality().equals(other.part_of, part_of)) &&
            (identical(other.performer, performer) || const DeepCollectionEquality().equals(other.performer, performer)) &&
            (identical(other.specimen, specimen) || const DeepCollectionEquality().equals(other.specimen, specimen)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) || const DeepCollectionEquality().equals(other.subject, subject)) &&
            (identical(other.value_concept, value_concept) || const DeepCollectionEquality().equals(other.value_concept, value_concept)) &&
            (identical(other.value_date, value_date) || const DeepCollectionEquality().equals(other.value_date, value_date)) &&
            (identical(other.value_quantity, value_quantity) || const DeepCollectionEquality().equals(other.value_quantity, value_quantity)) &&
            (identical(other.value_string, value_string) || const DeepCollectionEquality().equals(other.value_string, value_string)) &&
            (identical(other.code_value_concept, code_value_concept) || const DeepCollectionEquality().equals(other.code_value_concept, code_value_concept)) &&
            (identical(other.code_value_date, code_value_date) || const DeepCollectionEquality().equals(other.code_value_date, code_value_date)) &&
            (identical(other.code_value_quantity, code_value_quantity) || const DeepCollectionEquality().equals(other.code_value_quantity, code_value_quantity)) &&
            (identical(other.code_value_string, code_value_string) || const DeepCollectionEquality().equals(other.code_value_string, code_value_string)) &&
            (identical(other.combo_code_value_concept, combo_code_value_concept) || const DeepCollectionEquality().equals(other.combo_code_value_concept, combo_code_value_concept)) &&
            (identical(other.combo_code_value_quantity, combo_code_value_quantity) || const DeepCollectionEquality().equals(other.combo_code_value_quantity, combo_code_value_quantity)) &&
            (identical(other.component_code_value_concept, component_code_value_concept) || const DeepCollectionEquality().equals(other.component_code_value_concept, component_code_value_concept)) &&
            (identical(other.component_code_value_quantity, component_code_value_quantity) || const DeepCollectionEquality().equals(other.component_code_value_quantity, component_code_value_quantity)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(based_on) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(combo_code) ^
      const DeepCollectionEquality().hash(combo_data_absent_reason) ^
      const DeepCollectionEquality().hash(combo_value_concept) ^
      const DeepCollectionEquality().hash(combo_value_quantity) ^
      const DeepCollectionEquality().hash(component_code) ^
      const DeepCollectionEquality().hash(component_data_absent_reason) ^
      const DeepCollectionEquality().hash(component_value_concept) ^
      const DeepCollectionEquality().hash(component_value_quantity) ^
      const DeepCollectionEquality().hash(data_absent_reason) ^
      const DeepCollectionEquality().hash(derived_from) ^
      const DeepCollectionEquality().hash(device) ^
      const DeepCollectionEquality().hash(focus) ^
      const DeepCollectionEquality().hash(has_member) ^
      const DeepCollectionEquality().hash(method) ^
      const DeepCollectionEquality().hash(part_of) ^
      const DeepCollectionEquality().hash(performer) ^
      const DeepCollectionEquality().hash(specimen) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(value_concept) ^
      const DeepCollectionEquality().hash(value_date) ^
      const DeepCollectionEquality().hash(value_quantity) ^
      const DeepCollectionEquality().hash(value_string) ^
      const DeepCollectionEquality().hash(code_value_concept) ^
      const DeepCollectionEquality().hash(code_value_date) ^
      const DeepCollectionEquality().hash(code_value_quantity) ^
      const DeepCollectionEquality().hash(code_value_string) ^
      const DeepCollectionEquality().hash(combo_code_value_concept) ^
      const DeepCollectionEquality().hash(combo_code_value_quantity) ^
      const DeepCollectionEquality().hash(component_code_value_concept) ^
      const DeepCollectionEquality().hash(component_code_value_quantity);

  @override
  _$ObservationSearchCopyWith<_ObservationSearch> get copyWith =>
      __$ObservationSearchCopyWithImpl<_ObservationSearch>(this, _$identity);
}

abstract class _ObservationSearch extends ObservationSearch {
  _ObservationSearch._() : super._();
  factory _ObservationSearch(
          {List<Id> searchId,
          List<SearchDate> searchLastUpdated,
          List<SearchToken> searchTag,
          List<SearchUri> searchProfile,
          List<SearchToken> searchSecurity,
          List<SearchString> searchText,
          List<SearchString> searchContent,
          List<Id> searchList,
          List<SearchToken> code,
          List<SearchDate> date,
          List<SearchToken> identifier,
          List<SearchReference> patient,
          List<SearchReference> encounter,
          List<SearchReference> based_on,
          List<SearchToken> category,
          List<SearchToken> combo_code,
          List<SearchToken> combo_data_absent_reason,
          List<SearchToken> combo_value_concept,
          List<SearchQuantity> combo_value_quantity,
          List<SearchToken> component_code,
          List<SearchToken> component_data_absent_reason,
          List<SearchToken> component_value_concept,
          List<SearchQuantity> component_value_quantity,
          List<SearchToken> data_absent_reason,
          List<SearchReference> derived_from,
          List<SearchReference> device,
          List<SearchReference> focus,
          List<SearchReference> has_member,
          List<SearchToken> method,
          List<SearchReference> part_of,
          List<SearchReference> performer,
          List<SearchReference> specimen,
          List<SearchToken> status,
          List<SearchReference> subject,
          List<SearchToken> value_concept,
          List<SearchDate> value_date,
          List<SearchQuantity> value_quantity,
          List<SearchString> value_string,
          List<SearchComposite> code_value_concept,
          List<SearchComposite> code_value_date,
          List<SearchComposite> code_value_quantity,
          List<SearchComposite> code_value_string,
          List<SearchComposite> combo_code_value_concept,
          List<SearchComposite> combo_code_value_quantity,
          List<SearchComposite> component_code_value_concept,
          List<SearchComposite> component_code_value_quantity}) =
      _$_ObservationSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get encounter;
  @override
  List<SearchReference> get based_on;
  @override
  List<SearchToken> get category;
  @override
  List<SearchToken> get combo_code;
  @override
  List<SearchToken> get combo_data_absent_reason;
  @override
  List<SearchToken> get combo_value_concept;
  @override
  List<SearchQuantity> get combo_value_quantity;
  @override
  List<SearchToken> get component_code;
  @override
  List<SearchToken> get component_data_absent_reason;
  @override
  List<SearchToken> get component_value_concept;
  @override
  List<SearchQuantity> get component_value_quantity;
  @override
  List<SearchToken> get data_absent_reason;
  @override
  List<SearchReference> get derived_from;
  @override
  List<SearchReference> get device;
  @override
  List<SearchReference> get focus;
  @override
  List<SearchReference> get has_member;
  @override
  List<SearchToken> get method;
  @override
  List<SearchReference> get part_of;
  @override
  List<SearchReference> get performer;
  @override
  List<SearchReference> get specimen;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  List<SearchToken> get value_concept;
  @override
  List<SearchDate> get value_date;
  @override
  List<SearchQuantity> get value_quantity;
  @override
  List<SearchString> get value_string;
  @override
  List<SearchComposite> get code_value_concept;
  @override
  List<SearchComposite> get code_value_date;
  @override
  List<SearchComposite> get code_value_quantity;
  @override
  List<SearchComposite> get code_value_string;
  @override
  List<SearchComposite> get combo_code_value_concept;
  @override
  List<SearchComposite> get combo_code_value_quantity;
  @override
  List<SearchComposite> get component_code_value_concept;
  @override
  List<SearchComposite> get component_code_value_quantity;
  @override
  _$ObservationSearchCopyWith<_ObservationSearch> get copyWith;
}

/// @nodoc
class _$ImagingStudySearchTearOff {
  const _$ImagingStudySearchTearOff();

// ignore: unused_element
  _ImagingStudySearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> basedon,
      List<SearchToken> bodysite,
      List<SearchToken> dicom_class,
      List<SearchReference> encounter,
      List<SearchReference> endpoint,
      List<SearchToken> instance,
      List<SearchReference> interpreter,
      List<SearchToken> modality,
      List<SearchReference> performer,
      List<SearchToken> reason,
      List<SearchReference> referrer,
      List<SearchToken> series,
      List<SearchDate> started,
      List<SearchToken> status,
      List<SearchReference> subject}) {
    return _ImagingStudySearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      identifier: identifier,
      patient: patient,
      basedon: basedon,
      bodysite: bodysite,
      dicom_class: dicom_class,
      encounter: encounter,
      endpoint: endpoint,
      instance: instance,
      interpreter: interpreter,
      modality: modality,
      performer: performer,
      reason: reason,
      referrer: referrer,
      series: series,
      started: started,
      status: status,
      subject: subject,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ImagingStudySearch = _$ImagingStudySearchTearOff();

/// @nodoc
mixin _$ImagingStudySearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  List<SearchReference> get basedon;
  List<SearchToken> get bodysite;
  List<SearchToken> get dicom_class;
  List<SearchReference> get encounter;
  List<SearchReference> get endpoint;
  List<SearchToken> get instance;
  List<SearchReference> get interpreter;
  List<SearchToken> get modality;
  List<SearchReference> get performer;
  List<SearchToken> get reason;
  List<SearchReference> get referrer;
  List<SearchToken> get series;
  List<SearchDate> get started;
  List<SearchToken> get status;
  List<SearchReference> get subject;

  $ImagingStudySearchCopyWith<ImagingStudySearch> get copyWith;
}

/// @nodoc
abstract class $ImagingStudySearchCopyWith<$Res> {
  factory $ImagingStudySearchCopyWith(
          ImagingStudySearch value, $Res Function(ImagingStudySearch) then) =
      _$ImagingStudySearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> basedon,
      List<SearchToken> bodysite,
      List<SearchToken> dicom_class,
      List<SearchReference> encounter,
      List<SearchReference> endpoint,
      List<SearchToken> instance,
      List<SearchReference> interpreter,
      List<SearchToken> modality,
      List<SearchReference> performer,
      List<SearchToken> reason,
      List<SearchReference> referrer,
      List<SearchToken> series,
      List<SearchDate> started,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class _$ImagingStudySearchCopyWithImpl<$Res>
    implements $ImagingStudySearchCopyWith<$Res> {
  _$ImagingStudySearchCopyWithImpl(this._value, this._then);

  final ImagingStudySearch _value;
  // ignore: unused_field
  final $Res Function(ImagingStudySearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object basedon = freezed,
    Object bodysite = freezed,
    Object dicom_class = freezed,
    Object encounter = freezed,
    Object endpoint = freezed,
    Object instance = freezed,
    Object interpreter = freezed,
    Object modality = freezed,
    Object performer = freezed,
    Object reason = freezed,
    Object referrer = freezed,
    Object series = freezed,
    Object started = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      basedon: basedon == freezed
          ? _value.basedon
          : basedon as List<SearchReference>,
      bodysite:
          bodysite == freezed ? _value.bodysite : bodysite as List<SearchToken>,
      dicom_class: dicom_class == freezed
          ? _value.dicom_class
          : dicom_class as List<SearchToken>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      endpoint: endpoint == freezed
          ? _value.endpoint
          : endpoint as List<SearchReference>,
      instance:
          instance == freezed ? _value.instance : instance as List<SearchToken>,
      interpreter: interpreter == freezed
          ? _value.interpreter
          : interpreter as List<SearchReference>,
      modality:
          modality == freezed ? _value.modality : modality as List<SearchToken>,
      performer: performer == freezed
          ? _value.performer
          : performer as List<SearchReference>,
      reason: reason == freezed ? _value.reason : reason as List<SearchToken>,
      referrer: referrer == freezed
          ? _value.referrer
          : referrer as List<SearchReference>,
      series: series == freezed ? _value.series : series as List<SearchToken>,
      started:
          started == freezed ? _value.started : started as List<SearchDate>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$ImagingStudySearchCopyWith<$Res>
    implements $ImagingStudySearchCopyWith<$Res> {
  factory _$ImagingStudySearchCopyWith(
          _ImagingStudySearch value, $Res Function(_ImagingStudySearch) then) =
      __$ImagingStudySearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> basedon,
      List<SearchToken> bodysite,
      List<SearchToken> dicom_class,
      List<SearchReference> encounter,
      List<SearchReference> endpoint,
      List<SearchToken> instance,
      List<SearchReference> interpreter,
      List<SearchToken> modality,
      List<SearchReference> performer,
      List<SearchToken> reason,
      List<SearchReference> referrer,
      List<SearchToken> series,
      List<SearchDate> started,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class __$ImagingStudySearchCopyWithImpl<$Res>
    extends _$ImagingStudySearchCopyWithImpl<$Res>
    implements _$ImagingStudySearchCopyWith<$Res> {
  __$ImagingStudySearchCopyWithImpl(
      _ImagingStudySearch _value, $Res Function(_ImagingStudySearch) _then)
      : super(_value, (v) => _then(v as _ImagingStudySearch));

  @override
  _ImagingStudySearch get _value => super._value as _ImagingStudySearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object basedon = freezed,
    Object bodysite = freezed,
    Object dicom_class = freezed,
    Object encounter = freezed,
    Object endpoint = freezed,
    Object instance = freezed,
    Object interpreter = freezed,
    Object modality = freezed,
    Object performer = freezed,
    Object reason = freezed,
    Object referrer = freezed,
    Object series = freezed,
    Object started = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_ImagingStudySearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      basedon: basedon == freezed
          ? _value.basedon
          : basedon as List<SearchReference>,
      bodysite:
          bodysite == freezed ? _value.bodysite : bodysite as List<SearchToken>,
      dicom_class: dicom_class == freezed
          ? _value.dicom_class
          : dicom_class as List<SearchToken>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      endpoint: endpoint == freezed
          ? _value.endpoint
          : endpoint as List<SearchReference>,
      instance:
          instance == freezed ? _value.instance : instance as List<SearchToken>,
      interpreter: interpreter == freezed
          ? _value.interpreter
          : interpreter as List<SearchReference>,
      modality:
          modality == freezed ? _value.modality : modality as List<SearchToken>,
      performer: performer == freezed
          ? _value.performer
          : performer as List<SearchReference>,
      reason: reason == freezed ? _value.reason : reason as List<SearchToken>,
      referrer: referrer == freezed
          ? _value.referrer
          : referrer as List<SearchReference>,
      series: series == freezed ? _value.series : series as List<SearchToken>,
      started:
          started == freezed ? _value.started : started as List<SearchDate>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

/// @nodoc
class _$_ImagingStudySearch extends _ImagingStudySearch {
  _$_ImagingStudySearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.identifier,
      this.patient,
      this.basedon,
      this.bodysite,
      this.dicom_class,
      this.encounter,
      this.endpoint,
      this.instance,
      this.interpreter,
      this.modality,
      this.performer,
      this.reason,
      this.referrer,
      this.series,
      this.started,
      this.status,
      this.subject})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> basedon;
  @override
  final List<SearchToken> bodysite;
  @override
  final List<SearchToken> dicom_class;
  @override
  final List<SearchReference> encounter;
  @override
  final List<SearchReference> endpoint;
  @override
  final List<SearchToken> instance;
  @override
  final List<SearchReference> interpreter;
  @override
  final List<SearchToken> modality;
  @override
  final List<SearchReference> performer;
  @override
  final List<SearchToken> reason;
  @override
  final List<SearchReference> referrer;
  @override
  final List<SearchToken> series;
  @override
  final List<SearchDate> started;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;

  @override
  String toString() {
    return 'ImagingStudySearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, identifier: $identifier, patient: $patient, basedon: $basedon, bodysite: $bodysite, dicom_class: $dicom_class, encounter: $encounter, endpoint: $endpoint, instance: $instance, interpreter: $interpreter, modality: $modality, performer: $performer, reason: $reason, referrer: $referrer, series: $series, started: $started, status: $status, subject: $subject)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ImagingStudySearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.basedon, basedon) ||
                const DeepCollectionEquality()
                    .equals(other.basedon, basedon)) &&
            (identical(other.bodysite, bodysite) ||
                const DeepCollectionEquality()
                    .equals(other.bodysite, bodysite)) &&
            (identical(other.dicom_class, dicom_class) ||
                const DeepCollectionEquality()
                    .equals(other.dicom_class, dicom_class)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.endpoint, endpoint) ||
                const DeepCollectionEquality()
                    .equals(other.endpoint, endpoint)) &&
            (identical(other.instance, instance) ||
                const DeepCollectionEquality()
                    .equals(other.instance, instance)) &&
            (identical(other.interpreter, interpreter) ||
                const DeepCollectionEquality()
                    .equals(other.interpreter, interpreter)) &&
            (identical(other.modality, modality) ||
                const DeepCollectionEquality()
                    .equals(other.modality, modality)) &&
            (identical(other.performer, performer) ||
                const DeepCollectionEquality()
                    .equals(other.performer, performer)) &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)) &&
            (identical(other.referrer, referrer) ||
                const DeepCollectionEquality()
                    .equals(other.referrer, referrer)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.started, started) ||
                const DeepCollectionEquality().equals(other.started, started)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) || const DeepCollectionEquality().equals(other.subject, subject)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(basedon) ^
      const DeepCollectionEquality().hash(bodysite) ^
      const DeepCollectionEquality().hash(dicom_class) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(endpoint) ^
      const DeepCollectionEquality().hash(instance) ^
      const DeepCollectionEquality().hash(interpreter) ^
      const DeepCollectionEquality().hash(modality) ^
      const DeepCollectionEquality().hash(performer) ^
      const DeepCollectionEquality().hash(reason) ^
      const DeepCollectionEquality().hash(referrer) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(started) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject);

  @override
  _$ImagingStudySearchCopyWith<_ImagingStudySearch> get copyWith =>
      __$ImagingStudySearchCopyWithImpl<_ImagingStudySearch>(this, _$identity);
}

abstract class _ImagingStudySearch extends ImagingStudySearch {
  _ImagingStudySearch._() : super._();
  factory _ImagingStudySearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> basedon,
      List<SearchToken> bodysite,
      List<SearchToken> dicom_class,
      List<SearchReference> encounter,
      List<SearchReference> endpoint,
      List<SearchToken> instance,
      List<SearchReference> interpreter,
      List<SearchToken> modality,
      List<SearchReference> performer,
      List<SearchToken> reason,
      List<SearchReference> referrer,
      List<SearchToken> series,
      List<SearchDate> started,
      List<SearchToken> status,
      List<SearchReference> subject}) = _$_ImagingStudySearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get basedon;
  @override
  List<SearchToken> get bodysite;
  @override
  List<SearchToken> get dicom_class;
  @override
  List<SearchReference> get encounter;
  @override
  List<SearchReference> get endpoint;
  @override
  List<SearchToken> get instance;
  @override
  List<SearchReference> get interpreter;
  @override
  List<SearchToken> get modality;
  @override
  List<SearchReference> get performer;
  @override
  List<SearchToken> get reason;
  @override
  List<SearchReference> get referrer;
  @override
  List<SearchToken> get series;
  @override
  List<SearchDate> get started;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  _$ImagingStudySearchCopyWith<_ImagingStudySearch> get copyWith;
}

/// @nodoc
class _$BodyStructureSearchTearOff {
  const _$BodyStructureSearchTearOff();

// ignore: unused_element
  _BodyStructureSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchToken> location,
      List<SearchToken> morphology,
      List<SearchReference> patient}) {
    return _BodyStructureSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      identifier: identifier,
      location: location,
      morphology: morphology,
      patient: patient,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $BodyStructureSearch = _$BodyStructureSearchTearOff();

/// @nodoc
mixin _$BodyStructureSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get identifier;
  List<SearchToken> get location;
  List<SearchToken> get morphology;
  List<SearchReference> get patient;

  $BodyStructureSearchCopyWith<BodyStructureSearch> get copyWith;
}

/// @nodoc
abstract class $BodyStructureSearchCopyWith<$Res> {
  factory $BodyStructureSearchCopyWith(
          BodyStructureSearch value, $Res Function(BodyStructureSearch) then) =
      _$BodyStructureSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchToken> location,
      List<SearchToken> morphology,
      List<SearchReference> patient});
}

/// @nodoc
class _$BodyStructureSearchCopyWithImpl<$Res>
    implements $BodyStructureSearchCopyWith<$Res> {
  _$BodyStructureSearchCopyWithImpl(this._value, this._then);

  final BodyStructureSearch _value;
  // ignore: unused_field
  final $Res Function(BodyStructureSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object identifier = freezed,
    Object location = freezed,
    Object morphology = freezed,
    Object patient = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      location:
          location == freezed ? _value.location : location as List<SearchToken>,
      morphology: morphology == freezed
          ? _value.morphology
          : morphology as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$BodyStructureSearchCopyWith<$Res>
    implements $BodyStructureSearchCopyWith<$Res> {
  factory _$BodyStructureSearchCopyWith(_BodyStructureSearch value,
          $Res Function(_BodyStructureSearch) then) =
      __$BodyStructureSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchToken> location,
      List<SearchToken> morphology,
      List<SearchReference> patient});
}

/// @nodoc
class __$BodyStructureSearchCopyWithImpl<$Res>
    extends _$BodyStructureSearchCopyWithImpl<$Res>
    implements _$BodyStructureSearchCopyWith<$Res> {
  __$BodyStructureSearchCopyWithImpl(
      _BodyStructureSearch _value, $Res Function(_BodyStructureSearch) _then)
      : super(_value, (v) => _then(v as _BodyStructureSearch));

  @override
  _BodyStructureSearch get _value => super._value as _BodyStructureSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object identifier = freezed,
    Object location = freezed,
    Object morphology = freezed,
    Object patient = freezed,
  }) {
    return _then(_BodyStructureSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      location:
          location == freezed ? _value.location : location as List<SearchToken>,
      morphology: morphology == freezed
          ? _value.morphology
          : morphology as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
    ));
  }
}

/// @nodoc
class _$_BodyStructureSearch extends _BodyStructureSearch {
  _$_BodyStructureSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.identifier,
      this.location,
      this.morphology,
      this.patient})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> identifier;
  @override
  final List<SearchToken> location;
  @override
  final List<SearchToken> morphology;
  @override
  final List<SearchReference> patient;

  @override
  String toString() {
    return 'BodyStructureSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, identifier: $identifier, location: $location, morphology: $morphology, patient: $patient)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BodyStructureSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.morphology, morphology) ||
                const DeepCollectionEquality()
                    .equals(other.morphology, morphology)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality().equals(other.patient, patient)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(morphology) ^
      const DeepCollectionEquality().hash(patient);

  @override
  _$BodyStructureSearchCopyWith<_BodyStructureSearch> get copyWith =>
      __$BodyStructureSearchCopyWithImpl<_BodyStructureSearch>(
          this, _$identity);
}

abstract class _BodyStructureSearch extends BodyStructureSearch {
  _BodyStructureSearch._() : super._();
  factory _BodyStructureSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchToken> location,
      List<SearchToken> morphology,
      List<SearchReference> patient}) = _$_BodyStructureSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get identifier;
  @override
  List<SearchToken> get location;
  @override
  List<SearchToken> get morphology;
  @override
  List<SearchReference> get patient;
  @override
  _$BodyStructureSearchCopyWith<_BodyStructureSearch> get copyWith;
}

/// @nodoc
class _$MediaSearchTearOff {
  const _$MediaSearchTearOff();

// ignore: unused_element
  _MediaSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> based_on,
      List<SearchDate> created,
      List<SearchReference> device,
      List<SearchReference> encounter,
      List<SearchToken> identifier,
      List<SearchToken> modality,
      List<SearchReference> operator,
      List<SearchReference> patient,
      List<SearchToken> site,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> type,
      List<SearchToken> view}) {
    return _MediaSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      based_on: based_on,
      created: created,
      device: device,
      encounter: encounter,
      identifier: identifier,
      modality: modality,
      operator: operator,
      patient: patient,
      site: site,
      status: status,
      subject: subject,
      type: type,
      view: view,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $MediaSearch = _$MediaSearchTearOff();

/// @nodoc
mixin _$MediaSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get based_on;
  List<SearchDate> get created;
  List<SearchReference> get device;
  List<SearchReference> get encounter;
  List<SearchToken> get identifier;
  List<SearchToken> get modality;
  List<SearchReference> get operator;
  List<SearchReference> get patient;
  List<SearchToken> get site;
  List<SearchToken> get status;
  List<SearchReference> get subject;
  List<SearchToken> get type;
  List<SearchToken> get view;

  $MediaSearchCopyWith<MediaSearch> get copyWith;
}

/// @nodoc
abstract class $MediaSearchCopyWith<$Res> {
  factory $MediaSearchCopyWith(
          MediaSearch value, $Res Function(MediaSearch) then) =
      _$MediaSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> based_on,
      List<SearchDate> created,
      List<SearchReference> device,
      List<SearchReference> encounter,
      List<SearchToken> identifier,
      List<SearchToken> modality,
      List<SearchReference> operator,
      List<SearchReference> patient,
      List<SearchToken> site,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> type,
      List<SearchToken> view});
}

/// @nodoc
class _$MediaSearchCopyWithImpl<$Res> implements $MediaSearchCopyWith<$Res> {
  _$MediaSearchCopyWithImpl(this._value, this._then);

  final MediaSearch _value;
  // ignore: unused_field
  final $Res Function(MediaSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object based_on = freezed,
    Object created = freezed,
    Object device = freezed,
    Object encounter = freezed,
    Object identifier = freezed,
    Object modality = freezed,
    Object operator = freezed,
    Object patient = freezed,
    Object site = freezed,
    Object status = freezed,
    Object subject = freezed,
    Object type = freezed,
    Object view = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      based_on: based_on == freezed
          ? _value.based_on
          : based_on as List<SearchReference>,
      created:
          created == freezed ? _value.created : created as List<SearchDate>,
      device:
          device == freezed ? _value.device : device as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      modality:
          modality == freezed ? _value.modality : modality as List<SearchToken>,
      operator: operator == freezed
          ? _value.operator
          : operator as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      site: site == freezed ? _value.site : site as List<SearchToken>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      view: view == freezed ? _value.view : view as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$MediaSearchCopyWith<$Res>
    implements $MediaSearchCopyWith<$Res> {
  factory _$MediaSearchCopyWith(
          _MediaSearch value, $Res Function(_MediaSearch) then) =
      __$MediaSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> based_on,
      List<SearchDate> created,
      List<SearchReference> device,
      List<SearchReference> encounter,
      List<SearchToken> identifier,
      List<SearchToken> modality,
      List<SearchReference> operator,
      List<SearchReference> patient,
      List<SearchToken> site,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> type,
      List<SearchToken> view});
}

/// @nodoc
class __$MediaSearchCopyWithImpl<$Res> extends _$MediaSearchCopyWithImpl<$Res>
    implements _$MediaSearchCopyWith<$Res> {
  __$MediaSearchCopyWithImpl(
      _MediaSearch _value, $Res Function(_MediaSearch) _then)
      : super(_value, (v) => _then(v as _MediaSearch));

  @override
  _MediaSearch get _value => super._value as _MediaSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object based_on = freezed,
    Object created = freezed,
    Object device = freezed,
    Object encounter = freezed,
    Object identifier = freezed,
    Object modality = freezed,
    Object operator = freezed,
    Object patient = freezed,
    Object site = freezed,
    Object status = freezed,
    Object subject = freezed,
    Object type = freezed,
    Object view = freezed,
  }) {
    return _then(_MediaSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      based_on: based_on == freezed
          ? _value.based_on
          : based_on as List<SearchReference>,
      created:
          created == freezed ? _value.created : created as List<SearchDate>,
      device:
          device == freezed ? _value.device : device as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      modality:
          modality == freezed ? _value.modality : modality as List<SearchToken>,
      operator: operator == freezed
          ? _value.operator
          : operator as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      site: site == freezed ? _value.site : site as List<SearchToken>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      view: view == freezed ? _value.view : view as List<SearchToken>,
    ));
  }
}

/// @nodoc
class _$_MediaSearch extends _MediaSearch {
  _$_MediaSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.based_on,
      this.created,
      this.device,
      this.encounter,
      this.identifier,
      this.modality,
      this.operator,
      this.patient,
      this.site,
      this.status,
      this.subject,
      this.type,
      this.view})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchReference> based_on;
  @override
  final List<SearchDate> created;
  @override
  final List<SearchReference> device;
  @override
  final List<SearchReference> encounter;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchToken> modality;
  @override
  final List<SearchReference> operator;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchToken> site;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;
  @override
  final List<SearchToken> type;
  @override
  final List<SearchToken> view;

  @override
  String toString() {
    return 'MediaSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, based_on: $based_on, created: $created, device: $device, encounter: $encounter, identifier: $identifier, modality: $modality, operator: $operator, patient: $patient, site: $site, status: $status, subject: $subject, type: $type, view: $view)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MediaSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.based_on, based_on) ||
                const DeepCollectionEquality()
                    .equals(other.based_on, based_on)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.modality, modality) ||
                const DeepCollectionEquality()
                    .equals(other.modality, modality)) &&
            (identical(other.operator, operator) ||
                const DeepCollectionEquality()
                    .equals(other.operator, operator)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.site, site) ||
                const DeepCollectionEquality().equals(other.site, site)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.view, view) ||
                const DeepCollectionEquality().equals(other.view, view)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(based_on) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(device) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(modality) ^
      const DeepCollectionEquality().hash(operator) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(site) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(view);

  @override
  _$MediaSearchCopyWith<_MediaSearch> get copyWith =>
      __$MediaSearchCopyWithImpl<_MediaSearch>(this, _$identity);
}

abstract class _MediaSearch extends MediaSearch {
  _MediaSearch._() : super._();
  factory _MediaSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> based_on,
      List<SearchDate> created,
      List<SearchReference> device,
      List<SearchReference> encounter,
      List<SearchToken> identifier,
      List<SearchToken> modality,
      List<SearchReference> operator,
      List<SearchReference> patient,
      List<SearchToken> site,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> type,
      List<SearchToken> view}) = _$_MediaSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get based_on;
  @override
  List<SearchDate> get created;
  @override
  List<SearchReference> get device;
  @override
  List<SearchReference> get encounter;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchToken> get modality;
  @override
  List<SearchReference> get operator;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchToken> get site;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  List<SearchToken> get type;
  @override
  List<SearchToken> get view;
  @override
  _$MediaSearchCopyWith<_MediaSearch> get copyWith;
}

/// @nodoc
class _$MolecularSequenceSearchTearOff {
  const _$MolecularSequenceSearchTearOff();

// ignore: unused_element
  _MolecularSequenceSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> chromosome,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchToken> referenceseqid,
      List<SearchToken> type,
      List<SearchNumber> variant_end,
      List<SearchNumber> variant_start,
      List<SearchNumber> window_end,
      List<SearchNumber> window_start,
      List<SearchComposite> chromosome_variant_coordinate,
      List<SearchComposite> chromosome_window_coordinate,
      List<SearchComposite> referenceseqid_variant_coordinate,
      List<SearchComposite> referenceseqid_window_coordinate}) {
    return _MolecularSequenceSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      chromosome: chromosome,
      identifier: identifier,
      patient: patient,
      referenceseqid: referenceseqid,
      type: type,
      variant_end: variant_end,
      variant_start: variant_start,
      window_end: window_end,
      window_start: window_start,
      chromosome_variant_coordinate: chromosome_variant_coordinate,
      chromosome_window_coordinate: chromosome_window_coordinate,
      referenceseqid_variant_coordinate: referenceseqid_variant_coordinate,
      referenceseqid_window_coordinate: referenceseqid_window_coordinate,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $MolecularSequenceSearch = _$MolecularSequenceSearchTearOff();

/// @nodoc
mixin _$MolecularSequenceSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get chromosome;
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  List<SearchToken> get referenceseqid;
  List<SearchToken> get type;
  List<SearchNumber> get variant_end;
  List<SearchNumber> get variant_start;
  List<SearchNumber> get window_end;
  List<SearchNumber> get window_start;
  List<SearchComposite> get chromosome_variant_coordinate;
  List<SearchComposite> get chromosome_window_coordinate;
  List<SearchComposite> get referenceseqid_variant_coordinate;
  List<SearchComposite> get referenceseqid_window_coordinate;

  $MolecularSequenceSearchCopyWith<MolecularSequenceSearch> get copyWith;
}

/// @nodoc
abstract class $MolecularSequenceSearchCopyWith<$Res> {
  factory $MolecularSequenceSearchCopyWith(MolecularSequenceSearch value,
          $Res Function(MolecularSequenceSearch) then) =
      _$MolecularSequenceSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> chromosome,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchToken> referenceseqid,
      List<SearchToken> type,
      List<SearchNumber> variant_end,
      List<SearchNumber> variant_start,
      List<SearchNumber> window_end,
      List<SearchNumber> window_start,
      List<SearchComposite> chromosome_variant_coordinate,
      List<SearchComposite> chromosome_window_coordinate,
      List<SearchComposite> referenceseqid_variant_coordinate,
      List<SearchComposite> referenceseqid_window_coordinate});
}

/// @nodoc
class _$MolecularSequenceSearchCopyWithImpl<$Res>
    implements $MolecularSequenceSearchCopyWith<$Res> {
  _$MolecularSequenceSearchCopyWithImpl(this._value, this._then);

  final MolecularSequenceSearch _value;
  // ignore: unused_field
  final $Res Function(MolecularSequenceSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object chromosome = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object referenceseqid = freezed,
    Object type = freezed,
    Object variant_end = freezed,
    Object variant_start = freezed,
    Object window_end = freezed,
    Object window_start = freezed,
    Object chromosome_variant_coordinate = freezed,
    Object chromosome_window_coordinate = freezed,
    Object referenceseqid_variant_coordinate = freezed,
    Object referenceseqid_window_coordinate = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      chromosome: chromosome == freezed
          ? _value.chromosome
          : chromosome as List<SearchToken>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      referenceseqid: referenceseqid == freezed
          ? _value.referenceseqid
          : referenceseqid as List<SearchToken>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      variant_end: variant_end == freezed
          ? _value.variant_end
          : variant_end as List<SearchNumber>,
      variant_start: variant_start == freezed
          ? _value.variant_start
          : variant_start as List<SearchNumber>,
      window_end: window_end == freezed
          ? _value.window_end
          : window_end as List<SearchNumber>,
      window_start: window_start == freezed
          ? _value.window_start
          : window_start as List<SearchNumber>,
      chromosome_variant_coordinate: chromosome_variant_coordinate == freezed
          ? _value.chromosome_variant_coordinate
          : chromosome_variant_coordinate as List<SearchComposite>,
      chromosome_window_coordinate: chromosome_window_coordinate == freezed
          ? _value.chromosome_window_coordinate
          : chromosome_window_coordinate as List<SearchComposite>,
      referenceseqid_variant_coordinate:
          referenceseqid_variant_coordinate == freezed
              ? _value.referenceseqid_variant_coordinate
              : referenceseqid_variant_coordinate as List<SearchComposite>,
      referenceseqid_window_coordinate:
          referenceseqid_window_coordinate == freezed
              ? _value.referenceseqid_window_coordinate
              : referenceseqid_window_coordinate as List<SearchComposite>,
    ));
  }
}

/// @nodoc
abstract class _$MolecularSequenceSearchCopyWith<$Res>
    implements $MolecularSequenceSearchCopyWith<$Res> {
  factory _$MolecularSequenceSearchCopyWith(_MolecularSequenceSearch value,
          $Res Function(_MolecularSequenceSearch) then) =
      __$MolecularSequenceSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> chromosome,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchToken> referenceseqid,
      List<SearchToken> type,
      List<SearchNumber> variant_end,
      List<SearchNumber> variant_start,
      List<SearchNumber> window_end,
      List<SearchNumber> window_start,
      List<SearchComposite> chromosome_variant_coordinate,
      List<SearchComposite> chromosome_window_coordinate,
      List<SearchComposite> referenceseqid_variant_coordinate,
      List<SearchComposite> referenceseqid_window_coordinate});
}

/// @nodoc
class __$MolecularSequenceSearchCopyWithImpl<$Res>
    extends _$MolecularSequenceSearchCopyWithImpl<$Res>
    implements _$MolecularSequenceSearchCopyWith<$Res> {
  __$MolecularSequenceSearchCopyWithImpl(_MolecularSequenceSearch _value,
      $Res Function(_MolecularSequenceSearch) _then)
      : super(_value, (v) => _then(v as _MolecularSequenceSearch));

  @override
  _MolecularSequenceSearch get _value =>
      super._value as _MolecularSequenceSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object chromosome = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object referenceseqid = freezed,
    Object type = freezed,
    Object variant_end = freezed,
    Object variant_start = freezed,
    Object window_end = freezed,
    Object window_start = freezed,
    Object chromosome_variant_coordinate = freezed,
    Object chromosome_window_coordinate = freezed,
    Object referenceseqid_variant_coordinate = freezed,
    Object referenceseqid_window_coordinate = freezed,
  }) {
    return _then(_MolecularSequenceSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      chromosome: chromosome == freezed
          ? _value.chromosome
          : chromosome as List<SearchToken>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      referenceseqid: referenceseqid == freezed
          ? _value.referenceseqid
          : referenceseqid as List<SearchToken>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      variant_end: variant_end == freezed
          ? _value.variant_end
          : variant_end as List<SearchNumber>,
      variant_start: variant_start == freezed
          ? _value.variant_start
          : variant_start as List<SearchNumber>,
      window_end: window_end == freezed
          ? _value.window_end
          : window_end as List<SearchNumber>,
      window_start: window_start == freezed
          ? _value.window_start
          : window_start as List<SearchNumber>,
      chromosome_variant_coordinate: chromosome_variant_coordinate == freezed
          ? _value.chromosome_variant_coordinate
          : chromosome_variant_coordinate as List<SearchComposite>,
      chromosome_window_coordinate: chromosome_window_coordinate == freezed
          ? _value.chromosome_window_coordinate
          : chromosome_window_coordinate as List<SearchComposite>,
      referenceseqid_variant_coordinate:
          referenceseqid_variant_coordinate == freezed
              ? _value.referenceseqid_variant_coordinate
              : referenceseqid_variant_coordinate as List<SearchComposite>,
      referenceseqid_window_coordinate:
          referenceseqid_window_coordinate == freezed
              ? _value.referenceseqid_window_coordinate
              : referenceseqid_window_coordinate as List<SearchComposite>,
    ));
  }
}

/// @nodoc
class _$_MolecularSequenceSearch extends _MolecularSequenceSearch {
  _$_MolecularSequenceSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.chromosome,
      this.identifier,
      this.patient,
      this.referenceseqid,
      this.type,
      this.variant_end,
      this.variant_start,
      this.window_end,
      this.window_start,
      this.chromosome_variant_coordinate,
      this.chromosome_window_coordinate,
      this.referenceseqid_variant_coordinate,
      this.referenceseqid_window_coordinate})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> chromosome;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchToken> referenceseqid;
  @override
  final List<SearchToken> type;
  @override
  final List<SearchNumber> variant_end;
  @override
  final List<SearchNumber> variant_start;
  @override
  final List<SearchNumber> window_end;
  @override
  final List<SearchNumber> window_start;
  @override
  final List<SearchComposite> chromosome_variant_coordinate;
  @override
  final List<SearchComposite> chromosome_window_coordinate;
  @override
  final List<SearchComposite> referenceseqid_variant_coordinate;
  @override
  final List<SearchComposite> referenceseqid_window_coordinate;

  @override
  String toString() {
    return 'MolecularSequenceSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, chromosome: $chromosome, identifier: $identifier, patient: $patient, referenceseqid: $referenceseqid, type: $type, variant_end: $variant_end, variant_start: $variant_start, window_end: $window_end, window_start: $window_start, chromosome_variant_coordinate: $chromosome_variant_coordinate, chromosome_window_coordinate: $chromosome_window_coordinate, referenceseqid_variant_coordinate: $referenceseqid_variant_coordinate, referenceseqid_window_coordinate: $referenceseqid_window_coordinate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MolecularSequenceSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.chromosome, chromosome) ||
                const DeepCollectionEquality()
                    .equals(other.chromosome, chromosome)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.referenceseqid, referenceseqid) ||
                const DeepCollectionEquality()
                    .equals(other.referenceseqid, referenceseqid)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.variant_end, variant_end) ||
                const DeepCollectionEquality()
                    .equals(other.variant_end, variant_end)) &&
            (identical(other.variant_start, variant_start) ||
                const DeepCollectionEquality()
                    .equals(other.variant_start, variant_start)) &&
            (identical(other.window_end, window_end) ||
                const DeepCollectionEquality()
                    .equals(other.window_end, window_end)) &&
            (identical(other.window_start, window_start) ||
                const DeepCollectionEquality()
                    .equals(other.window_start, window_start)) &&
            (identical(other.chromosome_variant_coordinate, chromosome_variant_coordinate) ||
                const DeepCollectionEquality().equals(
                    other.chromosome_variant_coordinate,
                    chromosome_variant_coordinate)) &&
            (identical(other.chromosome_window_coordinate, chromosome_window_coordinate) ||
                const DeepCollectionEquality().equals(
                    other.chromosome_window_coordinate,
                    chromosome_window_coordinate)) &&
            (identical(other.referenceseqid_variant_coordinate, referenceseqid_variant_coordinate) ||
                const DeepCollectionEquality().equals(
                    other.referenceseqid_variant_coordinate,
                    referenceseqid_variant_coordinate)) &&
            (identical(other.referenceseqid_window_coordinate, referenceseqid_window_coordinate) || const DeepCollectionEquality().equals(other.referenceseqid_window_coordinate, referenceseqid_window_coordinate)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(chromosome) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(referenceseqid) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(variant_end) ^
      const DeepCollectionEquality().hash(variant_start) ^
      const DeepCollectionEquality().hash(window_end) ^
      const DeepCollectionEquality().hash(window_start) ^
      const DeepCollectionEquality().hash(chromosome_variant_coordinate) ^
      const DeepCollectionEquality().hash(chromosome_window_coordinate) ^
      const DeepCollectionEquality().hash(referenceseqid_variant_coordinate) ^
      const DeepCollectionEquality().hash(referenceseqid_window_coordinate);

  @override
  _$MolecularSequenceSearchCopyWith<_MolecularSequenceSearch> get copyWith =>
      __$MolecularSequenceSearchCopyWithImpl<_MolecularSequenceSearch>(
          this, _$identity);
}

abstract class _MolecularSequenceSearch extends MolecularSequenceSearch {
  _MolecularSequenceSearch._() : super._();
  factory _MolecularSequenceSearch(
          {List<Id> searchId,
          List<SearchDate> searchLastUpdated,
          List<SearchToken> searchTag,
          List<SearchUri> searchProfile,
          List<SearchToken> searchSecurity,
          List<SearchString> searchText,
          List<SearchString> searchContent,
          List<Id> searchList,
          List<SearchToken> chromosome,
          List<SearchToken> identifier,
          List<SearchReference> patient,
          List<SearchToken> referenceseqid,
          List<SearchToken> type,
          List<SearchNumber> variant_end,
          List<SearchNumber> variant_start,
          List<SearchNumber> window_end,
          List<SearchNumber> window_start,
          List<SearchComposite> chromosome_variant_coordinate,
          List<SearchComposite> chromosome_window_coordinate,
          List<SearchComposite> referenceseqid_variant_coordinate,
          List<SearchComposite> referenceseqid_window_coordinate}) =
      _$_MolecularSequenceSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get chromosome;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchToken> get referenceseqid;
  @override
  List<SearchToken> get type;
  @override
  List<SearchNumber> get variant_end;
  @override
  List<SearchNumber> get variant_start;
  @override
  List<SearchNumber> get window_end;
  @override
  List<SearchNumber> get window_start;
  @override
  List<SearchComposite> get chromosome_variant_coordinate;
  @override
  List<SearchComposite> get chromosome_window_coordinate;
  @override
  List<SearchComposite> get referenceseqid_variant_coordinate;
  @override
  List<SearchComposite> get referenceseqid_window_coordinate;
  @override
  _$MolecularSequenceSearchCopyWith<_MolecularSequenceSearch> get copyWith;
}

/// @nodoc
class _$QuestionnaireResponseSearchTearOff {
  const _$QuestionnaireResponseSearchTearOff();

// ignore: unused_element
  _QuestionnaireResponseSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> author,
      List<SearchDate> authored,
      List<SearchReference> based_on,
      List<SearchReference> encounter,
      List<SearchToken> identifier,
      List<SearchReference> part_of,
      List<SearchReference> patient,
      List<SearchReference> questionnaire,
      List<SearchReference> source,
      List<SearchToken> status,
      List<SearchReference> subject}) {
    return _QuestionnaireResponseSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      author: author,
      authored: authored,
      based_on: based_on,
      encounter: encounter,
      identifier: identifier,
      part_of: part_of,
      patient: patient,
      questionnaire: questionnaire,
      source: source,
      status: status,
      subject: subject,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $QuestionnaireResponseSearch = _$QuestionnaireResponseSearchTearOff();

/// @nodoc
mixin _$QuestionnaireResponseSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get author;
  List<SearchDate> get authored;
  List<SearchReference> get based_on;
  List<SearchReference> get encounter;
  List<SearchToken> get identifier;
  List<SearchReference> get part_of;
  List<SearchReference> get patient;
  List<SearchReference> get questionnaire;
  List<SearchReference> get source;
  List<SearchToken> get status;
  List<SearchReference> get subject;

  $QuestionnaireResponseSearchCopyWith<QuestionnaireResponseSearch>
      get copyWith;
}

/// @nodoc
abstract class $QuestionnaireResponseSearchCopyWith<$Res> {
  factory $QuestionnaireResponseSearchCopyWith(
          QuestionnaireResponseSearch value,
          $Res Function(QuestionnaireResponseSearch) then) =
      _$QuestionnaireResponseSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> author,
      List<SearchDate> authored,
      List<SearchReference> based_on,
      List<SearchReference> encounter,
      List<SearchToken> identifier,
      List<SearchReference> part_of,
      List<SearchReference> patient,
      List<SearchReference> questionnaire,
      List<SearchReference> source,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class _$QuestionnaireResponseSearchCopyWithImpl<$Res>
    implements $QuestionnaireResponseSearchCopyWith<$Res> {
  _$QuestionnaireResponseSearchCopyWithImpl(this._value, this._then);

  final QuestionnaireResponseSearch _value;
  // ignore: unused_field
  final $Res Function(QuestionnaireResponseSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object author = freezed,
    Object authored = freezed,
    Object based_on = freezed,
    Object encounter = freezed,
    Object identifier = freezed,
    Object part_of = freezed,
    Object patient = freezed,
    Object questionnaire = freezed,
    Object source = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      author:
          author == freezed ? _value.author : author as List<SearchReference>,
      authored:
          authored == freezed ? _value.authored : authored as List<SearchDate>,
      based_on: based_on == freezed
          ? _value.based_on
          : based_on as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      part_of: part_of == freezed
          ? _value.part_of
          : part_of as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      questionnaire: questionnaire == freezed
          ? _value.questionnaire
          : questionnaire as List<SearchReference>,
      source:
          source == freezed ? _value.source : source as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$QuestionnaireResponseSearchCopyWith<$Res>
    implements $QuestionnaireResponseSearchCopyWith<$Res> {
  factory _$QuestionnaireResponseSearchCopyWith(
          _QuestionnaireResponseSearch value,
          $Res Function(_QuestionnaireResponseSearch) then) =
      __$QuestionnaireResponseSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> author,
      List<SearchDate> authored,
      List<SearchReference> based_on,
      List<SearchReference> encounter,
      List<SearchToken> identifier,
      List<SearchReference> part_of,
      List<SearchReference> patient,
      List<SearchReference> questionnaire,
      List<SearchReference> source,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class __$QuestionnaireResponseSearchCopyWithImpl<$Res>
    extends _$QuestionnaireResponseSearchCopyWithImpl<$Res>
    implements _$QuestionnaireResponseSearchCopyWith<$Res> {
  __$QuestionnaireResponseSearchCopyWithImpl(
      _QuestionnaireResponseSearch _value,
      $Res Function(_QuestionnaireResponseSearch) _then)
      : super(_value, (v) => _then(v as _QuestionnaireResponseSearch));

  @override
  _QuestionnaireResponseSearch get _value =>
      super._value as _QuestionnaireResponseSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object author = freezed,
    Object authored = freezed,
    Object based_on = freezed,
    Object encounter = freezed,
    Object identifier = freezed,
    Object part_of = freezed,
    Object patient = freezed,
    Object questionnaire = freezed,
    Object source = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_QuestionnaireResponseSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      author:
          author == freezed ? _value.author : author as List<SearchReference>,
      authored:
          authored == freezed ? _value.authored : authored as List<SearchDate>,
      based_on: based_on == freezed
          ? _value.based_on
          : based_on as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      part_of: part_of == freezed
          ? _value.part_of
          : part_of as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      questionnaire: questionnaire == freezed
          ? _value.questionnaire
          : questionnaire as List<SearchReference>,
      source:
          source == freezed ? _value.source : source as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

/// @nodoc
class _$_QuestionnaireResponseSearch extends _QuestionnaireResponseSearch {
  _$_QuestionnaireResponseSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.author,
      this.authored,
      this.based_on,
      this.encounter,
      this.identifier,
      this.part_of,
      this.patient,
      this.questionnaire,
      this.source,
      this.status,
      this.subject})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchReference> author;
  @override
  final List<SearchDate> authored;
  @override
  final List<SearchReference> based_on;
  @override
  final List<SearchReference> encounter;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> part_of;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> questionnaire;
  @override
  final List<SearchReference> source;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;

  @override
  String toString() {
    return 'QuestionnaireResponseSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, author: $author, authored: $authored, based_on: $based_on, encounter: $encounter, identifier: $identifier, part_of: $part_of, patient: $patient, questionnaire: $questionnaire, source: $source, status: $status, subject: $subject)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _QuestionnaireResponseSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.authored, authored) ||
                const DeepCollectionEquality()
                    .equals(other.authored, authored)) &&
            (identical(other.based_on, based_on) ||
                const DeepCollectionEquality()
                    .equals(other.based_on, based_on)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.part_of, part_of) ||
                const DeepCollectionEquality()
                    .equals(other.part_of, part_of)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.questionnaire, questionnaire) ||
                const DeepCollectionEquality()
                    .equals(other.questionnaire, questionnaire)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality().equals(other.subject, subject)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(authored) ^
      const DeepCollectionEquality().hash(based_on) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(part_of) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(questionnaire) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject);

  @override
  _$QuestionnaireResponseSearchCopyWith<_QuestionnaireResponseSearch>
      get copyWith => __$QuestionnaireResponseSearchCopyWithImpl<
          _QuestionnaireResponseSearch>(this, _$identity);
}

abstract class _QuestionnaireResponseSearch
    extends QuestionnaireResponseSearch {
  _QuestionnaireResponseSearch._() : super._();
  factory _QuestionnaireResponseSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> author,
      List<SearchDate> authored,
      List<SearchReference> based_on,
      List<SearchReference> encounter,
      List<SearchToken> identifier,
      List<SearchReference> part_of,
      List<SearchReference> patient,
      List<SearchReference> questionnaire,
      List<SearchReference> source,
      List<SearchToken> status,
      List<SearchReference> subject}) = _$_QuestionnaireResponseSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get author;
  @override
  List<SearchDate> get authored;
  @override
  List<SearchReference> get based_on;
  @override
  List<SearchReference> get encounter;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get part_of;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get questionnaire;
  @override
  List<SearchReference> get source;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  _$QuestionnaireResponseSearchCopyWith<_QuestionnaireResponseSearch>
      get copyWith;
}

/// @nodoc
class _$SpecimenSearchTearOff {
  const _$SpecimenSearchTearOff();

// ignore: unused_element
  _SpecimenSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> accession,
      List<SearchToken> bodysite,
      List<SearchDate> collected,
      List<SearchReference> collector,
      List<SearchToken> container,
      List<SearchToken> container_id,
      List<SearchToken> identifier,
      List<SearchReference> parent,
      List<SearchReference> patient,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> type}) {
    return _SpecimenSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      accession: accession,
      bodysite: bodysite,
      collected: collected,
      collector: collector,
      container: container,
      container_id: container_id,
      identifier: identifier,
      parent: parent,
      patient: patient,
      status: status,
      subject: subject,
      type: type,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $SpecimenSearch = _$SpecimenSearchTearOff();

/// @nodoc
mixin _$SpecimenSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get accession;
  List<SearchToken> get bodysite;
  List<SearchDate> get collected;
  List<SearchReference> get collector;
  List<SearchToken> get container;
  List<SearchToken> get container_id;
  List<SearchToken> get identifier;
  List<SearchReference> get parent;
  List<SearchReference> get patient;
  List<SearchToken> get status;
  List<SearchReference> get subject;
  List<SearchToken> get type;

  $SpecimenSearchCopyWith<SpecimenSearch> get copyWith;
}

/// @nodoc
abstract class $SpecimenSearchCopyWith<$Res> {
  factory $SpecimenSearchCopyWith(
          SpecimenSearch value, $Res Function(SpecimenSearch) then) =
      _$SpecimenSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> accession,
      List<SearchToken> bodysite,
      List<SearchDate> collected,
      List<SearchReference> collector,
      List<SearchToken> container,
      List<SearchToken> container_id,
      List<SearchToken> identifier,
      List<SearchReference> parent,
      List<SearchReference> patient,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> type});
}

/// @nodoc
class _$SpecimenSearchCopyWithImpl<$Res>
    implements $SpecimenSearchCopyWith<$Res> {
  _$SpecimenSearchCopyWithImpl(this._value, this._then);

  final SpecimenSearch _value;
  // ignore: unused_field
  final $Res Function(SpecimenSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object accession = freezed,
    Object bodysite = freezed,
    Object collected = freezed,
    Object collector = freezed,
    Object container = freezed,
    Object container_id = freezed,
    Object identifier = freezed,
    Object parent = freezed,
    Object patient = freezed,
    Object status = freezed,
    Object subject = freezed,
    Object type = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      accession: accession == freezed
          ? _value.accession
          : accession as List<SearchToken>,
      bodysite:
          bodysite == freezed ? _value.bodysite : bodysite as List<SearchToken>,
      collected: collected == freezed
          ? _value.collected
          : collected as List<SearchDate>,
      collector: collector == freezed
          ? _value.collector
          : collector as List<SearchReference>,
      container: container == freezed
          ? _value.container
          : container as List<SearchToken>,
      container_id: container_id == freezed
          ? _value.container_id
          : container_id as List<SearchToken>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      parent:
          parent == freezed ? _value.parent : parent as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$SpecimenSearchCopyWith<$Res>
    implements $SpecimenSearchCopyWith<$Res> {
  factory _$SpecimenSearchCopyWith(
          _SpecimenSearch value, $Res Function(_SpecimenSearch) then) =
      __$SpecimenSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> accession,
      List<SearchToken> bodysite,
      List<SearchDate> collected,
      List<SearchReference> collector,
      List<SearchToken> container,
      List<SearchToken> container_id,
      List<SearchToken> identifier,
      List<SearchReference> parent,
      List<SearchReference> patient,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> type});
}

/// @nodoc
class __$SpecimenSearchCopyWithImpl<$Res>
    extends _$SpecimenSearchCopyWithImpl<$Res>
    implements _$SpecimenSearchCopyWith<$Res> {
  __$SpecimenSearchCopyWithImpl(
      _SpecimenSearch _value, $Res Function(_SpecimenSearch) _then)
      : super(_value, (v) => _then(v as _SpecimenSearch));

  @override
  _SpecimenSearch get _value => super._value as _SpecimenSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object accession = freezed,
    Object bodysite = freezed,
    Object collected = freezed,
    Object collector = freezed,
    Object container = freezed,
    Object container_id = freezed,
    Object identifier = freezed,
    Object parent = freezed,
    Object patient = freezed,
    Object status = freezed,
    Object subject = freezed,
    Object type = freezed,
  }) {
    return _then(_SpecimenSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      accession: accession == freezed
          ? _value.accession
          : accession as List<SearchToken>,
      bodysite:
          bodysite == freezed ? _value.bodysite : bodysite as List<SearchToken>,
      collected: collected == freezed
          ? _value.collected
          : collected as List<SearchDate>,
      collector: collector == freezed
          ? _value.collector
          : collector as List<SearchReference>,
      container: container == freezed
          ? _value.container
          : container as List<SearchToken>,
      container_id: container_id == freezed
          ? _value.container_id
          : container_id as List<SearchToken>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      parent:
          parent == freezed ? _value.parent : parent as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
    ));
  }
}

/// @nodoc
class _$_SpecimenSearch extends _SpecimenSearch {
  _$_SpecimenSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.accession,
      this.bodysite,
      this.collected,
      this.collector,
      this.container,
      this.container_id,
      this.identifier,
      this.parent,
      this.patient,
      this.status,
      this.subject,
      this.type})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> accession;
  @override
  final List<SearchToken> bodysite;
  @override
  final List<SearchDate> collected;
  @override
  final List<SearchReference> collector;
  @override
  final List<SearchToken> container;
  @override
  final List<SearchToken> container_id;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> parent;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;
  @override
  final List<SearchToken> type;

  @override
  String toString() {
    return 'SpecimenSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, accession: $accession, bodysite: $bodysite, collected: $collected, collector: $collector, container: $container, container_id: $container_id, identifier: $identifier, parent: $parent, patient: $patient, status: $status, subject: $subject, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SpecimenSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.accession, accession) ||
                const DeepCollectionEquality()
                    .equals(other.accession, accession)) &&
            (identical(other.bodysite, bodysite) ||
                const DeepCollectionEquality()
                    .equals(other.bodysite, bodysite)) &&
            (identical(other.collected, collected) ||
                const DeepCollectionEquality()
                    .equals(other.collected, collected)) &&
            (identical(other.collector, collector) ||
                const DeepCollectionEquality()
                    .equals(other.collector, collector)) &&
            (identical(other.container, container) ||
                const DeepCollectionEquality()
                    .equals(other.container, container)) &&
            (identical(other.container_id, container_id) ||
                const DeepCollectionEquality()
                    .equals(other.container_id, container_id)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.parent, parent) ||
                const DeepCollectionEquality().equals(other.parent, parent)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(accession) ^
      const DeepCollectionEquality().hash(bodysite) ^
      const DeepCollectionEquality().hash(collected) ^
      const DeepCollectionEquality().hash(collector) ^
      const DeepCollectionEquality().hash(container) ^
      const DeepCollectionEquality().hash(container_id) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(parent) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(type);

  @override
  _$SpecimenSearchCopyWith<_SpecimenSearch> get copyWith =>
      __$SpecimenSearchCopyWithImpl<_SpecimenSearch>(this, _$identity);
}

abstract class _SpecimenSearch extends SpecimenSearch {
  _SpecimenSearch._() : super._();
  factory _SpecimenSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> accession,
      List<SearchToken> bodysite,
      List<SearchDate> collected,
      List<SearchReference> collector,
      List<SearchToken> container,
      List<SearchToken> container_id,
      List<SearchToken> identifier,
      List<SearchReference> parent,
      List<SearchReference> patient,
      List<SearchToken> status,
      List<SearchReference> subject,
      List<SearchToken> type}) = _$_SpecimenSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get accession;
  @override
  List<SearchToken> get bodysite;
  @override
  List<SearchDate> get collected;
  @override
  List<SearchReference> get collector;
  @override
  List<SearchToken> get container;
  @override
  List<SearchToken> get container_id;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get parent;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  List<SearchToken> get type;
  @override
  _$SpecimenSearchCopyWith<_SpecimenSearch> get copyWith;
}

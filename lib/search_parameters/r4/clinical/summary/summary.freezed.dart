// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'summary.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;
AdverseEventSearch _$AdverseEventSearchFromJson(Map<String, dynamic> json) {
  return _AdverseEventSearch.fromJson(json);
}

/// @nodoc
class _$AdverseEventSearchTearOff {
  const _$AdverseEventSearchTearOff();

// ignore: unused_element
  _AdverseEventSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> actuality,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchToken> event,
      List<SearchReference> location,
      List<SearchReference> recorder,
      List<SearchReference> resultingcondition,
      List<SearchToken> seriousness,
      List<SearchToken> severity,
      List<SearchReference> study,
      List<SearchReference> subject,
      List<SearchReference> substance}) {
    return _AdverseEventSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      actuality: actuality,
      category: category,
      date: date,
      event: event,
      location: location,
      recorder: recorder,
      resultingcondition: resultingcondition,
      seriousness: seriousness,
      severity: severity,
      study: study,
      subject: subject,
      substance: substance,
    );
  }

// ignore: unused_element
  AdverseEventSearch fromJson(Map<String, Object> json) {
    return AdverseEventSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $AdverseEventSearch = _$AdverseEventSearchTearOff();

/// @nodoc
mixin _$AdverseEventSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get actuality;
  List<SearchToken> get category;
  List<SearchDate> get date;
  List<SearchToken> get event;
  List<SearchReference> get location;
  List<SearchReference> get recorder;
  List<SearchReference> get resultingcondition;
  List<SearchToken> get seriousness;
  List<SearchToken> get severity;
  List<SearchReference> get study;
  List<SearchReference> get subject;
  List<SearchReference> get substance;

  Map<String, dynamic> toJson();
  $AdverseEventSearchCopyWith<AdverseEventSearch> get copyWith;
}

/// @nodoc
abstract class $AdverseEventSearchCopyWith<$Res> {
  factory $AdverseEventSearchCopyWith(
          AdverseEventSearch value, $Res Function(AdverseEventSearch) then) =
      _$AdverseEventSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> actuality,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchToken> event,
      List<SearchReference> location,
      List<SearchReference> recorder,
      List<SearchReference> resultingcondition,
      List<SearchToken> seriousness,
      List<SearchToken> severity,
      List<SearchReference> study,
      List<SearchReference> subject,
      List<SearchReference> substance});
}

/// @nodoc
class _$AdverseEventSearchCopyWithImpl<$Res>
    implements $AdverseEventSearchCopyWith<$Res> {
  _$AdverseEventSearchCopyWithImpl(this._value, this._then);

  final AdverseEventSearch _value;
  // ignore: unused_field
  final $Res Function(AdverseEventSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object actuality = freezed,
    Object category = freezed,
    Object date = freezed,
    Object event = freezed,
    Object location = freezed,
    Object recorder = freezed,
    Object resultingcondition = freezed,
    Object seriousness = freezed,
    Object severity = freezed,
    Object study = freezed,
    Object subject = freezed,
    Object substance = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      actuality: actuality == freezed
          ? _value.actuality
          : actuality as List<SearchToken>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      event: event == freezed ? _value.event : event as List<SearchToken>,
      location: location == freezed
          ? _value.location
          : location as List<SearchReference>,
      recorder: recorder == freezed
          ? _value.recorder
          : recorder as List<SearchReference>,
      resultingcondition: resultingcondition == freezed
          ? _value.resultingcondition
          : resultingcondition as List<SearchReference>,
      seriousness: seriousness == freezed
          ? _value.seriousness
          : seriousness as List<SearchToken>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      study: study == freezed ? _value.study : study as List<SearchReference>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      substance: substance == freezed
          ? _value.substance
          : substance as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$AdverseEventSearchCopyWith<$Res>
    implements $AdverseEventSearchCopyWith<$Res> {
  factory _$AdverseEventSearchCopyWith(
          _AdverseEventSearch value, $Res Function(_AdverseEventSearch) then) =
      __$AdverseEventSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> actuality,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchToken> event,
      List<SearchReference> location,
      List<SearchReference> recorder,
      List<SearchReference> resultingcondition,
      List<SearchToken> seriousness,
      List<SearchToken> severity,
      List<SearchReference> study,
      List<SearchReference> subject,
      List<SearchReference> substance});
}

/// @nodoc
class __$AdverseEventSearchCopyWithImpl<$Res>
    extends _$AdverseEventSearchCopyWithImpl<$Res>
    implements _$AdverseEventSearchCopyWith<$Res> {
  __$AdverseEventSearchCopyWithImpl(
      _AdverseEventSearch _value, $Res Function(_AdverseEventSearch) _then)
      : super(_value, (v) => _then(v as _AdverseEventSearch));

  @override
  _AdverseEventSearch get _value => super._value as _AdverseEventSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object actuality = freezed,
    Object category = freezed,
    Object date = freezed,
    Object event = freezed,
    Object location = freezed,
    Object recorder = freezed,
    Object resultingcondition = freezed,
    Object seriousness = freezed,
    Object severity = freezed,
    Object study = freezed,
    Object subject = freezed,
    Object substance = freezed,
  }) {
    return _then(_AdverseEventSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      actuality: actuality == freezed
          ? _value.actuality
          : actuality as List<SearchToken>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      event: event == freezed ? _value.event : event as List<SearchToken>,
      location: location == freezed
          ? _value.location
          : location as List<SearchReference>,
      recorder: recorder == freezed
          ? _value.recorder
          : recorder as List<SearchReference>,
      resultingcondition: resultingcondition == freezed
          ? _value.resultingcondition
          : resultingcondition as List<SearchReference>,
      seriousness: seriousness == freezed
          ? _value.seriousness
          : seriousness as List<SearchToken>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      study: study == freezed ? _value.study : study as List<SearchReference>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      substance: substance == freezed
          ? _value.substance
          : substance as List<SearchReference>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_AdverseEventSearch extends _AdverseEventSearch {
  _$_AdverseEventSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.actuality,
      this.category,
      this.date,
      this.event,
      this.location,
      this.recorder,
      this.resultingcondition,
      this.seriousness,
      this.severity,
      this.study,
      this.subject,
      this.substance})
      : super._();

  factory _$_AdverseEventSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_AdverseEventSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> actuality;
  @override
  final List<SearchToken> category;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> event;
  @override
  final List<SearchReference> location;
  @override
  final List<SearchReference> recorder;
  @override
  final List<SearchReference> resultingcondition;
  @override
  final List<SearchToken> seriousness;
  @override
  final List<SearchToken> severity;
  @override
  final List<SearchReference> study;
  @override
  final List<SearchReference> subject;
  @override
  final List<SearchReference> substance;

  @override
  String toString() {
    return 'AdverseEventSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, actuality: $actuality, category: $category, date: $date, event: $event, location: $location, recorder: $recorder, resultingcondition: $resultingcondition, seriousness: $seriousness, severity: $severity, study: $study, subject: $subject, substance: $substance)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AdverseEventSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.actuality, actuality) ||
                const DeepCollectionEquality()
                    .equals(other.actuality, actuality)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.event, event) ||
                const DeepCollectionEquality().equals(other.event, event)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.recorder, recorder) ||
                const DeepCollectionEquality()
                    .equals(other.recorder, recorder)) &&
            (identical(other.resultingcondition, resultingcondition) ||
                const DeepCollectionEquality()
                    .equals(other.resultingcondition, resultingcondition)) &&
            (identical(other.seriousness, seriousness) ||
                const DeepCollectionEquality()
                    .equals(other.seriousness, seriousness)) &&
            (identical(other.severity, severity) ||
                const DeepCollectionEquality()
                    .equals(other.severity, severity)) &&
            (identical(other.study, study) ||
                const DeepCollectionEquality().equals(other.study, study)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.substance, substance) ||
                const DeepCollectionEquality()
                    .equals(other.substance, substance)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(actuality) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(event) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(recorder) ^
      const DeepCollectionEquality().hash(resultingcondition) ^
      const DeepCollectionEquality().hash(seriousness) ^
      const DeepCollectionEquality().hash(severity) ^
      const DeepCollectionEquality().hash(study) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(substance);

  @override
  _$AdverseEventSearchCopyWith<_AdverseEventSearch> get copyWith =>
      __$AdverseEventSearchCopyWithImpl<_AdverseEventSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_AdverseEventSearchToJson(this);
  }
}

abstract class _AdverseEventSearch extends AdverseEventSearch {
  _AdverseEventSearch._() : super._();
  factory _AdverseEventSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> actuality,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchToken> event,
      List<SearchReference> location,
      List<SearchReference> recorder,
      List<SearchReference> resultingcondition,
      List<SearchToken> seriousness,
      List<SearchToken> severity,
      List<SearchReference> study,
      List<SearchReference> subject,
      List<SearchReference> substance}) = _$_AdverseEventSearch;

  factory _AdverseEventSearch.fromJson(Map<String, dynamic> json) =
      _$_AdverseEventSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get actuality;
  @override
  List<SearchToken> get category;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get event;
  @override
  List<SearchReference> get location;
  @override
  List<SearchReference> get recorder;
  @override
  List<SearchReference> get resultingcondition;
  @override
  List<SearchToken> get seriousness;
  @override
  List<SearchToken> get severity;
  @override
  List<SearchReference> get study;
  @override
  List<SearchReference> get subject;
  @override
  List<SearchReference> get substance;
  @override
  _$AdverseEventSearchCopyWith<_AdverseEventSearch> get copyWith;
}

AllergyIntoleranceSearch _$AllergyIntoleranceSearchFromJson(
    Map<String, dynamic> json) {
  return _AllergyIntoleranceSearch.fromJson(json);
}

/// @nodoc
class _$AllergyIntoleranceSearchTearOff {
  const _$AllergyIntoleranceSearchTearOff();

// ignore: unused_element
  _AllergyIntoleranceSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> asserter,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      @JsonKey(name: 'last-date')
          List<SearchDate> lastDate,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<SearchReference> patient,
      List<SearchReference> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus}) {
    return _AllergyIntoleranceSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      asserter: asserter,
      category: category,
      clinicalStatus: clinicalStatus,
      code: code,
      criticality: criticality,
      date: date,
      identifier: identifier,
      lastDate: lastDate,
      manifestation: manifestation,
      onset: onset,
      patient: patient,
      recorder: recorder,
      route: route,
      severity: severity,
      type: type,
      verificationStatus: verificationStatus,
    );
  }

// ignore: unused_element
  AllergyIntoleranceSearch fromJson(Map<String, Object> json) {
    return AllergyIntoleranceSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $AllergyIntoleranceSearch = _$AllergyIntoleranceSearchTearOff();

/// @nodoc
mixin _$AllergyIntoleranceSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get asserter;
  List<SearchToken> get category;
  @JsonKey(name: 'clinical-status')
  List<SearchToken> get clinicalStatus;
  List<SearchToken> get code;
  List<SearchToken> get criticality;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  @JsonKey(name: 'last-date')
  List<SearchDate> get lastDate;
  List<SearchToken> get manifestation;
  List<SearchDate> get onset;
  List<SearchReference> get patient;
  List<SearchReference> get recorder;
  List<SearchToken> get route;
  List<SearchToken> get severity;
  List<SearchToken> get type;
  @JsonKey(name: 'verification-status')
  List<SearchToken> get verificationStatus;

  Map<String, dynamic> toJson();
  $AllergyIntoleranceSearchCopyWith<AllergyIntoleranceSearch> get copyWith;
}

/// @nodoc
abstract class $AllergyIntoleranceSearchCopyWith<$Res> {
  factory $AllergyIntoleranceSearchCopyWith(AllergyIntoleranceSearch value,
          $Res Function(AllergyIntoleranceSearch) then) =
      _$AllergyIntoleranceSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> asserter,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      @JsonKey(name: 'last-date')
          List<SearchDate> lastDate,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<SearchReference> patient,
      List<SearchReference> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus});
}

/// @nodoc
class _$AllergyIntoleranceSearchCopyWithImpl<$Res>
    implements $AllergyIntoleranceSearchCopyWith<$Res> {
  _$AllergyIntoleranceSearchCopyWithImpl(this._value, this._then);

  final AllergyIntoleranceSearch _value;
  // ignore: unused_field
  final $Res Function(AllergyIntoleranceSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object asserter = freezed,
    Object category = freezed,
    Object clinicalStatus = freezed,
    Object code = freezed,
    Object criticality = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object lastDate = freezed,
    Object manifestation = freezed,
    Object onset = freezed,
    Object patient = freezed,
    Object recorder = freezed,
    Object route = freezed,
    Object severity = freezed,
    Object type = freezed,
    Object verificationStatus = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      asserter: asserter == freezed
          ? _value.asserter
          : asserter as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinicalStatus: clinicalStatus == freezed
          ? _value.clinicalStatus
          : clinicalStatus as List<SearchToken>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      criticality: criticality == freezed
          ? _value.criticality
          : criticality as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      lastDate:
          lastDate == freezed ? _value.lastDate : lastDate as List<SearchDate>,
      manifestation: manifestation == freezed
          ? _value.manifestation
          : manifestation as List<SearchToken>,
      onset: onset == freezed ? _value.onset : onset as List<SearchDate>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      recorder: recorder == freezed
          ? _value.recorder
          : recorder as List<SearchReference>,
      route: route == freezed ? _value.route : route as List<SearchToken>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      verificationStatus: verificationStatus == freezed
          ? _value.verificationStatus
          : verificationStatus as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$AllergyIntoleranceSearchCopyWith<$Res>
    implements $AllergyIntoleranceSearchCopyWith<$Res> {
  factory _$AllergyIntoleranceSearchCopyWith(_AllergyIntoleranceSearch value,
          $Res Function(_AllergyIntoleranceSearch) then) =
      __$AllergyIntoleranceSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> asserter,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      @JsonKey(name: 'last-date')
          List<SearchDate> lastDate,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<SearchReference> patient,
      List<SearchReference> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus});
}

/// @nodoc
class __$AllergyIntoleranceSearchCopyWithImpl<$Res>
    extends _$AllergyIntoleranceSearchCopyWithImpl<$Res>
    implements _$AllergyIntoleranceSearchCopyWith<$Res> {
  __$AllergyIntoleranceSearchCopyWithImpl(_AllergyIntoleranceSearch _value,
      $Res Function(_AllergyIntoleranceSearch) _then)
      : super(_value, (v) => _then(v as _AllergyIntoleranceSearch));

  @override
  _AllergyIntoleranceSearch get _value =>
      super._value as _AllergyIntoleranceSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object asserter = freezed,
    Object category = freezed,
    Object clinicalStatus = freezed,
    Object code = freezed,
    Object criticality = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object lastDate = freezed,
    Object manifestation = freezed,
    Object onset = freezed,
    Object patient = freezed,
    Object recorder = freezed,
    Object route = freezed,
    Object severity = freezed,
    Object type = freezed,
    Object verificationStatus = freezed,
  }) {
    return _then(_AllergyIntoleranceSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      asserter: asserter == freezed
          ? _value.asserter
          : asserter as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinicalStatus: clinicalStatus == freezed
          ? _value.clinicalStatus
          : clinicalStatus as List<SearchToken>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      criticality: criticality == freezed
          ? _value.criticality
          : criticality as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      lastDate:
          lastDate == freezed ? _value.lastDate : lastDate as List<SearchDate>,
      manifestation: manifestation == freezed
          ? _value.manifestation
          : manifestation as List<SearchToken>,
      onset: onset == freezed ? _value.onset : onset as List<SearchDate>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      recorder: recorder == freezed
          ? _value.recorder
          : recorder as List<SearchReference>,
      route: route == freezed ? _value.route : route as List<SearchToken>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      verificationStatus: verificationStatus == freezed
          ? _value.verificationStatus
          : verificationStatus as List<SearchToken>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_AllergyIntoleranceSearch extends _AllergyIntoleranceSearch {
  _$_AllergyIntoleranceSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.asserter,
      this.category,
      @JsonKey(name: 'clinical-status') this.clinicalStatus,
      this.code,
      this.criticality,
      this.date,
      this.identifier,
      @JsonKey(name: 'last-date') this.lastDate,
      this.manifestation,
      this.onset,
      this.patient,
      this.recorder,
      this.route,
      this.severity,
      this.type,
      @JsonKey(name: 'verification-status') this.verificationStatus})
      : super._();

  factory _$_AllergyIntoleranceSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_AllergyIntoleranceSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchReference> asserter;
  @override
  final List<SearchToken> category;
  @override
  @JsonKey(name: 'clinical-status')
  final List<SearchToken> clinicalStatus;
  @override
  final List<SearchToken> code;
  @override
  final List<SearchToken> criticality;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  @JsonKey(name: 'last-date')
  final List<SearchDate> lastDate;
  @override
  final List<SearchToken> manifestation;
  @override
  final List<SearchDate> onset;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> recorder;
  @override
  final List<SearchToken> route;
  @override
  final List<SearchToken> severity;
  @override
  final List<SearchToken> type;
  @override
  @JsonKey(name: 'verification-status')
  final List<SearchToken> verificationStatus;

  @override
  String toString() {
    return 'AllergyIntoleranceSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, asserter: $asserter, category: $category, clinicalStatus: $clinicalStatus, code: $code, criticality: $criticality, date: $date, identifier: $identifier, lastDate: $lastDate, manifestation: $manifestation, onset: $onset, patient: $patient, recorder: $recorder, route: $route, severity: $severity, type: $type, verificationStatus: $verificationStatus)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AllergyIntoleranceSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.asserter, asserter) ||
                const DeepCollectionEquality()
                    .equals(other.asserter, asserter)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.clinicalStatus, clinicalStatus) ||
                const DeepCollectionEquality()
                    .equals(other.clinicalStatus, clinicalStatus)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.criticality, criticality) ||
                const DeepCollectionEquality()
                    .equals(other.criticality, criticality)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.lastDate, lastDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastDate, lastDate)) &&
            (identical(other.manifestation, manifestation) ||
                const DeepCollectionEquality()
                    .equals(other.manifestation, manifestation)) &&
            (identical(other.onset, onset) ||
                const DeepCollectionEquality().equals(other.onset, onset)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.recorder, recorder) ||
                const DeepCollectionEquality()
                    .equals(other.recorder, recorder)) &&
            (identical(other.route, route) ||
                const DeepCollectionEquality().equals(other.route, route)) &&
            (identical(other.severity, severity) ||
                const DeepCollectionEquality()
                    .equals(other.severity, severity)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(asserter) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(clinicalStatus) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(criticality) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(lastDate) ^
      const DeepCollectionEquality().hash(manifestation) ^
      const DeepCollectionEquality().hash(onset) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(recorder) ^
      const DeepCollectionEquality().hash(route) ^
      const DeepCollectionEquality().hash(severity) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(verificationStatus);

  @override
  _$AllergyIntoleranceSearchCopyWith<_AllergyIntoleranceSearch> get copyWith =>
      __$AllergyIntoleranceSearchCopyWithImpl<_AllergyIntoleranceSearch>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_AllergyIntoleranceSearchToJson(this);
  }
}

abstract class _AllergyIntoleranceSearch extends AllergyIntoleranceSearch {
  _AllergyIntoleranceSearch._() : super._();
  factory _AllergyIntoleranceSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> asserter,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      @JsonKey(name: 'last-date')
          List<SearchDate> lastDate,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<SearchReference> patient,
      List<SearchReference> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus}) = _$_AllergyIntoleranceSearch;

  factory _AllergyIntoleranceSearch.fromJson(Map<String, dynamic> json) =
      _$_AllergyIntoleranceSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get asserter;
  @override
  List<SearchToken> get category;
  @override
  @JsonKey(name: 'clinical-status')
  List<SearchToken> get clinicalStatus;
  @override
  List<SearchToken> get code;
  @override
  List<SearchToken> get criticality;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  @JsonKey(name: 'last-date')
  List<SearchDate> get lastDate;
  @override
  List<SearchToken> get manifestation;
  @override
  List<SearchDate> get onset;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get recorder;
  @override
  List<SearchToken> get route;
  @override
  List<SearchToken> get severity;
  @override
  List<SearchToken> get type;
  @override
  @JsonKey(name: 'verification-status')
  List<SearchToken> get verificationStatus;
  @override
  _$AllergyIntoleranceSearchCopyWith<_AllergyIntoleranceSearch> get copyWith;
}

ConditionSearch _$ConditionSearchFromJson(Map<String, dynamic> json) {
  return _ConditionSearch.fromJson(json);
}

/// @nodoc
class _$ConditionSearchTearOff {
  const _$ConditionSearchTearOff();

// ignore: unused_element
  _ConditionSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'abatement-age')
          List<SearchQuantity> abatementAge,
      @JsonKey(name: 'abatement-date')
          List<SearchDate> abatementDate,
      @JsonKey(name: 'abatement-string')
          List<SearchString> abatementString,
      List<SearchReference> asserter,
      @JsonKey(name: 'body-site')
          List<SearchToken> bodySite,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchReference> encounter,
      List<SearchToken> evidence,
      @JsonKey(name: 'evidence-detail')
          List<SearchReference> evidenceDetail,
      @JsonKey(name: 'onset-age')
          List<SearchQuantity> onsetAge,
      @JsonKey(name: 'onset-date')
          List<SearchDate> onsetDate,
      @JsonKey(name: 'onset-info')
          List<SearchString> onsetInfo,
      @JsonKey(name: 'recorded-date')
          List<SearchDate> recordedDate,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<SearchReference> subject,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus}) {
    return _ConditionSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      code: code,
      identifier: identifier,
      patient: patient,
      abatementAge: abatementAge,
      abatementDate: abatementDate,
      abatementString: abatementString,
      asserter: asserter,
      bodySite: bodySite,
      category: category,
      clinicalStatus: clinicalStatus,
      encounter: encounter,
      evidence: evidence,
      evidenceDetail: evidenceDetail,
      onsetAge: onsetAge,
      onsetDate: onsetDate,
      onsetInfo: onsetInfo,
      recordedDate: recordedDate,
      severity: severity,
      stage: stage,
      subject: subject,
      verificationStatus: verificationStatus,
    );
  }

// ignore: unused_element
  ConditionSearch fromJson(Map<String, Object> json) {
    return ConditionSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $ConditionSearch = _$ConditionSearchTearOff();

/// @nodoc
mixin _$ConditionSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  @JsonKey(name: 'abatement-age')
  List<SearchQuantity> get abatementAge;
  @JsonKey(name: 'abatement-date')
  List<SearchDate> get abatementDate;
  @JsonKey(name: 'abatement-string')
  List<SearchString> get abatementString;
  List<SearchReference> get asserter;
  @JsonKey(name: 'body-site')
  List<SearchToken> get bodySite;
  List<SearchToken> get category;
  @JsonKey(name: 'clinical-status')
  List<SearchToken> get clinicalStatus;
  List<SearchReference> get encounter;
  List<SearchToken> get evidence;
  @JsonKey(name: 'evidence-detail')
  List<SearchReference> get evidenceDetail;
  @JsonKey(name: 'onset-age')
  List<SearchQuantity> get onsetAge;
  @JsonKey(name: 'onset-date')
  List<SearchDate> get onsetDate;
  @JsonKey(name: 'onset-info')
  List<SearchString> get onsetInfo;
  @JsonKey(name: 'recorded-date')
  List<SearchDate> get recordedDate;
  List<SearchToken> get severity;
  List<SearchToken> get stage;
  List<SearchReference> get subject;
  @JsonKey(name: 'verification-status')
  List<SearchToken> get verificationStatus;

  Map<String, dynamic> toJson();
  $ConditionSearchCopyWith<ConditionSearch> get copyWith;
}

/// @nodoc
abstract class $ConditionSearchCopyWith<$Res> {
  factory $ConditionSearchCopyWith(
          ConditionSearch value, $Res Function(ConditionSearch) then) =
      _$ConditionSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'abatement-age')
          List<SearchQuantity> abatementAge,
      @JsonKey(name: 'abatement-date')
          List<SearchDate> abatementDate,
      @JsonKey(name: 'abatement-string')
          List<SearchString> abatementString,
      List<SearchReference> asserter,
      @JsonKey(name: 'body-site')
          List<SearchToken> bodySite,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchReference> encounter,
      List<SearchToken> evidence,
      @JsonKey(name: 'evidence-detail')
          List<SearchReference> evidenceDetail,
      @JsonKey(name: 'onset-age')
          List<SearchQuantity> onsetAge,
      @JsonKey(name: 'onset-date')
          List<SearchDate> onsetDate,
      @JsonKey(name: 'onset-info')
          List<SearchString> onsetInfo,
      @JsonKey(name: 'recorded-date')
          List<SearchDate> recordedDate,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<SearchReference> subject,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus});
}

/// @nodoc
class _$ConditionSearchCopyWithImpl<$Res>
    implements $ConditionSearchCopyWith<$Res> {
  _$ConditionSearchCopyWithImpl(this._value, this._then);

  final ConditionSearch _value;
  // ignore: unused_field
  final $Res Function(ConditionSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object abatementAge = freezed,
    Object abatementDate = freezed,
    Object abatementString = freezed,
    Object asserter = freezed,
    Object bodySite = freezed,
    Object category = freezed,
    Object clinicalStatus = freezed,
    Object encounter = freezed,
    Object evidence = freezed,
    Object evidenceDetail = freezed,
    Object onsetAge = freezed,
    Object onsetDate = freezed,
    Object onsetInfo = freezed,
    Object recordedDate = freezed,
    Object severity = freezed,
    Object stage = freezed,
    Object subject = freezed,
    Object verificationStatus = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      abatementAge: abatementAge == freezed
          ? _value.abatementAge
          : abatementAge as List<SearchQuantity>,
      abatementDate: abatementDate == freezed
          ? _value.abatementDate
          : abatementDate as List<SearchDate>,
      abatementString: abatementString == freezed
          ? _value.abatementString
          : abatementString as List<SearchString>,
      asserter: asserter == freezed
          ? _value.asserter
          : asserter as List<SearchReference>,
      bodySite:
          bodySite == freezed ? _value.bodySite : bodySite as List<SearchToken>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinicalStatus: clinicalStatus == freezed
          ? _value.clinicalStatus
          : clinicalStatus as List<SearchToken>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      evidence:
          evidence == freezed ? _value.evidence : evidence as List<SearchToken>,
      evidenceDetail: evidenceDetail == freezed
          ? _value.evidenceDetail
          : evidenceDetail as List<SearchReference>,
      onsetAge: onsetAge == freezed
          ? _value.onsetAge
          : onsetAge as List<SearchQuantity>,
      onsetDate: onsetDate == freezed
          ? _value.onsetDate
          : onsetDate as List<SearchDate>,
      onsetInfo: onsetInfo == freezed
          ? _value.onsetInfo
          : onsetInfo as List<SearchString>,
      recordedDate: recordedDate == freezed
          ? _value.recordedDate
          : recordedDate as List<SearchDate>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      stage: stage == freezed ? _value.stage : stage as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      verificationStatus: verificationStatus == freezed
          ? _value.verificationStatus
          : verificationStatus as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$ConditionSearchCopyWith<$Res>
    implements $ConditionSearchCopyWith<$Res> {
  factory _$ConditionSearchCopyWith(
          _ConditionSearch value, $Res Function(_ConditionSearch) then) =
      __$ConditionSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'abatement-age')
          List<SearchQuantity> abatementAge,
      @JsonKey(name: 'abatement-date')
          List<SearchDate> abatementDate,
      @JsonKey(name: 'abatement-string')
          List<SearchString> abatementString,
      List<SearchReference> asserter,
      @JsonKey(name: 'body-site')
          List<SearchToken> bodySite,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchReference> encounter,
      List<SearchToken> evidence,
      @JsonKey(name: 'evidence-detail')
          List<SearchReference> evidenceDetail,
      @JsonKey(name: 'onset-age')
          List<SearchQuantity> onsetAge,
      @JsonKey(name: 'onset-date')
          List<SearchDate> onsetDate,
      @JsonKey(name: 'onset-info')
          List<SearchString> onsetInfo,
      @JsonKey(name: 'recorded-date')
          List<SearchDate> recordedDate,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<SearchReference> subject,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus});
}

/// @nodoc
class __$ConditionSearchCopyWithImpl<$Res>
    extends _$ConditionSearchCopyWithImpl<$Res>
    implements _$ConditionSearchCopyWith<$Res> {
  __$ConditionSearchCopyWithImpl(
      _ConditionSearch _value, $Res Function(_ConditionSearch) _then)
      : super(_value, (v) => _then(v as _ConditionSearch));

  @override
  _ConditionSearch get _value => super._value as _ConditionSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object abatementAge = freezed,
    Object abatementDate = freezed,
    Object abatementString = freezed,
    Object asserter = freezed,
    Object bodySite = freezed,
    Object category = freezed,
    Object clinicalStatus = freezed,
    Object encounter = freezed,
    Object evidence = freezed,
    Object evidenceDetail = freezed,
    Object onsetAge = freezed,
    Object onsetDate = freezed,
    Object onsetInfo = freezed,
    Object recordedDate = freezed,
    Object severity = freezed,
    Object stage = freezed,
    Object subject = freezed,
    Object verificationStatus = freezed,
  }) {
    return _then(_ConditionSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      abatementAge: abatementAge == freezed
          ? _value.abatementAge
          : abatementAge as List<SearchQuantity>,
      abatementDate: abatementDate == freezed
          ? _value.abatementDate
          : abatementDate as List<SearchDate>,
      abatementString: abatementString == freezed
          ? _value.abatementString
          : abatementString as List<SearchString>,
      asserter: asserter == freezed
          ? _value.asserter
          : asserter as List<SearchReference>,
      bodySite:
          bodySite == freezed ? _value.bodySite : bodySite as List<SearchToken>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinicalStatus: clinicalStatus == freezed
          ? _value.clinicalStatus
          : clinicalStatus as List<SearchToken>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      evidence:
          evidence == freezed ? _value.evidence : evidence as List<SearchToken>,
      evidenceDetail: evidenceDetail == freezed
          ? _value.evidenceDetail
          : evidenceDetail as List<SearchReference>,
      onsetAge: onsetAge == freezed
          ? _value.onsetAge
          : onsetAge as List<SearchQuantity>,
      onsetDate: onsetDate == freezed
          ? _value.onsetDate
          : onsetDate as List<SearchDate>,
      onsetInfo: onsetInfo == freezed
          ? _value.onsetInfo
          : onsetInfo as List<SearchString>,
      recordedDate: recordedDate == freezed
          ? _value.recordedDate
          : recordedDate as List<SearchDate>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      stage: stage == freezed ? _value.stage : stage as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      verificationStatus: verificationStatus == freezed
          ? _value.verificationStatus
          : verificationStatus as List<SearchToken>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_ConditionSearch extends _ConditionSearch {
  _$_ConditionSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.code,
      this.identifier,
      this.patient,
      @JsonKey(name: 'abatement-age') this.abatementAge,
      @JsonKey(name: 'abatement-date') this.abatementDate,
      @JsonKey(name: 'abatement-string') this.abatementString,
      this.asserter,
      @JsonKey(name: 'body-site') this.bodySite,
      this.category,
      @JsonKey(name: 'clinical-status') this.clinicalStatus,
      this.encounter,
      this.evidence,
      @JsonKey(name: 'evidence-detail') this.evidenceDetail,
      @JsonKey(name: 'onset-age') this.onsetAge,
      @JsonKey(name: 'onset-date') this.onsetDate,
      @JsonKey(name: 'onset-info') this.onsetInfo,
      @JsonKey(name: 'recorded-date') this.recordedDate,
      this.severity,
      this.stage,
      this.subject,
      @JsonKey(name: 'verification-status') this.verificationStatus})
      : super._();

  factory _$_ConditionSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_ConditionSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  @JsonKey(name: 'abatement-age')
  final List<SearchQuantity> abatementAge;
  @override
  @JsonKey(name: 'abatement-date')
  final List<SearchDate> abatementDate;
  @override
  @JsonKey(name: 'abatement-string')
  final List<SearchString> abatementString;
  @override
  final List<SearchReference> asserter;
  @override
  @JsonKey(name: 'body-site')
  final List<SearchToken> bodySite;
  @override
  final List<SearchToken> category;
  @override
  @JsonKey(name: 'clinical-status')
  final List<SearchToken> clinicalStatus;
  @override
  final List<SearchReference> encounter;
  @override
  final List<SearchToken> evidence;
  @override
  @JsonKey(name: 'evidence-detail')
  final List<SearchReference> evidenceDetail;
  @override
  @JsonKey(name: 'onset-age')
  final List<SearchQuantity> onsetAge;
  @override
  @JsonKey(name: 'onset-date')
  final List<SearchDate> onsetDate;
  @override
  @JsonKey(name: 'onset-info')
  final List<SearchString> onsetInfo;
  @override
  @JsonKey(name: 'recorded-date')
  final List<SearchDate> recordedDate;
  @override
  final List<SearchToken> severity;
  @override
  final List<SearchToken> stage;
  @override
  final List<SearchReference> subject;
  @override
  @JsonKey(name: 'verification-status')
  final List<SearchToken> verificationStatus;

  @override
  String toString() {
    return 'ConditionSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, code: $code, identifier: $identifier, patient: $patient, abatementAge: $abatementAge, abatementDate: $abatementDate, abatementString: $abatementString, asserter: $asserter, bodySite: $bodySite, category: $category, clinicalStatus: $clinicalStatus, encounter: $encounter, evidence: $evidence, evidenceDetail: $evidenceDetail, onsetAge: $onsetAge, onsetDate: $onsetDate, onsetInfo: $onsetInfo, recordedDate: $recordedDate, severity: $severity, stage: $stage, subject: $subject, verificationStatus: $verificationStatus)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ConditionSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.abatementAge, abatementAge) ||
                const DeepCollectionEquality()
                    .equals(other.abatementAge, abatementAge)) &&
            (identical(other.abatementDate, abatementDate) ||
                const DeepCollectionEquality()
                    .equals(other.abatementDate, abatementDate)) &&
            (identical(other.abatementString, abatementString) ||
                const DeepCollectionEquality()
                    .equals(other.abatementString, abatementString)) &&
            (identical(other.asserter, asserter) ||
                const DeepCollectionEquality()
                    .equals(other.asserter, asserter)) &&
            (identical(other.bodySite, bodySite) ||
                const DeepCollectionEquality()
                    .equals(other.bodySite, bodySite)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.clinicalStatus, clinicalStatus) ||
                const DeepCollectionEquality()
                    .equals(other.clinicalStatus, clinicalStatus)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.evidence, evidence) ||
                const DeepCollectionEquality()
                    .equals(other.evidence, evidence)) &&
            (identical(other.evidenceDetail, evidenceDetail) ||
                const DeepCollectionEquality()
                    .equals(other.evidenceDetail, evidenceDetail)) &&
            (identical(other.onsetAge, onsetAge) ||
                const DeepCollectionEquality()
                    .equals(other.onsetAge, onsetAge)) &&
            (identical(other.onsetDate, onsetDate) || const DeepCollectionEquality().equals(other.onsetDate, onsetDate)) &&
            (identical(other.onsetInfo, onsetInfo) || const DeepCollectionEquality().equals(other.onsetInfo, onsetInfo)) &&
            (identical(other.recordedDate, recordedDate) || const DeepCollectionEquality().equals(other.recordedDate, recordedDate)) &&
            (identical(other.severity, severity) || const DeepCollectionEquality().equals(other.severity, severity)) &&
            (identical(other.stage, stage) || const DeepCollectionEquality().equals(other.stage, stage)) &&
            (identical(other.subject, subject) || const DeepCollectionEquality().equals(other.subject, subject)) &&
            (identical(other.verificationStatus, verificationStatus) || const DeepCollectionEquality().equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(abatementAge) ^
      const DeepCollectionEquality().hash(abatementDate) ^
      const DeepCollectionEquality().hash(abatementString) ^
      const DeepCollectionEquality().hash(asserter) ^
      const DeepCollectionEquality().hash(bodySite) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(clinicalStatus) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(evidence) ^
      const DeepCollectionEquality().hash(evidenceDetail) ^
      const DeepCollectionEquality().hash(onsetAge) ^
      const DeepCollectionEquality().hash(onsetDate) ^
      const DeepCollectionEquality().hash(onsetInfo) ^
      const DeepCollectionEquality().hash(recordedDate) ^
      const DeepCollectionEquality().hash(severity) ^
      const DeepCollectionEquality().hash(stage) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(verificationStatus);

  @override
  _$ConditionSearchCopyWith<_ConditionSearch> get copyWith =>
      __$ConditionSearchCopyWithImpl<_ConditionSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ConditionSearchToJson(this);
  }
}

abstract class _ConditionSearch extends ConditionSearch {
  _ConditionSearch._() : super._();
  factory _ConditionSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'abatement-age')
          List<SearchQuantity> abatementAge,
      @JsonKey(name: 'abatement-date')
          List<SearchDate> abatementDate,
      @JsonKey(name: 'abatement-string')
          List<SearchString> abatementString,
      List<SearchReference> asserter,
      @JsonKey(name: 'body-site')
          List<SearchToken> bodySite,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchReference> encounter,
      List<SearchToken> evidence,
      @JsonKey(name: 'evidence-detail')
          List<SearchReference> evidenceDetail,
      @JsonKey(name: 'onset-age')
          List<SearchQuantity> onsetAge,
      @JsonKey(name: 'onset-date')
          List<SearchDate> onsetDate,
      @JsonKey(name: 'onset-info')
          List<SearchString> onsetInfo,
      @JsonKey(name: 'recorded-date')
          List<SearchDate> recordedDate,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<SearchReference> subject,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus}) = _$_ConditionSearch;

  factory _ConditionSearch.fromJson(Map<String, dynamic> json) =
      _$_ConditionSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  @JsonKey(name: 'abatement-age')
  List<SearchQuantity> get abatementAge;
  @override
  @JsonKey(name: 'abatement-date')
  List<SearchDate> get abatementDate;
  @override
  @JsonKey(name: 'abatement-string')
  List<SearchString> get abatementString;
  @override
  List<SearchReference> get asserter;
  @override
  @JsonKey(name: 'body-site')
  List<SearchToken> get bodySite;
  @override
  List<SearchToken> get category;
  @override
  @JsonKey(name: 'clinical-status')
  List<SearchToken> get clinicalStatus;
  @override
  List<SearchReference> get encounter;
  @override
  List<SearchToken> get evidence;
  @override
  @JsonKey(name: 'evidence-detail')
  List<SearchReference> get evidenceDetail;
  @override
  @JsonKey(name: 'onset-age')
  List<SearchQuantity> get onsetAge;
  @override
  @JsonKey(name: 'onset-date')
  List<SearchDate> get onsetDate;
  @override
  @JsonKey(name: 'onset-info')
  List<SearchString> get onsetInfo;
  @override
  @JsonKey(name: 'recorded-date')
  List<SearchDate> get recordedDate;
  @override
  List<SearchToken> get severity;
  @override
  List<SearchToken> get stage;
  @override
  List<SearchReference> get subject;
  @override
  @JsonKey(name: 'verification-status')
  List<SearchToken> get verificationStatus;
  @override
  _$ConditionSearchCopyWith<_ConditionSearch> get copyWith;
}

FamilyMemberHistorySearch _$FamilyMemberHistorySearchFromJson(
    Map<String, dynamic> json) {
  return _FamilyMemberHistorySearch.fromJson(json);
}

/// @nodoc
class _$FamilyMemberHistorySearchTearOff {
  const _$FamilyMemberHistorySearchTearOff();

// ignore: unused_element
  _FamilyMemberHistorySearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'instantiates-canonical')
          List<SearchReference> instantiatesCanonical,
      @JsonKey(name: 'instantiates-uri')
          List<SearchUri> instantiatesUri,
      List<SearchToken> relationship,
      List<SearchToken> sex,
      List<SearchToken> status}) {
    return _FamilyMemberHistorySearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      code: code,
      date: date,
      identifier: identifier,
      patient: patient,
      instantiatesCanonical: instantiatesCanonical,
      instantiatesUri: instantiatesUri,
      relationship: relationship,
      sex: sex,
      status: status,
    );
  }

// ignore: unused_element
  FamilyMemberHistorySearch fromJson(Map<String, Object> json) {
    return FamilyMemberHistorySearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $FamilyMemberHistorySearch = _$FamilyMemberHistorySearchTearOff();

/// @nodoc
mixin _$FamilyMemberHistorySearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  @JsonKey(name: 'instantiates-canonical')
  List<SearchReference> get instantiatesCanonical;
  @JsonKey(name: 'instantiates-uri')
  List<SearchUri> get instantiatesUri;
  List<SearchToken> get relationship;
  List<SearchToken> get sex;
  List<SearchToken> get status;

  Map<String, dynamic> toJson();
  $FamilyMemberHistorySearchCopyWith<FamilyMemberHistorySearch> get copyWith;
}

/// @nodoc
abstract class $FamilyMemberHistorySearchCopyWith<$Res> {
  factory $FamilyMemberHistorySearchCopyWith(FamilyMemberHistorySearch value,
          $Res Function(FamilyMemberHistorySearch) then) =
      _$FamilyMemberHistorySearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'instantiates-canonical')
          List<SearchReference> instantiatesCanonical,
      @JsonKey(name: 'instantiates-uri')
          List<SearchUri> instantiatesUri,
      List<SearchToken> relationship,
      List<SearchToken> sex,
      List<SearchToken> status});
}

/// @nodoc
class _$FamilyMemberHistorySearchCopyWithImpl<$Res>
    implements $FamilyMemberHistorySearchCopyWith<$Res> {
  _$FamilyMemberHistorySearchCopyWithImpl(this._value, this._then);

  final FamilyMemberHistorySearch _value;
  // ignore: unused_field
  final $Res Function(FamilyMemberHistorySearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object instantiatesCanonical = freezed,
    Object instantiatesUri = freezed,
    Object relationship = freezed,
    Object sex = freezed,
    Object status = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      instantiatesCanonical: instantiatesCanonical == freezed
          ? _value.instantiatesCanonical
          : instantiatesCanonical as List<SearchReference>,
      instantiatesUri: instantiatesUri == freezed
          ? _value.instantiatesUri
          : instantiatesUri as List<SearchUri>,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as List<SearchToken>,
      sex: sex == freezed ? _value.sex : sex as List<SearchToken>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$FamilyMemberHistorySearchCopyWith<$Res>
    implements $FamilyMemberHistorySearchCopyWith<$Res> {
  factory _$FamilyMemberHistorySearchCopyWith(_FamilyMemberHistorySearch value,
          $Res Function(_FamilyMemberHistorySearch) then) =
      __$FamilyMemberHistorySearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'instantiates-canonical')
          List<SearchReference> instantiatesCanonical,
      @JsonKey(name: 'instantiates-uri')
          List<SearchUri> instantiatesUri,
      List<SearchToken> relationship,
      List<SearchToken> sex,
      List<SearchToken> status});
}

/// @nodoc
class __$FamilyMemberHistorySearchCopyWithImpl<$Res>
    extends _$FamilyMemberHistorySearchCopyWithImpl<$Res>
    implements _$FamilyMemberHistorySearchCopyWith<$Res> {
  __$FamilyMemberHistorySearchCopyWithImpl(_FamilyMemberHistorySearch _value,
      $Res Function(_FamilyMemberHistorySearch) _then)
      : super(_value, (v) => _then(v as _FamilyMemberHistorySearch));

  @override
  _FamilyMemberHistorySearch get _value =>
      super._value as _FamilyMemberHistorySearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object instantiatesCanonical = freezed,
    Object instantiatesUri = freezed,
    Object relationship = freezed,
    Object sex = freezed,
    Object status = freezed,
  }) {
    return _then(_FamilyMemberHistorySearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      instantiatesCanonical: instantiatesCanonical == freezed
          ? _value.instantiatesCanonical
          : instantiatesCanonical as List<SearchReference>,
      instantiatesUri: instantiatesUri == freezed
          ? _value.instantiatesUri
          : instantiatesUri as List<SearchUri>,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as List<SearchToken>,
      sex: sex == freezed ? _value.sex : sex as List<SearchToken>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_FamilyMemberHistorySearch extends _FamilyMemberHistorySearch {
  _$_FamilyMemberHistorySearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.code,
      this.date,
      this.identifier,
      this.patient,
      @JsonKey(name: 'instantiates-canonical') this.instantiatesCanonical,
      @JsonKey(name: 'instantiates-uri') this.instantiatesUri,
      this.relationship,
      this.sex,
      this.status})
      : super._();

  factory _$_FamilyMemberHistorySearch.fromJson(Map<String, dynamic> json) =>
      _$_$_FamilyMemberHistorySearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  @JsonKey(name: 'instantiates-canonical')
  final List<SearchReference> instantiatesCanonical;
  @override
  @JsonKey(name: 'instantiates-uri')
  final List<SearchUri> instantiatesUri;
  @override
  final List<SearchToken> relationship;
  @override
  final List<SearchToken> sex;
  @override
  final List<SearchToken> status;

  @override
  String toString() {
    return 'FamilyMemberHistorySearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, code: $code, date: $date, identifier: $identifier, patient: $patient, instantiatesCanonical: $instantiatesCanonical, instantiatesUri: $instantiatesUri, relationship: $relationship, sex: $sex, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _FamilyMemberHistorySearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.instantiatesCanonical, instantiatesCanonical) ||
                const DeepCollectionEquality().equals(
                    other.instantiatesCanonical, instantiatesCanonical)) &&
            (identical(other.instantiatesUri, instantiatesUri) ||
                const DeepCollectionEquality()
                    .equals(other.instantiatesUri, instantiatesUri)) &&
            (identical(other.relationship, relationship) ||
                const DeepCollectionEquality()
                    .equals(other.relationship, relationship)) &&
            (identical(other.sex, sex) ||
                const DeepCollectionEquality().equals(other.sex, sex)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(instantiatesCanonical) ^
      const DeepCollectionEquality().hash(instantiatesUri) ^
      const DeepCollectionEquality().hash(relationship) ^
      const DeepCollectionEquality().hash(sex) ^
      const DeepCollectionEquality().hash(status);

  @override
  _$FamilyMemberHistorySearchCopyWith<_FamilyMemberHistorySearch>
      get copyWith =>
          __$FamilyMemberHistorySearchCopyWithImpl<_FamilyMemberHistorySearch>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_FamilyMemberHistorySearchToJson(this);
  }
}

abstract class _FamilyMemberHistorySearch extends FamilyMemberHistorySearch {
  _FamilyMemberHistorySearch._() : super._();
  factory _FamilyMemberHistorySearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'instantiates-canonical')
          List<SearchReference> instantiatesCanonical,
      @JsonKey(name: 'instantiates-uri')
          List<SearchUri> instantiatesUri,
      List<SearchToken> relationship,
      List<SearchToken> sex,
      List<SearchToken> status}) = _$_FamilyMemberHistorySearch;

  factory _FamilyMemberHistorySearch.fromJson(Map<String, dynamic> json) =
      _$_FamilyMemberHistorySearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  @JsonKey(name: 'instantiates-canonical')
  List<SearchReference> get instantiatesCanonical;
  @override
  @JsonKey(name: 'instantiates-uri')
  List<SearchUri> get instantiatesUri;
  @override
  List<SearchToken> get relationship;
  @override
  List<SearchToken> get sex;
  @override
  List<SearchToken> get status;
  @override
  _$FamilyMemberHistorySearchCopyWith<_FamilyMemberHistorySearch> get copyWith;
}

ProcedureSearch _$ProcedureSearchFromJson(Map<String, dynamic> json) {
  return _ProcedureSearch.fromJson(json);
}

/// @nodoc
class _$ProcedureSearchTearOff {
  const _$ProcedureSearchTearOff();

// ignore: unused_element
  _ProcedureSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      @JsonKey(name: 'based-on')
          List<SearchReference> basedOn,
      List<SearchToken> category,
      @JsonKey(name: 'instantiates-canonical')
          List<SearchReference> instantiatesCanonical,
      @JsonKey(name: 'instantiates-uri')
          List<SearchUri> instantiatesUri,
      List<SearchReference> location,
      @JsonKey(name: 'part-of')
          List<SearchReference> partOf,
      List<SearchReference> performer,
      @JsonKey(name: 'reason-code')
          List<SearchToken> reasonCode,
      @JsonKey(name: 'reason-reference')
          List<SearchReference> reasonReference,
      List<SearchToken> status,
      List<SearchReference> subject}) {
    return _ProcedureSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      code: code,
      date: date,
      identifier: identifier,
      patient: patient,
      encounter: encounter,
      basedOn: basedOn,
      category: category,
      instantiatesCanonical: instantiatesCanonical,
      instantiatesUri: instantiatesUri,
      location: location,
      partOf: partOf,
      performer: performer,
      reasonCode: reasonCode,
      reasonReference: reasonReference,
      status: status,
      subject: subject,
    );
  }

// ignore: unused_element
  ProcedureSearch fromJson(Map<String, Object> json) {
    return ProcedureSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $ProcedureSearch = _$ProcedureSearchTearOff();

/// @nodoc
mixin _$ProcedureSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  List<SearchReference> get encounter;
  @JsonKey(name: 'based-on')
  List<SearchReference> get basedOn;
  List<SearchToken> get category;
  @JsonKey(name: 'instantiates-canonical')
  List<SearchReference> get instantiatesCanonical;
  @JsonKey(name: 'instantiates-uri')
  List<SearchUri> get instantiatesUri;
  List<SearchReference> get location;
  @JsonKey(name: 'part-of')
  List<SearchReference> get partOf;
  List<SearchReference> get performer;
  @JsonKey(name: 'reason-code')
  List<SearchToken> get reasonCode;
  @JsonKey(name: 'reason-reference')
  List<SearchReference> get reasonReference;
  List<SearchToken> get status;
  List<SearchReference> get subject;

  Map<String, dynamic> toJson();
  $ProcedureSearchCopyWith<ProcedureSearch> get copyWith;
}

/// @nodoc
abstract class $ProcedureSearchCopyWith<$Res> {
  factory $ProcedureSearchCopyWith(
          ProcedureSearch value, $Res Function(ProcedureSearch) then) =
      _$ProcedureSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      @JsonKey(name: 'based-on')
          List<SearchReference> basedOn,
      List<SearchToken> category,
      @JsonKey(name: 'instantiates-canonical')
          List<SearchReference> instantiatesCanonical,
      @JsonKey(name: 'instantiates-uri')
          List<SearchUri> instantiatesUri,
      List<SearchReference> location,
      @JsonKey(name: 'part-of')
          List<SearchReference> partOf,
      List<SearchReference> performer,
      @JsonKey(name: 'reason-code')
          List<SearchToken> reasonCode,
      @JsonKey(name: 'reason-reference')
          List<SearchReference> reasonReference,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class _$ProcedureSearchCopyWithImpl<$Res>
    implements $ProcedureSearchCopyWith<$Res> {
  _$ProcedureSearchCopyWithImpl(this._value, this._then);

  final ProcedureSearch _value;
  // ignore: unused_field
  final $Res Function(ProcedureSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object encounter = freezed,
    Object basedOn = freezed,
    Object category = freezed,
    Object instantiatesCanonical = freezed,
    Object instantiatesUri = freezed,
    Object location = freezed,
    Object partOf = freezed,
    Object performer = freezed,
    Object reasonCode = freezed,
    Object reasonReference = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      basedOn: basedOn == freezed
          ? _value.basedOn
          : basedOn as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      instantiatesCanonical: instantiatesCanonical == freezed
          ? _value.instantiatesCanonical
          : instantiatesCanonical as List<SearchReference>,
      instantiatesUri: instantiatesUri == freezed
          ? _value.instantiatesUri
          : instantiatesUri as List<SearchUri>,
      location: location == freezed
          ? _value.location
          : location as List<SearchReference>,
      partOf:
          partOf == freezed ? _value.partOf : partOf as List<SearchReference>,
      performer: performer == freezed
          ? _value.performer
          : performer as List<SearchReference>,
      reasonCode: reasonCode == freezed
          ? _value.reasonCode
          : reasonCode as List<SearchToken>,
      reasonReference: reasonReference == freezed
          ? _value.reasonReference
          : reasonReference as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$ProcedureSearchCopyWith<$Res>
    implements $ProcedureSearchCopyWith<$Res> {
  factory _$ProcedureSearchCopyWith(
          _ProcedureSearch value, $Res Function(_ProcedureSearch) then) =
      __$ProcedureSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      @JsonKey(name: 'based-on')
          List<SearchReference> basedOn,
      List<SearchToken> category,
      @JsonKey(name: 'instantiates-canonical')
          List<SearchReference> instantiatesCanonical,
      @JsonKey(name: 'instantiates-uri')
          List<SearchUri> instantiatesUri,
      List<SearchReference> location,
      @JsonKey(name: 'part-of')
          List<SearchReference> partOf,
      List<SearchReference> performer,
      @JsonKey(name: 'reason-code')
          List<SearchToken> reasonCode,
      @JsonKey(name: 'reason-reference')
          List<SearchReference> reasonReference,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class __$ProcedureSearchCopyWithImpl<$Res>
    extends _$ProcedureSearchCopyWithImpl<$Res>
    implements _$ProcedureSearchCopyWith<$Res> {
  __$ProcedureSearchCopyWithImpl(
      _ProcedureSearch _value, $Res Function(_ProcedureSearch) _then)
      : super(_value, (v) => _then(v as _ProcedureSearch));

  @override
  _ProcedureSearch get _value => super._value as _ProcedureSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object encounter = freezed,
    Object basedOn = freezed,
    Object category = freezed,
    Object instantiatesCanonical = freezed,
    Object instantiatesUri = freezed,
    Object location = freezed,
    Object partOf = freezed,
    Object performer = freezed,
    Object reasonCode = freezed,
    Object reasonReference = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_ProcedureSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      basedOn: basedOn == freezed
          ? _value.basedOn
          : basedOn as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      instantiatesCanonical: instantiatesCanonical == freezed
          ? _value.instantiatesCanonical
          : instantiatesCanonical as List<SearchReference>,
      instantiatesUri: instantiatesUri == freezed
          ? _value.instantiatesUri
          : instantiatesUri as List<SearchUri>,
      location: location == freezed
          ? _value.location
          : location as List<SearchReference>,
      partOf:
          partOf == freezed ? _value.partOf : partOf as List<SearchReference>,
      performer: performer == freezed
          ? _value.performer
          : performer as List<SearchReference>,
      reasonCode: reasonCode == freezed
          ? _value.reasonCode
          : reasonCode as List<SearchToken>,
      reasonReference: reasonReference == freezed
          ? _value.reasonReference
          : reasonReference as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_ProcedureSearch extends _ProcedureSearch {
  _$_ProcedureSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.code,
      this.date,
      this.identifier,
      this.patient,
      this.encounter,
      @JsonKey(name: 'based-on') this.basedOn,
      this.category,
      @JsonKey(name: 'instantiates-canonical') this.instantiatesCanonical,
      @JsonKey(name: 'instantiates-uri') this.instantiatesUri,
      this.location,
      @JsonKey(name: 'part-of') this.partOf,
      this.performer,
      @JsonKey(name: 'reason-code') this.reasonCode,
      @JsonKey(name: 'reason-reference') this.reasonReference,
      this.status,
      this.subject})
      : super._();

  factory _$_ProcedureSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_ProcedureSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> encounter;
  @override
  @JsonKey(name: 'based-on')
  final List<SearchReference> basedOn;
  @override
  final List<SearchToken> category;
  @override
  @JsonKey(name: 'instantiates-canonical')
  final List<SearchReference> instantiatesCanonical;
  @override
  @JsonKey(name: 'instantiates-uri')
  final List<SearchUri> instantiatesUri;
  @override
  final List<SearchReference> location;
  @override
  @JsonKey(name: 'part-of')
  final List<SearchReference> partOf;
  @override
  final List<SearchReference> performer;
  @override
  @JsonKey(name: 'reason-code')
  final List<SearchToken> reasonCode;
  @override
  @JsonKey(name: 'reason-reference')
  final List<SearchReference> reasonReference;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;

  @override
  String toString() {
    return 'ProcedureSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, code: $code, date: $date, identifier: $identifier, patient: $patient, encounter: $encounter, basedOn: $basedOn, category: $category, instantiatesCanonical: $instantiatesCanonical, instantiatesUri: $instantiatesUri, location: $location, partOf: $partOf, performer: $performer, reasonCode: $reasonCode, reasonReference: $reasonReference, status: $status, subject: $subject)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ProcedureSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.basedOn, basedOn) ||
                const DeepCollectionEquality()
                    .equals(other.basedOn, basedOn)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.instantiatesCanonical, instantiatesCanonical) ||
                const DeepCollectionEquality().equals(
                    other.instantiatesCanonical, instantiatesCanonical)) &&
            (identical(other.instantiatesUri, instantiatesUri) ||
                const DeepCollectionEquality()
                    .equals(other.instantiatesUri, instantiatesUri)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.partOf, partOf) ||
                const DeepCollectionEquality().equals(other.partOf, partOf)) &&
            (identical(other.performer, performer) ||
                const DeepCollectionEquality()
                    .equals(other.performer, performer)) &&
            (identical(other.reasonCode, reasonCode) ||
                const DeepCollectionEquality()
                    .equals(other.reasonCode, reasonCode)) &&
            (identical(other.reasonReference, reasonReference) ||
                const DeepCollectionEquality()
                    .equals(other.reasonReference, reasonReference)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality().equals(other.subject, subject)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(basedOn) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(instantiatesCanonical) ^
      const DeepCollectionEquality().hash(instantiatesUri) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(partOf) ^
      const DeepCollectionEquality().hash(performer) ^
      const DeepCollectionEquality().hash(reasonCode) ^
      const DeepCollectionEquality().hash(reasonReference) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject);

  @override
  _$ProcedureSearchCopyWith<_ProcedureSearch> get copyWith =>
      __$ProcedureSearchCopyWithImpl<_ProcedureSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ProcedureSearchToJson(this);
  }
}

abstract class _ProcedureSearch extends ProcedureSearch {
  _ProcedureSearch._() : super._();
  factory _ProcedureSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      @JsonKey(name: 'based-on')
          List<SearchReference> basedOn,
      List<SearchToken> category,
      @JsonKey(name: 'instantiates-canonical')
          List<SearchReference> instantiatesCanonical,
      @JsonKey(name: 'instantiates-uri')
          List<SearchUri> instantiatesUri,
      List<SearchReference> location,
      @JsonKey(name: 'part-of')
          List<SearchReference> partOf,
      List<SearchReference> performer,
      @JsonKey(name: 'reason-code')
          List<SearchToken> reasonCode,
      @JsonKey(name: 'reason-reference')
          List<SearchReference> reasonReference,
      List<SearchToken> status,
      List<SearchReference> subject}) = _$_ProcedureSearch;

  factory _ProcedureSearch.fromJson(Map<String, dynamic> json) =
      _$_ProcedureSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get encounter;
  @override
  @JsonKey(name: 'based-on')
  List<SearchReference> get basedOn;
  @override
  List<SearchToken> get category;
  @override
  @JsonKey(name: 'instantiates-canonical')
  List<SearchReference> get instantiatesCanonical;
  @override
  @JsonKey(name: 'instantiates-uri')
  List<SearchUri> get instantiatesUri;
  @override
  List<SearchReference> get location;
  @override
  @JsonKey(name: 'part-of')
  List<SearchReference> get partOf;
  @override
  List<SearchReference> get performer;
  @override
  @JsonKey(name: 'reason-code')
  List<SearchToken> get reasonCode;
  @override
  @JsonKey(name: 'reason-reference')
  List<SearchReference> get reasonReference;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  _$ProcedureSearchCopyWith<_ProcedureSearch> get copyWith;
}

ClinicalImpressionSearch _$ClinicalImpressionSearchFromJson(
    Map<String, dynamic> json) {
  return _ClinicalImpressionSearch.fromJson(json);
}

/// @nodoc
class _$ClinicalImpressionSearchTearOff {
  const _$ClinicalImpressionSearchTearOff();

// ignore: unused_element
  _ClinicalImpressionSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchReference> patient,
      List<SearchReference> assessor,
      List<SearchReference> encounter,
      @JsonKey(name: 'finding-code') List<SearchToken> findingCode,
      @JsonKey(name: 'finding-ref') List<SearchReference> findingRef,
      List<SearchToken> identifier,
      List<SearchReference> investigation,
      List<SearchReference> previous,
      List<SearchReference> problem,
      List<SearchToken> status,
      List<SearchReference> subject,
      @JsonKey(name: 'supporting-info') List<SearchReference> supportingInfo}) {
    return _ClinicalImpressionSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      date: date,
      patient: patient,
      assessor: assessor,
      encounter: encounter,
      findingCode: findingCode,
      findingRef: findingRef,
      identifier: identifier,
      investigation: investigation,
      previous: previous,
      problem: problem,
      status: status,
      subject: subject,
      supportingInfo: supportingInfo,
    );
  }

// ignore: unused_element
  ClinicalImpressionSearch fromJson(Map<String, Object> json) {
    return ClinicalImpressionSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $ClinicalImpressionSearch = _$ClinicalImpressionSearchTearOff();

/// @nodoc
mixin _$ClinicalImpressionSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchDate> get date;
  List<SearchReference> get patient;
  List<SearchReference> get assessor;
  List<SearchReference> get encounter;
  @JsonKey(name: 'finding-code')
  List<SearchToken> get findingCode;
  @JsonKey(name: 'finding-ref')
  List<SearchReference> get findingRef;
  List<SearchToken> get identifier;
  List<SearchReference> get investigation;
  List<SearchReference> get previous;
  List<SearchReference> get problem;
  List<SearchToken> get status;
  List<SearchReference> get subject;
  @JsonKey(name: 'supporting-info')
  List<SearchReference> get supportingInfo;

  Map<String, dynamic> toJson();
  $ClinicalImpressionSearchCopyWith<ClinicalImpressionSearch> get copyWith;
}

/// @nodoc
abstract class $ClinicalImpressionSearchCopyWith<$Res> {
  factory $ClinicalImpressionSearchCopyWith(ClinicalImpressionSearch value,
          $Res Function(ClinicalImpressionSearch) then) =
      _$ClinicalImpressionSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchReference> patient,
      List<SearchReference> assessor,
      List<SearchReference> encounter,
      @JsonKey(name: 'finding-code') List<SearchToken> findingCode,
      @JsonKey(name: 'finding-ref') List<SearchReference> findingRef,
      List<SearchToken> identifier,
      List<SearchReference> investigation,
      List<SearchReference> previous,
      List<SearchReference> problem,
      List<SearchToken> status,
      List<SearchReference> subject,
      @JsonKey(name: 'supporting-info') List<SearchReference> supportingInfo});
}

/// @nodoc
class _$ClinicalImpressionSearchCopyWithImpl<$Res>
    implements $ClinicalImpressionSearchCopyWith<$Res> {
  _$ClinicalImpressionSearchCopyWithImpl(this._value, this._then);

  final ClinicalImpressionSearch _value;
  // ignore: unused_field
  final $Res Function(ClinicalImpressionSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object date = freezed,
    Object patient = freezed,
    Object assessor = freezed,
    Object encounter = freezed,
    Object findingCode = freezed,
    Object findingRef = freezed,
    Object identifier = freezed,
    Object investigation = freezed,
    Object previous = freezed,
    Object problem = freezed,
    Object status = freezed,
    Object subject = freezed,
    Object supportingInfo = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      assessor: assessor == freezed
          ? _value.assessor
          : assessor as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      findingCode: findingCode == freezed
          ? _value.findingCode
          : findingCode as List<SearchToken>,
      findingRef: findingRef == freezed
          ? _value.findingRef
          : findingRef as List<SearchReference>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      investigation: investigation == freezed
          ? _value.investigation
          : investigation as List<SearchReference>,
      previous: previous == freezed
          ? _value.previous
          : previous as List<SearchReference>,
      problem: problem == freezed
          ? _value.problem
          : problem as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      supportingInfo: supportingInfo == freezed
          ? _value.supportingInfo
          : supportingInfo as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$ClinicalImpressionSearchCopyWith<$Res>
    implements $ClinicalImpressionSearchCopyWith<$Res> {
  factory _$ClinicalImpressionSearchCopyWith(_ClinicalImpressionSearch value,
          $Res Function(_ClinicalImpressionSearch) then) =
      __$ClinicalImpressionSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchReference> patient,
      List<SearchReference> assessor,
      List<SearchReference> encounter,
      @JsonKey(name: 'finding-code') List<SearchToken> findingCode,
      @JsonKey(name: 'finding-ref') List<SearchReference> findingRef,
      List<SearchToken> identifier,
      List<SearchReference> investigation,
      List<SearchReference> previous,
      List<SearchReference> problem,
      List<SearchToken> status,
      List<SearchReference> subject,
      @JsonKey(name: 'supporting-info') List<SearchReference> supportingInfo});
}

/// @nodoc
class __$ClinicalImpressionSearchCopyWithImpl<$Res>
    extends _$ClinicalImpressionSearchCopyWithImpl<$Res>
    implements _$ClinicalImpressionSearchCopyWith<$Res> {
  __$ClinicalImpressionSearchCopyWithImpl(_ClinicalImpressionSearch _value,
      $Res Function(_ClinicalImpressionSearch) _then)
      : super(_value, (v) => _then(v as _ClinicalImpressionSearch));

  @override
  _ClinicalImpressionSearch get _value =>
      super._value as _ClinicalImpressionSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object date = freezed,
    Object patient = freezed,
    Object assessor = freezed,
    Object encounter = freezed,
    Object findingCode = freezed,
    Object findingRef = freezed,
    Object identifier = freezed,
    Object investigation = freezed,
    Object previous = freezed,
    Object problem = freezed,
    Object status = freezed,
    Object subject = freezed,
    Object supportingInfo = freezed,
  }) {
    return _then(_ClinicalImpressionSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      assessor: assessor == freezed
          ? _value.assessor
          : assessor as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      findingCode: findingCode == freezed
          ? _value.findingCode
          : findingCode as List<SearchToken>,
      findingRef: findingRef == freezed
          ? _value.findingRef
          : findingRef as List<SearchReference>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      investigation: investigation == freezed
          ? _value.investigation
          : investigation as List<SearchReference>,
      previous: previous == freezed
          ? _value.previous
          : previous as List<SearchReference>,
      problem: problem == freezed
          ? _value.problem
          : problem as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      supportingInfo: supportingInfo == freezed
          ? _value.supportingInfo
          : supportingInfo as List<SearchReference>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_ClinicalImpressionSearch extends _ClinicalImpressionSearch {
  _$_ClinicalImpressionSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.date,
      this.patient,
      this.assessor,
      this.encounter,
      @JsonKey(name: 'finding-code') this.findingCode,
      @JsonKey(name: 'finding-ref') this.findingRef,
      this.identifier,
      this.investigation,
      this.previous,
      this.problem,
      this.status,
      this.subject,
      @JsonKey(name: 'supporting-info') this.supportingInfo})
      : super._();

  factory _$_ClinicalImpressionSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_ClinicalImpressionSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchDate> date;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> assessor;
  @override
  final List<SearchReference> encounter;
  @override
  @JsonKey(name: 'finding-code')
  final List<SearchToken> findingCode;
  @override
  @JsonKey(name: 'finding-ref')
  final List<SearchReference> findingRef;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> investigation;
  @override
  final List<SearchReference> previous;
  @override
  final List<SearchReference> problem;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;
  @override
  @JsonKey(name: 'supporting-info')
  final List<SearchReference> supportingInfo;

  @override
  String toString() {
    return 'ClinicalImpressionSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, date: $date, patient: $patient, assessor: $assessor, encounter: $encounter, findingCode: $findingCode, findingRef: $findingRef, identifier: $identifier, investigation: $investigation, previous: $previous, problem: $problem, status: $status, subject: $subject, supportingInfo: $supportingInfo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ClinicalImpressionSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.assessor, assessor) ||
                const DeepCollectionEquality()
                    .equals(other.assessor, assessor)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.findingCode, findingCode) ||
                const DeepCollectionEquality()
                    .equals(other.findingCode, findingCode)) &&
            (identical(other.findingRef, findingRef) ||
                const DeepCollectionEquality()
                    .equals(other.findingRef, findingRef)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.investigation, investigation) ||
                const DeepCollectionEquality()
                    .equals(other.investigation, investigation)) &&
            (identical(other.previous, previous) ||
                const DeepCollectionEquality()
                    .equals(other.previous, previous)) &&
            (identical(other.problem, problem) ||
                const DeepCollectionEquality()
                    .equals(other.problem, problem)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.supportingInfo, supportingInfo) ||
                const DeepCollectionEquality()
                    .equals(other.supportingInfo, supportingInfo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(assessor) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(findingCode) ^
      const DeepCollectionEquality().hash(findingRef) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(investigation) ^
      const DeepCollectionEquality().hash(previous) ^
      const DeepCollectionEquality().hash(problem) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(supportingInfo);

  @override
  _$ClinicalImpressionSearchCopyWith<_ClinicalImpressionSearch> get copyWith =>
      __$ClinicalImpressionSearchCopyWithImpl<_ClinicalImpressionSearch>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ClinicalImpressionSearchToJson(this);
  }
}

abstract class _ClinicalImpressionSearch extends ClinicalImpressionSearch {
  _ClinicalImpressionSearch._() : super._();
  factory _ClinicalImpressionSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchReference> patient,
      List<SearchReference> assessor,
      List<SearchReference> encounter,
      @JsonKey(name: 'finding-code')
          List<SearchToken> findingCode,
      @JsonKey(name: 'finding-ref')
          List<SearchReference> findingRef,
      List<SearchToken> identifier,
      List<SearchReference> investigation,
      List<SearchReference> previous,
      List<SearchReference> problem,
      List<SearchToken> status,
      List<SearchReference> subject,
      @JsonKey(name: 'supporting-info')
          List<SearchReference> supportingInfo}) = _$_ClinicalImpressionSearch;

  factory _ClinicalImpressionSearch.fromJson(Map<String, dynamic> json) =
      _$_ClinicalImpressionSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchDate> get date;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get assessor;
  @override
  List<SearchReference> get encounter;
  @override
  @JsonKey(name: 'finding-code')
  List<SearchToken> get findingCode;
  @override
  @JsonKey(name: 'finding-ref')
  List<SearchReference> get findingRef;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get investigation;
  @override
  List<SearchReference> get previous;
  @override
  List<SearchReference> get problem;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  @JsonKey(name: 'supporting-info')
  List<SearchReference> get supportingInfo;
  @override
  _$ClinicalImpressionSearchCopyWith<_ClinicalImpressionSearch> get copyWith;
}

DetectedIssueSearch _$DetectedIssueSearchFromJson(Map<String, dynamic> json) {
  return _DetectedIssueSearch.fromJson(json);
}

/// @nodoc
class _$DetectedIssueSearchTearOff {
  const _$DetectedIssueSearchTearOff();

// ignore: unused_element
  _DetectedIssueSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> author,
      List<SearchToken> code,
      List<SearchDate> identified,
      List<SearchReference> implicated}) {
    return _DetectedIssueSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      identifier: identifier,
      patient: patient,
      author: author,
      code: code,
      identified: identified,
      implicated: implicated,
    );
  }

// ignore: unused_element
  DetectedIssueSearch fromJson(Map<String, Object> json) {
    return DetectedIssueSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $DetectedIssueSearch = _$DetectedIssueSearchTearOff();

/// @nodoc
mixin _$DetectedIssueSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  List<SearchReference> get author;
  List<SearchToken> get code;
  List<SearchDate> get identified;
  List<SearchReference> get implicated;

  Map<String, dynamic> toJson();
  $DetectedIssueSearchCopyWith<DetectedIssueSearch> get copyWith;
}

/// @nodoc
abstract class $DetectedIssueSearchCopyWith<$Res> {
  factory $DetectedIssueSearchCopyWith(
          DetectedIssueSearch value, $Res Function(DetectedIssueSearch) then) =
      _$DetectedIssueSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> author,
      List<SearchToken> code,
      List<SearchDate> identified,
      List<SearchReference> implicated});
}

/// @nodoc
class _$DetectedIssueSearchCopyWithImpl<$Res>
    implements $DetectedIssueSearchCopyWith<$Res> {
  _$DetectedIssueSearchCopyWithImpl(this._value, this._then);

  final DetectedIssueSearch _value;
  // ignore: unused_field
  final $Res Function(DetectedIssueSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object author = freezed,
    Object code = freezed,
    Object identified = freezed,
    Object implicated = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      author:
          author == freezed ? _value.author : author as List<SearchReference>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      identified: identified == freezed
          ? _value.identified
          : identified as List<SearchDate>,
      implicated: implicated == freezed
          ? _value.implicated
          : implicated as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$DetectedIssueSearchCopyWith<$Res>
    implements $DetectedIssueSearchCopyWith<$Res> {
  factory _$DetectedIssueSearchCopyWith(_DetectedIssueSearch value,
          $Res Function(_DetectedIssueSearch) then) =
      __$DetectedIssueSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> author,
      List<SearchToken> code,
      List<SearchDate> identified,
      List<SearchReference> implicated});
}

/// @nodoc
class __$DetectedIssueSearchCopyWithImpl<$Res>
    extends _$DetectedIssueSearchCopyWithImpl<$Res>
    implements _$DetectedIssueSearchCopyWith<$Res> {
  __$DetectedIssueSearchCopyWithImpl(
      _DetectedIssueSearch _value, $Res Function(_DetectedIssueSearch) _then)
      : super(_value, (v) => _then(v as _DetectedIssueSearch));

  @override
  _DetectedIssueSearch get _value => super._value as _DetectedIssueSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object author = freezed,
    Object code = freezed,
    Object identified = freezed,
    Object implicated = freezed,
  }) {
    return _then(_DetectedIssueSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      author:
          author == freezed ? _value.author : author as List<SearchReference>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      identified: identified == freezed
          ? _value.identified
          : identified as List<SearchDate>,
      implicated: implicated == freezed
          ? _value.implicated
          : implicated as List<SearchReference>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_DetectedIssueSearch extends _DetectedIssueSearch {
  _$_DetectedIssueSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.identifier,
      this.patient,
      this.author,
      this.code,
      this.identified,
      this.implicated})
      : super._();

  factory _$_DetectedIssueSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_DetectedIssueSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> author;
  @override
  final List<SearchToken> code;
  @override
  final List<SearchDate> identified;
  @override
  final List<SearchReference> implicated;

  @override
  String toString() {
    return 'DetectedIssueSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, identifier: $identifier, patient: $patient, author: $author, code: $code, identified: $identified, implicated: $implicated)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DetectedIssueSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.identified, identified) ||
                const DeepCollectionEquality()
                    .equals(other.identified, identified)) &&
            (identical(other.implicated, implicated) ||
                const DeepCollectionEquality()
                    .equals(other.implicated, implicated)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(identified) ^
      const DeepCollectionEquality().hash(implicated);

  @override
  _$DetectedIssueSearchCopyWith<_DetectedIssueSearch> get copyWith =>
      __$DetectedIssueSearchCopyWithImpl<_DetectedIssueSearch>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DetectedIssueSearchToJson(this);
  }
}

abstract class _DetectedIssueSearch extends DetectedIssueSearch {
  _DetectedIssueSearch._() : super._();
  factory _DetectedIssueSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> author,
      List<SearchToken> code,
      List<SearchDate> identified,
      List<SearchReference> implicated}) = _$_DetectedIssueSearch;

  factory _DetectedIssueSearch.fromJson(Map<String, dynamic> json) =
      _$_DetectedIssueSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get author;
  @override
  List<SearchToken> get code;
  @override
  List<SearchDate> get identified;
  @override
  List<SearchReference> get implicated;
  @override
  _$DetectedIssueSearchCopyWith<_DetectedIssueSearch> get copyWith;
}

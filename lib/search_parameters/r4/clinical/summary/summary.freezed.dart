// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'summary.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$AdverseEventSearchTearOff {
  const _$AdverseEventSearchTearOff();

// ignore: unused_element
  _AdverseEventSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> actuality,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchToken> event,
      List<String> location,
      List<String> recorder,
      List<String> resultingcondition,
      List<SearchToken> seriousness,
      List<SearchToken> severity,
      List<String> study,
      List<String> subject,
      List<String> substance}) {
    return _AdverseEventSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      actuality: actuality,
      category: category,
      date: date,
      event: event,
      location: location,
      recorder: recorder,
      resultingcondition: resultingcondition,
      seriousness: seriousness,
      severity: severity,
      study: study,
      subject: subject,
      substance: substance,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AdverseEventSearch = _$AdverseEventSearchTearOff();

/// @nodoc
mixin _$AdverseEventSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated; //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get actuality;
  List<SearchToken> get category;
  List<SearchDate> get date;
  List<SearchToken> get event;
  List<String> get location;
  List<String> get recorder;
  List<String> get resultingcondition;
  List<SearchToken> get seriousness;
  List<SearchToken> get severity;
  List<String> get study;
  List<String> get subject;
  List<String> get substance;

  $AdverseEventSearchCopyWith<AdverseEventSearch> get copyWith;
}

/// @nodoc
abstract class $AdverseEventSearchCopyWith<$Res> {
  factory $AdverseEventSearchCopyWith(
          AdverseEventSearch value, $Res Function(AdverseEventSearch) then) =
      _$AdverseEventSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> actuality,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchToken> event,
      List<String> location,
      List<String> recorder,
      List<String> resultingcondition,
      List<SearchToken> seriousness,
      List<SearchToken> severity,
      List<String> study,
      List<String> subject,
      List<String> substance});
}

/// @nodoc
class _$AdverseEventSearchCopyWithImpl<$Res>
    implements $AdverseEventSearchCopyWith<$Res> {
  _$AdverseEventSearchCopyWithImpl(this._value, this._then);

  final AdverseEventSearch _value;
  // ignore: unused_field
  final $Res Function(AdverseEventSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object actuality = freezed,
    Object category = freezed,
    Object date = freezed,
    Object event = freezed,
    Object location = freezed,
    Object recorder = freezed,
    Object resultingcondition = freezed,
    Object seriousness = freezed,
    Object severity = freezed,
    Object study = freezed,
    Object subject = freezed,
    Object substance = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      actuality: actuality == freezed
          ? _value.actuality
          : actuality as List<SearchToken>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      event: event == freezed ? _value.event : event as List<SearchToken>,
      location:
          location == freezed ? _value.location : location as List<String>,
      recorder:
          recorder == freezed ? _value.recorder : recorder as List<String>,
      resultingcondition: resultingcondition == freezed
          ? _value.resultingcondition
          : resultingcondition as List<String>,
      seriousness: seriousness == freezed
          ? _value.seriousness
          : seriousness as List<SearchToken>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      study: study == freezed ? _value.study : study as List<String>,
      subject: subject == freezed ? _value.subject : subject as List<String>,
      substance:
          substance == freezed ? _value.substance : substance as List<String>,
    ));
  }
}

/// @nodoc
abstract class _$AdverseEventSearchCopyWith<$Res>
    implements $AdverseEventSearchCopyWith<$Res> {
  factory _$AdverseEventSearchCopyWith(
          _AdverseEventSearch value, $Res Function(_AdverseEventSearch) then) =
      __$AdverseEventSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> actuality,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchToken> event,
      List<String> location,
      List<String> recorder,
      List<String> resultingcondition,
      List<SearchToken> seriousness,
      List<SearchToken> severity,
      List<String> study,
      List<String> subject,
      List<String> substance});
}

/// @nodoc
class __$AdverseEventSearchCopyWithImpl<$Res>
    extends _$AdverseEventSearchCopyWithImpl<$Res>
    implements _$AdverseEventSearchCopyWith<$Res> {
  __$AdverseEventSearchCopyWithImpl(
      _AdverseEventSearch _value, $Res Function(_AdverseEventSearch) _then)
      : super(_value, (v) => _then(v as _AdverseEventSearch));

  @override
  _AdverseEventSearch get _value => super._value as _AdverseEventSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object actuality = freezed,
    Object category = freezed,
    Object date = freezed,
    Object event = freezed,
    Object location = freezed,
    Object recorder = freezed,
    Object resultingcondition = freezed,
    Object seriousness = freezed,
    Object severity = freezed,
    Object study = freezed,
    Object subject = freezed,
    Object substance = freezed,
  }) {
    return _then(_AdverseEventSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      actuality: actuality == freezed
          ? _value.actuality
          : actuality as List<SearchToken>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      event: event == freezed ? _value.event : event as List<SearchToken>,
      location:
          location == freezed ? _value.location : location as List<String>,
      recorder:
          recorder == freezed ? _value.recorder : recorder as List<String>,
      resultingcondition: resultingcondition == freezed
          ? _value.resultingcondition
          : resultingcondition as List<String>,
      seriousness: seriousness == freezed
          ? _value.seriousness
          : seriousness as List<SearchToken>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      study: study == freezed ? _value.study : study as List<String>,
      subject: subject == freezed ? _value.subject : subject as List<String>,
      substance:
          substance == freezed ? _value.substance : substance as List<String>,
    ));
  }
}

/// @nodoc
class _$_AdverseEventSearch extends _AdverseEventSearch {
  _$_AdverseEventSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.actuality,
      this.category,
      this.date,
      this.event,
      this.location,
      this.recorder,
      this.resultingcondition,
      this.seriousness,
      this.severity,
      this.study,
      this.subject,
      this.substance})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> actuality;
  @override
  final List<SearchToken> category;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> event;
  @override
  final List<String> location;
  @override
  final List<String> recorder;
  @override
  final List<String> resultingcondition;
  @override
  final List<SearchToken> seriousness;
  @override
  final List<SearchToken> severity;
  @override
  final List<String> study;
  @override
  final List<String> subject;
  @override
  final List<String> substance;

  @override
  String toString() {
    return 'AdverseEventSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, actuality: $actuality, category: $category, date: $date, event: $event, location: $location, recorder: $recorder, resultingcondition: $resultingcondition, seriousness: $seriousness, severity: $severity, study: $study, subject: $subject, substance: $substance)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AdverseEventSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.actuality, actuality) ||
                const DeepCollectionEquality()
                    .equals(other.actuality, actuality)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.event, event) ||
                const DeepCollectionEquality().equals(other.event, event)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.recorder, recorder) ||
                const DeepCollectionEquality()
                    .equals(other.recorder, recorder)) &&
            (identical(other.resultingcondition, resultingcondition) ||
                const DeepCollectionEquality()
                    .equals(other.resultingcondition, resultingcondition)) &&
            (identical(other.seriousness, seriousness) ||
                const DeepCollectionEquality()
                    .equals(other.seriousness, seriousness)) &&
            (identical(other.severity, severity) ||
                const DeepCollectionEquality()
                    .equals(other.severity, severity)) &&
            (identical(other.study, study) ||
                const DeepCollectionEquality().equals(other.study, study)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.substance, substance) ||
                const DeepCollectionEquality()
                    .equals(other.substance, substance)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(actuality) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(event) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(recorder) ^
      const DeepCollectionEquality().hash(resultingcondition) ^
      const DeepCollectionEquality().hash(seriousness) ^
      const DeepCollectionEquality().hash(severity) ^
      const DeepCollectionEquality().hash(study) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(substance);

  @override
  _$AdverseEventSearchCopyWith<_AdverseEventSearch> get copyWith =>
      __$AdverseEventSearchCopyWithImpl<_AdverseEventSearch>(this, _$identity);
}

abstract class _AdverseEventSearch extends AdverseEventSearch {
  _AdverseEventSearch._() : super._();
  factory _AdverseEventSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> actuality,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchToken> event,
      List<String> location,
      List<String> recorder,
      List<String> resultingcondition,
      List<SearchToken> seriousness,
      List<SearchToken> severity,
      List<String> study,
      List<String> subject,
      List<String> substance}) = _$_AdverseEventSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get actuality;
  @override
  List<SearchToken> get category;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get event;
  @override
  List<String> get location;
  @override
  List<String> get recorder;
  @override
  List<String> get resultingcondition;
  @override
  List<SearchToken> get seriousness;
  @override
  List<SearchToken> get severity;
  @override
  List<String> get study;
  @override
  List<String> get subject;
  @override
  List<String> get substance;
  @override
  _$AdverseEventSearchCopyWith<_AdverseEventSearch> get copyWith;
}

/// @nodoc
class _$AllergyIntoleranceSearchTearOff {
  const _$AllergyIntoleranceSearchTearOff();

// ignore: unused_element
  _AllergyIntoleranceSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<String> asserter,
      List<SearchToken> category,
      List<SearchToken> clinical_status,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchDate> last_date,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<String> patient,
      List<String> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      List<SearchToken> verification_status}) {
    return _AllergyIntoleranceSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      asserter: asserter,
      category: category,
      clinical_status: clinical_status,
      code: code,
      criticality: criticality,
      date: date,
      identifier: identifier,
      last_date: last_date,
      manifestation: manifestation,
      onset: onset,
      patient: patient,
      recorder: recorder,
      route: route,
      severity: severity,
      type: type,
      verification_status: verification_status,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AllergyIntoleranceSearch = _$AllergyIntoleranceSearchTearOff();

/// @nodoc
mixin _$AllergyIntoleranceSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated; //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<String> get asserter;
  List<SearchToken> get category;
  List<SearchToken> get clinical_status;
  List<SearchToken> get code;
  List<SearchToken> get criticality;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<SearchDate> get last_date;
  List<SearchToken> get manifestation;
  List<SearchDate> get onset;
  List<String> get patient;
  List<String> get recorder;
  List<SearchToken> get route;
  List<SearchToken> get severity;
  List<SearchToken> get type;
  List<SearchToken> get verification_status;

  $AllergyIntoleranceSearchCopyWith<AllergyIntoleranceSearch> get copyWith;
}

/// @nodoc
abstract class $AllergyIntoleranceSearchCopyWith<$Res> {
  factory $AllergyIntoleranceSearchCopyWith(AllergyIntoleranceSearch value,
          $Res Function(AllergyIntoleranceSearch) then) =
      _$AllergyIntoleranceSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<String> asserter,
      List<SearchToken> category,
      List<SearchToken> clinical_status,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchDate> last_date,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<String> patient,
      List<String> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      List<SearchToken> verification_status});
}

/// @nodoc
class _$AllergyIntoleranceSearchCopyWithImpl<$Res>
    implements $AllergyIntoleranceSearchCopyWith<$Res> {
  _$AllergyIntoleranceSearchCopyWithImpl(this._value, this._then);

  final AllergyIntoleranceSearch _value;
  // ignore: unused_field
  final $Res Function(AllergyIntoleranceSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object asserter = freezed,
    Object category = freezed,
    Object clinical_status = freezed,
    Object code = freezed,
    Object criticality = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object last_date = freezed,
    Object manifestation = freezed,
    Object onset = freezed,
    Object patient = freezed,
    Object recorder = freezed,
    Object route = freezed,
    Object severity = freezed,
    Object type = freezed,
    Object verification_status = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      asserter:
          asserter == freezed ? _value.asserter : asserter as List<String>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinical_status: clinical_status == freezed
          ? _value.clinical_status
          : clinical_status as List<SearchToken>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      criticality: criticality == freezed
          ? _value.criticality
          : criticality as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      last_date: last_date == freezed
          ? _value.last_date
          : last_date as List<SearchDate>,
      manifestation: manifestation == freezed
          ? _value.manifestation
          : manifestation as List<SearchToken>,
      onset: onset == freezed ? _value.onset : onset as List<SearchDate>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      recorder:
          recorder == freezed ? _value.recorder : recorder as List<String>,
      route: route == freezed ? _value.route : route as List<SearchToken>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      verification_status: verification_status == freezed
          ? _value.verification_status
          : verification_status as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$AllergyIntoleranceSearchCopyWith<$Res>
    implements $AllergyIntoleranceSearchCopyWith<$Res> {
  factory _$AllergyIntoleranceSearchCopyWith(_AllergyIntoleranceSearch value,
          $Res Function(_AllergyIntoleranceSearch) then) =
      __$AllergyIntoleranceSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<String> asserter,
      List<SearchToken> category,
      List<SearchToken> clinical_status,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchDate> last_date,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<String> patient,
      List<String> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      List<SearchToken> verification_status});
}

/// @nodoc
class __$AllergyIntoleranceSearchCopyWithImpl<$Res>
    extends _$AllergyIntoleranceSearchCopyWithImpl<$Res>
    implements _$AllergyIntoleranceSearchCopyWith<$Res> {
  __$AllergyIntoleranceSearchCopyWithImpl(_AllergyIntoleranceSearch _value,
      $Res Function(_AllergyIntoleranceSearch) _then)
      : super(_value, (v) => _then(v as _AllergyIntoleranceSearch));

  @override
  _AllergyIntoleranceSearch get _value =>
      super._value as _AllergyIntoleranceSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object asserter = freezed,
    Object category = freezed,
    Object clinical_status = freezed,
    Object code = freezed,
    Object criticality = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object last_date = freezed,
    Object manifestation = freezed,
    Object onset = freezed,
    Object patient = freezed,
    Object recorder = freezed,
    Object route = freezed,
    Object severity = freezed,
    Object type = freezed,
    Object verification_status = freezed,
  }) {
    return _then(_AllergyIntoleranceSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      asserter:
          asserter == freezed ? _value.asserter : asserter as List<String>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinical_status: clinical_status == freezed
          ? _value.clinical_status
          : clinical_status as List<SearchToken>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      criticality: criticality == freezed
          ? _value.criticality
          : criticality as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      last_date: last_date == freezed
          ? _value.last_date
          : last_date as List<SearchDate>,
      manifestation: manifestation == freezed
          ? _value.manifestation
          : manifestation as List<SearchToken>,
      onset: onset == freezed ? _value.onset : onset as List<SearchDate>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      recorder:
          recorder == freezed ? _value.recorder : recorder as List<String>,
      route: route == freezed ? _value.route : route as List<SearchToken>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      verification_status: verification_status == freezed
          ? _value.verification_status
          : verification_status as List<SearchToken>,
    ));
  }
}

/// @nodoc
class _$_AllergyIntoleranceSearch extends _AllergyIntoleranceSearch {
  _$_AllergyIntoleranceSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.asserter,
      this.category,
      this.clinical_status,
      this.code,
      this.criticality,
      this.date,
      this.identifier,
      this.last_date,
      this.manifestation,
      this.onset,
      this.patient,
      this.recorder,
      this.route,
      this.severity,
      this.type,
      this.verification_status})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<String> asserter;
  @override
  final List<SearchToken> category;
  @override
  final List<SearchToken> clinical_status;
  @override
  final List<SearchToken> code;
  @override
  final List<SearchToken> criticality;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchDate> last_date;
  @override
  final List<SearchToken> manifestation;
  @override
  final List<SearchDate> onset;
  @override
  final List<String> patient;
  @override
  final List<String> recorder;
  @override
  final List<SearchToken> route;
  @override
  final List<SearchToken> severity;
  @override
  final List<SearchToken> type;
  @override
  final List<SearchToken> verification_status;

  @override
  String toString() {
    return 'AllergyIntoleranceSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, asserter: $asserter, category: $category, clinical_status: $clinical_status, code: $code, criticality: $criticality, date: $date, identifier: $identifier, last_date: $last_date, manifestation: $manifestation, onset: $onset, patient: $patient, recorder: $recorder, route: $route, severity: $severity, type: $type, verification_status: $verification_status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AllergyIntoleranceSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.asserter, asserter) ||
                const DeepCollectionEquality()
                    .equals(other.asserter, asserter)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.clinical_status, clinical_status) ||
                const DeepCollectionEquality()
                    .equals(other.clinical_status, clinical_status)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.criticality, criticality) ||
                const DeepCollectionEquality()
                    .equals(other.criticality, criticality)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.last_date, last_date) ||
                const DeepCollectionEquality()
                    .equals(other.last_date, last_date)) &&
            (identical(other.manifestation, manifestation) ||
                const DeepCollectionEquality()
                    .equals(other.manifestation, manifestation)) &&
            (identical(other.onset, onset) ||
                const DeepCollectionEquality().equals(other.onset, onset)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.recorder, recorder) ||
                const DeepCollectionEquality()
                    .equals(other.recorder, recorder)) &&
            (identical(other.route, route) ||
                const DeepCollectionEquality().equals(other.route, route)) &&
            (identical(other.severity, severity) ||
                const DeepCollectionEquality()
                    .equals(other.severity, severity)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.verification_status, verification_status) ||
                const DeepCollectionEquality()
                    .equals(other.verification_status, verification_status)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(asserter) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(clinical_status) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(criticality) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(last_date) ^
      const DeepCollectionEquality().hash(manifestation) ^
      const DeepCollectionEquality().hash(onset) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(recorder) ^
      const DeepCollectionEquality().hash(route) ^
      const DeepCollectionEquality().hash(severity) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(verification_status);

  @override
  _$AllergyIntoleranceSearchCopyWith<_AllergyIntoleranceSearch> get copyWith =>
      __$AllergyIntoleranceSearchCopyWithImpl<_AllergyIntoleranceSearch>(
          this, _$identity);
}

abstract class _AllergyIntoleranceSearch extends AllergyIntoleranceSearch {
  _AllergyIntoleranceSearch._() : super._();
  factory _AllergyIntoleranceSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<String> asserter,
      List<SearchToken> category,
      List<SearchToken> clinical_status,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchDate> last_date,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<String> patient,
      List<String> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      List<SearchToken> verification_status}) = _$_AllergyIntoleranceSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<String> get asserter;
  @override
  List<SearchToken> get category;
  @override
  List<SearchToken> get clinical_status;
  @override
  List<SearchToken> get code;
  @override
  List<SearchToken> get criticality;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchDate> get last_date;
  @override
  List<SearchToken> get manifestation;
  @override
  List<SearchDate> get onset;
  @override
  List<String> get patient;
  @override
  List<String> get recorder;
  @override
  List<SearchToken> get route;
  @override
  List<SearchToken> get severity;
  @override
  List<SearchToken> get type;
  @override
  List<SearchToken> get verification_status;
  @override
  _$AllergyIntoleranceSearchCopyWith<_AllergyIntoleranceSearch> get copyWith;
}

/// @nodoc
class _$ConditionSearchTearOff {
  const _$ConditionSearchTearOff();

// ignore: unused_element
  _ConditionSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> abatement_age,
      List<SearchDate> abatement_date,
      List<SearchString> abatement_string,
      List<String> asserter,
      List<SearchToken> body_site,
      List<SearchToken> category,
      List<SearchToken> clinical_status,
      List<String> encounter,
      List<SearchToken> evidence,
      List<String> evidence_detail,
      List<String> onset_age,
      List<SearchDate> onset_date,
      List<SearchString> onset_info,
      List<SearchDate> recorded_date,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<String> subject,
      List<SearchToken> verification_status}) {
    return _ConditionSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      code: code,
      identifier: identifier,
      patient: patient,
      abatement_age: abatement_age,
      abatement_date: abatement_date,
      abatement_string: abatement_string,
      asserter: asserter,
      body_site: body_site,
      category: category,
      clinical_status: clinical_status,
      encounter: encounter,
      evidence: evidence,
      evidence_detail: evidence_detail,
      onset_age: onset_age,
      onset_date: onset_date,
      onset_info: onset_info,
      recorded_date: recorded_date,
      severity: severity,
      stage: stage,
      subject: subject,
      verification_status: verification_status,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ConditionSearch = _$ConditionSearchTearOff();

/// @nodoc
mixin _$ConditionSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated; //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchToken> get identifier;
  List<String> get patient;
  List<String> get abatement_age;
  List<SearchDate> get abatement_date;
  List<SearchString> get abatement_string;
  List<String> get asserter;
  List<SearchToken> get body_site;
  List<SearchToken> get category;
  List<SearchToken> get clinical_status;
  List<String> get encounter;
  List<SearchToken> get evidence;
  List<String> get evidence_detail;
  List<String> get onset_age;
  List<SearchDate> get onset_date;
  List<SearchString> get onset_info;
  List<SearchDate> get recorded_date;
  List<SearchToken> get severity;
  List<SearchToken> get stage;
  List<String> get subject;
  List<SearchToken> get verification_status;

  $ConditionSearchCopyWith<ConditionSearch> get copyWith;
}

/// @nodoc
abstract class $ConditionSearchCopyWith<$Res> {
  factory $ConditionSearchCopyWith(
          ConditionSearch value, $Res Function(ConditionSearch) then) =
      _$ConditionSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> abatement_age,
      List<SearchDate> abatement_date,
      List<SearchString> abatement_string,
      List<String> asserter,
      List<SearchToken> body_site,
      List<SearchToken> category,
      List<SearchToken> clinical_status,
      List<String> encounter,
      List<SearchToken> evidence,
      List<String> evidence_detail,
      List<String> onset_age,
      List<SearchDate> onset_date,
      List<SearchString> onset_info,
      List<SearchDate> recorded_date,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<String> subject,
      List<SearchToken> verification_status});
}

/// @nodoc
class _$ConditionSearchCopyWithImpl<$Res>
    implements $ConditionSearchCopyWith<$Res> {
  _$ConditionSearchCopyWithImpl(this._value, this._then);

  final ConditionSearch _value;
  // ignore: unused_field
  final $Res Function(ConditionSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object code = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object abatement_age = freezed,
    Object abatement_date = freezed,
    Object abatement_string = freezed,
    Object asserter = freezed,
    Object body_site = freezed,
    Object category = freezed,
    Object clinical_status = freezed,
    Object encounter = freezed,
    Object evidence = freezed,
    Object evidence_detail = freezed,
    Object onset_age = freezed,
    Object onset_date = freezed,
    Object onset_info = freezed,
    Object recorded_date = freezed,
    Object severity = freezed,
    Object stage = freezed,
    Object subject = freezed,
    Object verification_status = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      abatement_age: abatement_age == freezed
          ? _value.abatement_age
          : abatement_age as List<String>,
      abatement_date: abatement_date == freezed
          ? _value.abatement_date
          : abatement_date as List<SearchDate>,
      abatement_string: abatement_string == freezed
          ? _value.abatement_string
          : abatement_string as List<SearchString>,
      asserter:
          asserter == freezed ? _value.asserter : asserter as List<String>,
      body_site: body_site == freezed
          ? _value.body_site
          : body_site as List<SearchToken>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinical_status: clinical_status == freezed
          ? _value.clinical_status
          : clinical_status as List<SearchToken>,
      encounter:
          encounter == freezed ? _value.encounter : encounter as List<String>,
      evidence:
          evidence == freezed ? _value.evidence : evidence as List<SearchToken>,
      evidence_detail: evidence_detail == freezed
          ? _value.evidence_detail
          : evidence_detail as List<String>,
      onset_age:
          onset_age == freezed ? _value.onset_age : onset_age as List<String>,
      onset_date: onset_date == freezed
          ? _value.onset_date
          : onset_date as List<SearchDate>,
      onset_info: onset_info == freezed
          ? _value.onset_info
          : onset_info as List<SearchString>,
      recorded_date: recorded_date == freezed
          ? _value.recorded_date
          : recorded_date as List<SearchDate>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      stage: stage == freezed ? _value.stage : stage as List<SearchToken>,
      subject: subject == freezed ? _value.subject : subject as List<String>,
      verification_status: verification_status == freezed
          ? _value.verification_status
          : verification_status as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$ConditionSearchCopyWith<$Res>
    implements $ConditionSearchCopyWith<$Res> {
  factory _$ConditionSearchCopyWith(
          _ConditionSearch value, $Res Function(_ConditionSearch) then) =
      __$ConditionSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> abatement_age,
      List<SearchDate> abatement_date,
      List<SearchString> abatement_string,
      List<String> asserter,
      List<SearchToken> body_site,
      List<SearchToken> category,
      List<SearchToken> clinical_status,
      List<String> encounter,
      List<SearchToken> evidence,
      List<String> evidence_detail,
      List<String> onset_age,
      List<SearchDate> onset_date,
      List<SearchString> onset_info,
      List<SearchDate> recorded_date,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<String> subject,
      List<SearchToken> verification_status});
}

/// @nodoc
class __$ConditionSearchCopyWithImpl<$Res>
    extends _$ConditionSearchCopyWithImpl<$Res>
    implements _$ConditionSearchCopyWith<$Res> {
  __$ConditionSearchCopyWithImpl(
      _ConditionSearch _value, $Res Function(_ConditionSearch) _then)
      : super(_value, (v) => _then(v as _ConditionSearch));

  @override
  _ConditionSearch get _value => super._value as _ConditionSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object code = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object abatement_age = freezed,
    Object abatement_date = freezed,
    Object abatement_string = freezed,
    Object asserter = freezed,
    Object body_site = freezed,
    Object category = freezed,
    Object clinical_status = freezed,
    Object encounter = freezed,
    Object evidence = freezed,
    Object evidence_detail = freezed,
    Object onset_age = freezed,
    Object onset_date = freezed,
    Object onset_info = freezed,
    Object recorded_date = freezed,
    Object severity = freezed,
    Object stage = freezed,
    Object subject = freezed,
    Object verification_status = freezed,
  }) {
    return _then(_ConditionSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      abatement_age: abatement_age == freezed
          ? _value.abatement_age
          : abatement_age as List<String>,
      abatement_date: abatement_date == freezed
          ? _value.abatement_date
          : abatement_date as List<SearchDate>,
      abatement_string: abatement_string == freezed
          ? _value.abatement_string
          : abatement_string as List<SearchString>,
      asserter:
          asserter == freezed ? _value.asserter : asserter as List<String>,
      body_site: body_site == freezed
          ? _value.body_site
          : body_site as List<SearchToken>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinical_status: clinical_status == freezed
          ? _value.clinical_status
          : clinical_status as List<SearchToken>,
      encounter:
          encounter == freezed ? _value.encounter : encounter as List<String>,
      evidence:
          evidence == freezed ? _value.evidence : evidence as List<SearchToken>,
      evidence_detail: evidence_detail == freezed
          ? _value.evidence_detail
          : evidence_detail as List<String>,
      onset_age:
          onset_age == freezed ? _value.onset_age : onset_age as List<String>,
      onset_date: onset_date == freezed
          ? _value.onset_date
          : onset_date as List<SearchDate>,
      onset_info: onset_info == freezed
          ? _value.onset_info
          : onset_info as List<SearchString>,
      recorded_date: recorded_date == freezed
          ? _value.recorded_date
          : recorded_date as List<SearchDate>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      stage: stage == freezed ? _value.stage : stage as List<SearchToken>,
      subject: subject == freezed ? _value.subject : subject as List<String>,
      verification_status: verification_status == freezed
          ? _value.verification_status
          : verification_status as List<SearchToken>,
    ));
  }
}

/// @nodoc
class _$_ConditionSearch extends _ConditionSearch {
  _$_ConditionSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.code,
      this.identifier,
      this.patient,
      this.abatement_age,
      this.abatement_date,
      this.abatement_string,
      this.asserter,
      this.body_site,
      this.category,
      this.clinical_status,
      this.encounter,
      this.evidence,
      this.evidence_detail,
      this.onset_age,
      this.onset_date,
      this.onset_info,
      this.recorded_date,
      this.severity,
      this.stage,
      this.subject,
      this.verification_status})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchToken> identifier;
  @override
  final List<String> patient;
  @override
  final List<String> abatement_age;
  @override
  final List<SearchDate> abatement_date;
  @override
  final List<SearchString> abatement_string;
  @override
  final List<String> asserter;
  @override
  final List<SearchToken> body_site;
  @override
  final List<SearchToken> category;
  @override
  final List<SearchToken> clinical_status;
  @override
  final List<String> encounter;
  @override
  final List<SearchToken> evidence;
  @override
  final List<String> evidence_detail;
  @override
  final List<String> onset_age;
  @override
  final List<SearchDate> onset_date;
  @override
  final List<SearchString> onset_info;
  @override
  final List<SearchDate> recorded_date;
  @override
  final List<SearchToken> severity;
  @override
  final List<SearchToken> stage;
  @override
  final List<String> subject;
  @override
  final List<SearchToken> verification_status;

  @override
  String toString() {
    return 'ConditionSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, code: $code, identifier: $identifier, patient: $patient, abatement_age: $abatement_age, abatement_date: $abatement_date, abatement_string: $abatement_string, asserter: $asserter, body_site: $body_site, category: $category, clinical_status: $clinical_status, encounter: $encounter, evidence: $evidence, evidence_detail: $evidence_detail, onset_age: $onset_age, onset_date: $onset_date, onset_info: $onset_info, recorded_date: $recorded_date, severity: $severity, stage: $stage, subject: $subject, verification_status: $verification_status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ConditionSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.abatement_age, abatement_age) ||
                const DeepCollectionEquality()
                    .equals(other.abatement_age, abatement_age)) &&
            (identical(other.abatement_date, abatement_date) ||
                const DeepCollectionEquality()
                    .equals(other.abatement_date, abatement_date)) &&
            (identical(other.abatement_string, abatement_string) ||
                const DeepCollectionEquality()
                    .equals(other.abatement_string, abatement_string)) &&
            (identical(other.asserter, asserter) ||
                const DeepCollectionEquality()
                    .equals(other.asserter, asserter)) &&
            (identical(other.body_site, body_site) ||
                const DeepCollectionEquality()
                    .equals(other.body_site, body_site)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.clinical_status, clinical_status) ||
                const DeepCollectionEquality()
                    .equals(other.clinical_status, clinical_status)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.evidence, evidence) ||
                const DeepCollectionEquality()
                    .equals(other.evidence, evidence)) &&
            (identical(other.evidence_detail, evidence_detail) ||
                const DeepCollectionEquality()
                    .equals(other.evidence_detail, evidence_detail)) &&
            (identical(other.onset_age, onset_age) ||
                const DeepCollectionEquality()
                    .equals(other.onset_age, onset_age)) &&
            (identical(other.onset_date, onset_date) ||
                const DeepCollectionEquality()
                    .equals(other.onset_date, onset_date)) &&
            (identical(other.onset_info, onset_info) ||
                const DeepCollectionEquality()
                    .equals(other.onset_info, onset_info)) &&
            (identical(other.recorded_date, recorded_date) ||
                const DeepCollectionEquality()
                    .equals(other.recorded_date, recorded_date)) &&
            (identical(other.severity, severity) ||
                const DeepCollectionEquality()
                    .equals(other.severity, severity)) &&
            (identical(other.stage, stage) ||
                const DeepCollectionEquality().equals(other.stage, stage)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.verification_status, verification_status) ||
                const DeepCollectionEquality().equals(other.verification_status, verification_status)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(abatement_age) ^
      const DeepCollectionEquality().hash(abatement_date) ^
      const DeepCollectionEquality().hash(abatement_string) ^
      const DeepCollectionEquality().hash(asserter) ^
      const DeepCollectionEquality().hash(body_site) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(clinical_status) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(evidence) ^
      const DeepCollectionEquality().hash(evidence_detail) ^
      const DeepCollectionEquality().hash(onset_age) ^
      const DeepCollectionEquality().hash(onset_date) ^
      const DeepCollectionEquality().hash(onset_info) ^
      const DeepCollectionEquality().hash(recorded_date) ^
      const DeepCollectionEquality().hash(severity) ^
      const DeepCollectionEquality().hash(stage) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(verification_status);

  @override
  _$ConditionSearchCopyWith<_ConditionSearch> get copyWith =>
      __$ConditionSearchCopyWithImpl<_ConditionSearch>(this, _$identity);
}

abstract class _ConditionSearch extends ConditionSearch {
  _ConditionSearch._() : super._();
  factory _ConditionSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> abatement_age,
      List<SearchDate> abatement_date,
      List<SearchString> abatement_string,
      List<String> asserter,
      List<SearchToken> body_site,
      List<SearchToken> category,
      List<SearchToken> clinical_status,
      List<String> encounter,
      List<SearchToken> evidence,
      List<String> evidence_detail,
      List<String> onset_age,
      List<SearchDate> onset_date,
      List<SearchString> onset_info,
      List<SearchDate> recorded_date,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<String> subject,
      List<SearchToken> verification_status}) = _$_ConditionSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchToken> get identifier;
  @override
  List<String> get patient;
  @override
  List<String> get abatement_age;
  @override
  List<SearchDate> get abatement_date;
  @override
  List<SearchString> get abatement_string;
  @override
  List<String> get asserter;
  @override
  List<SearchToken> get body_site;
  @override
  List<SearchToken> get category;
  @override
  List<SearchToken> get clinical_status;
  @override
  List<String> get encounter;
  @override
  List<SearchToken> get evidence;
  @override
  List<String> get evidence_detail;
  @override
  List<String> get onset_age;
  @override
  List<SearchDate> get onset_date;
  @override
  List<SearchString> get onset_info;
  @override
  List<SearchDate> get recorded_date;
  @override
  List<SearchToken> get severity;
  @override
  List<SearchToken> get stage;
  @override
  List<String> get subject;
  @override
  List<SearchToken> get verification_status;
  @override
  _$ConditionSearchCopyWith<_ConditionSearch> get copyWith;
}

/// @nodoc
class _$FamilyMemberHistorySearchTearOff {
  const _$FamilyMemberHistorySearchTearOff();

// ignore: unused_element
  _FamilyMemberHistorySearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> instantiates_canonical,
      List<SearchUri> instantiates_uri,
      List<SearchToken> relationship,
      List<SearchToken> sex,
      List<SearchToken> status}) {
    return _FamilyMemberHistorySearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      code: code,
      date: date,
      identifier: identifier,
      patient: patient,
      instantiates_canonical: instantiates_canonical,
      instantiates_uri: instantiates_uri,
      relationship: relationship,
      sex: sex,
      status: status,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $FamilyMemberHistorySearch = _$FamilyMemberHistorySearchTearOff();

/// @nodoc
mixin _$FamilyMemberHistorySearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated; //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<String> get patient;
  List<String> get instantiates_canonical;
  List<SearchUri> get instantiates_uri;
  List<SearchToken> get relationship;
  List<SearchToken> get sex;
  List<SearchToken> get status;

  $FamilyMemberHistorySearchCopyWith<FamilyMemberHistorySearch> get copyWith;
}

/// @nodoc
abstract class $FamilyMemberHistorySearchCopyWith<$Res> {
  factory $FamilyMemberHistorySearchCopyWith(FamilyMemberHistorySearch value,
          $Res Function(FamilyMemberHistorySearch) then) =
      _$FamilyMemberHistorySearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> instantiates_canonical,
      List<SearchUri> instantiates_uri,
      List<SearchToken> relationship,
      List<SearchToken> sex,
      List<SearchToken> status});
}

/// @nodoc
class _$FamilyMemberHistorySearchCopyWithImpl<$Res>
    implements $FamilyMemberHistorySearchCopyWith<$Res> {
  _$FamilyMemberHistorySearchCopyWithImpl(this._value, this._then);

  final FamilyMemberHistorySearch _value;
  // ignore: unused_field
  final $Res Function(FamilyMemberHistorySearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object instantiates_canonical = freezed,
    Object instantiates_uri = freezed,
    Object relationship = freezed,
    Object sex = freezed,
    Object status = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      instantiates_canonical: instantiates_canonical == freezed
          ? _value.instantiates_canonical
          : instantiates_canonical as List<String>,
      instantiates_uri: instantiates_uri == freezed
          ? _value.instantiates_uri
          : instantiates_uri as List<SearchUri>,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as List<SearchToken>,
      sex: sex == freezed ? _value.sex : sex as List<SearchToken>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$FamilyMemberHistorySearchCopyWith<$Res>
    implements $FamilyMemberHistorySearchCopyWith<$Res> {
  factory _$FamilyMemberHistorySearchCopyWith(_FamilyMemberHistorySearch value,
          $Res Function(_FamilyMemberHistorySearch) then) =
      __$FamilyMemberHistorySearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> instantiates_canonical,
      List<SearchUri> instantiates_uri,
      List<SearchToken> relationship,
      List<SearchToken> sex,
      List<SearchToken> status});
}

/// @nodoc
class __$FamilyMemberHistorySearchCopyWithImpl<$Res>
    extends _$FamilyMemberHistorySearchCopyWithImpl<$Res>
    implements _$FamilyMemberHistorySearchCopyWith<$Res> {
  __$FamilyMemberHistorySearchCopyWithImpl(_FamilyMemberHistorySearch _value,
      $Res Function(_FamilyMemberHistorySearch) _then)
      : super(_value, (v) => _then(v as _FamilyMemberHistorySearch));

  @override
  _FamilyMemberHistorySearch get _value =>
      super._value as _FamilyMemberHistorySearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object instantiates_canonical = freezed,
    Object instantiates_uri = freezed,
    Object relationship = freezed,
    Object sex = freezed,
    Object status = freezed,
  }) {
    return _then(_FamilyMemberHistorySearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      instantiates_canonical: instantiates_canonical == freezed
          ? _value.instantiates_canonical
          : instantiates_canonical as List<String>,
      instantiates_uri: instantiates_uri == freezed
          ? _value.instantiates_uri
          : instantiates_uri as List<SearchUri>,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as List<SearchToken>,
      sex: sex == freezed ? _value.sex : sex as List<SearchToken>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
    ));
  }
}

/// @nodoc
class _$_FamilyMemberHistorySearch extends _FamilyMemberHistorySearch {
  _$_FamilyMemberHistorySearch(
      {this.searchId,
      this.searchLastUpdated,
      this.code,
      this.date,
      this.identifier,
      this.patient,
      this.instantiates_canonical,
      this.instantiates_uri,
      this.relationship,
      this.sex,
      this.status})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<String> patient;
  @override
  final List<String> instantiates_canonical;
  @override
  final List<SearchUri> instantiates_uri;
  @override
  final List<SearchToken> relationship;
  @override
  final List<SearchToken> sex;
  @override
  final List<SearchToken> status;

  @override
  String toString() {
    return 'FamilyMemberHistorySearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, code: $code, date: $date, identifier: $identifier, patient: $patient, instantiates_canonical: $instantiates_canonical, instantiates_uri: $instantiates_uri, relationship: $relationship, sex: $sex, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _FamilyMemberHistorySearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.instantiates_canonical, instantiates_canonical) ||
                const DeepCollectionEquality().equals(
                    other.instantiates_canonical, instantiates_canonical)) &&
            (identical(other.instantiates_uri, instantiates_uri) ||
                const DeepCollectionEquality()
                    .equals(other.instantiates_uri, instantiates_uri)) &&
            (identical(other.relationship, relationship) ||
                const DeepCollectionEquality()
                    .equals(other.relationship, relationship)) &&
            (identical(other.sex, sex) ||
                const DeepCollectionEquality().equals(other.sex, sex)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(instantiates_canonical) ^
      const DeepCollectionEquality().hash(instantiates_uri) ^
      const DeepCollectionEquality().hash(relationship) ^
      const DeepCollectionEquality().hash(sex) ^
      const DeepCollectionEquality().hash(status);

  @override
  _$FamilyMemberHistorySearchCopyWith<_FamilyMemberHistorySearch>
      get copyWith =>
          __$FamilyMemberHistorySearchCopyWithImpl<_FamilyMemberHistorySearch>(
              this, _$identity);
}

abstract class _FamilyMemberHistorySearch extends FamilyMemberHistorySearch {
  _FamilyMemberHistorySearch._() : super._();
  factory _FamilyMemberHistorySearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> instantiates_canonical,
      List<SearchUri> instantiates_uri,
      List<SearchToken> relationship,
      List<SearchToken> sex,
      List<SearchToken> status}) = _$_FamilyMemberHistorySearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<String> get patient;
  @override
  List<String> get instantiates_canonical;
  @override
  List<SearchUri> get instantiates_uri;
  @override
  List<SearchToken> get relationship;
  @override
  List<SearchToken> get sex;
  @override
  List<SearchToken> get status;
  @override
  _$FamilyMemberHistorySearchCopyWith<_FamilyMemberHistorySearch> get copyWith;
}

/// @nodoc
class _$ProcedureSearchTearOff {
  const _$ProcedureSearchTearOff();

// ignore: unused_element
  _ProcedureSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> encounter,
      List<String> based_on,
      List<SearchToken> category,
      List<String> instantiates_canonical,
      List<SearchUri> instantiates_uri,
      List<String> location,
      List<String> part_of,
      List<String> performer,
      List<SearchToken> reason_code,
      List<String> reason_reference,
      List<SearchToken> status,
      List<String> subject}) {
    return _ProcedureSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      code: code,
      date: date,
      identifier: identifier,
      patient: patient,
      encounter: encounter,
      based_on: based_on,
      category: category,
      instantiates_canonical: instantiates_canonical,
      instantiates_uri: instantiates_uri,
      location: location,
      part_of: part_of,
      performer: performer,
      reason_code: reason_code,
      reason_reference: reason_reference,
      status: status,
      subject: subject,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ProcedureSearch = _$ProcedureSearchTearOff();

/// @nodoc
mixin _$ProcedureSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated; //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<String> get patient;
  List<String> get encounter;
  List<String> get based_on;
  List<SearchToken> get category;
  List<String> get instantiates_canonical;
  List<SearchUri> get instantiates_uri;
  List<String> get location;
  List<String> get part_of;
  List<String> get performer;
  List<SearchToken> get reason_code;
  List<String> get reason_reference;
  List<SearchToken> get status;
  List<String> get subject;

  $ProcedureSearchCopyWith<ProcedureSearch> get copyWith;
}

/// @nodoc
abstract class $ProcedureSearchCopyWith<$Res> {
  factory $ProcedureSearchCopyWith(
          ProcedureSearch value, $Res Function(ProcedureSearch) then) =
      _$ProcedureSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> encounter,
      List<String> based_on,
      List<SearchToken> category,
      List<String> instantiates_canonical,
      List<SearchUri> instantiates_uri,
      List<String> location,
      List<String> part_of,
      List<String> performer,
      List<SearchToken> reason_code,
      List<String> reason_reference,
      List<SearchToken> status,
      List<String> subject});
}

/// @nodoc
class _$ProcedureSearchCopyWithImpl<$Res>
    implements $ProcedureSearchCopyWith<$Res> {
  _$ProcedureSearchCopyWithImpl(this._value, this._then);

  final ProcedureSearch _value;
  // ignore: unused_field
  final $Res Function(ProcedureSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object encounter = freezed,
    Object based_on = freezed,
    Object category = freezed,
    Object instantiates_canonical = freezed,
    Object instantiates_uri = freezed,
    Object location = freezed,
    Object part_of = freezed,
    Object performer = freezed,
    Object reason_code = freezed,
    Object reason_reference = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      encounter:
          encounter == freezed ? _value.encounter : encounter as List<String>,
      based_on:
          based_on == freezed ? _value.based_on : based_on as List<String>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      instantiates_canonical: instantiates_canonical == freezed
          ? _value.instantiates_canonical
          : instantiates_canonical as List<String>,
      instantiates_uri: instantiates_uri == freezed
          ? _value.instantiates_uri
          : instantiates_uri as List<SearchUri>,
      location:
          location == freezed ? _value.location : location as List<String>,
      part_of: part_of == freezed ? _value.part_of : part_of as List<String>,
      performer:
          performer == freezed ? _value.performer : performer as List<String>,
      reason_code: reason_code == freezed
          ? _value.reason_code
          : reason_code as List<SearchToken>,
      reason_reference: reason_reference == freezed
          ? _value.reason_reference
          : reason_reference as List<String>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed ? _value.subject : subject as List<String>,
    ));
  }
}

/// @nodoc
abstract class _$ProcedureSearchCopyWith<$Res>
    implements $ProcedureSearchCopyWith<$Res> {
  factory _$ProcedureSearchCopyWith(
          _ProcedureSearch value, $Res Function(_ProcedureSearch) then) =
      __$ProcedureSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> encounter,
      List<String> based_on,
      List<SearchToken> category,
      List<String> instantiates_canonical,
      List<SearchUri> instantiates_uri,
      List<String> location,
      List<String> part_of,
      List<String> performer,
      List<SearchToken> reason_code,
      List<String> reason_reference,
      List<SearchToken> status,
      List<String> subject});
}

/// @nodoc
class __$ProcedureSearchCopyWithImpl<$Res>
    extends _$ProcedureSearchCopyWithImpl<$Res>
    implements _$ProcedureSearchCopyWith<$Res> {
  __$ProcedureSearchCopyWithImpl(
      _ProcedureSearch _value, $Res Function(_ProcedureSearch) _then)
      : super(_value, (v) => _then(v as _ProcedureSearch));

  @override
  _ProcedureSearch get _value => super._value as _ProcedureSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object encounter = freezed,
    Object based_on = freezed,
    Object category = freezed,
    Object instantiates_canonical = freezed,
    Object instantiates_uri = freezed,
    Object location = freezed,
    Object part_of = freezed,
    Object performer = freezed,
    Object reason_code = freezed,
    Object reason_reference = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_ProcedureSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      encounter:
          encounter == freezed ? _value.encounter : encounter as List<String>,
      based_on:
          based_on == freezed ? _value.based_on : based_on as List<String>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      instantiates_canonical: instantiates_canonical == freezed
          ? _value.instantiates_canonical
          : instantiates_canonical as List<String>,
      instantiates_uri: instantiates_uri == freezed
          ? _value.instantiates_uri
          : instantiates_uri as List<SearchUri>,
      location:
          location == freezed ? _value.location : location as List<String>,
      part_of: part_of == freezed ? _value.part_of : part_of as List<String>,
      performer:
          performer == freezed ? _value.performer : performer as List<String>,
      reason_code: reason_code == freezed
          ? _value.reason_code
          : reason_code as List<SearchToken>,
      reason_reference: reason_reference == freezed
          ? _value.reason_reference
          : reason_reference as List<String>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed ? _value.subject : subject as List<String>,
    ));
  }
}

/// @nodoc
class _$_ProcedureSearch extends _ProcedureSearch {
  _$_ProcedureSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.code,
      this.date,
      this.identifier,
      this.patient,
      this.encounter,
      this.based_on,
      this.category,
      this.instantiates_canonical,
      this.instantiates_uri,
      this.location,
      this.part_of,
      this.performer,
      this.reason_code,
      this.reason_reference,
      this.status,
      this.subject})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<String> patient;
  @override
  final List<String> encounter;
  @override
  final List<String> based_on;
  @override
  final List<SearchToken> category;
  @override
  final List<String> instantiates_canonical;
  @override
  final List<SearchUri> instantiates_uri;
  @override
  final List<String> location;
  @override
  final List<String> part_of;
  @override
  final List<String> performer;
  @override
  final List<SearchToken> reason_code;
  @override
  final List<String> reason_reference;
  @override
  final List<SearchToken> status;
  @override
  final List<String> subject;

  @override
  String toString() {
    return 'ProcedureSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, code: $code, date: $date, identifier: $identifier, patient: $patient, encounter: $encounter, based_on: $based_on, category: $category, instantiates_canonical: $instantiates_canonical, instantiates_uri: $instantiates_uri, location: $location, part_of: $part_of, performer: $performer, reason_code: $reason_code, reason_reference: $reason_reference, status: $status, subject: $subject)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ProcedureSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.based_on, based_on) ||
                const DeepCollectionEquality()
                    .equals(other.based_on, based_on)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.instantiates_canonical, instantiates_canonical) ||
                const DeepCollectionEquality().equals(
                    other.instantiates_canonical, instantiates_canonical)) &&
            (identical(other.instantiates_uri, instantiates_uri) ||
                const DeepCollectionEquality()
                    .equals(other.instantiates_uri, instantiates_uri)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.part_of, part_of) ||
                const DeepCollectionEquality()
                    .equals(other.part_of, part_of)) &&
            (identical(other.performer, performer) ||
                const DeepCollectionEquality()
                    .equals(other.performer, performer)) &&
            (identical(other.reason_code, reason_code) ||
                const DeepCollectionEquality()
                    .equals(other.reason_code, reason_code)) &&
            (identical(other.reason_reference, reason_reference) ||
                const DeepCollectionEquality()
                    .equals(other.reason_reference, reason_reference)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality().equals(other.subject, subject)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(based_on) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(instantiates_canonical) ^
      const DeepCollectionEquality().hash(instantiates_uri) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(part_of) ^
      const DeepCollectionEquality().hash(performer) ^
      const DeepCollectionEquality().hash(reason_code) ^
      const DeepCollectionEquality().hash(reason_reference) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject);

  @override
  _$ProcedureSearchCopyWith<_ProcedureSearch> get copyWith =>
      __$ProcedureSearchCopyWithImpl<_ProcedureSearch>(this, _$identity);
}

abstract class _ProcedureSearch extends ProcedureSearch {
  _ProcedureSearch._() : super._();
  factory _ProcedureSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> encounter,
      List<String> based_on,
      List<SearchToken> category,
      List<String> instantiates_canonical,
      List<SearchUri> instantiates_uri,
      List<String> location,
      List<String> part_of,
      List<String> performer,
      List<SearchToken> reason_code,
      List<String> reason_reference,
      List<SearchToken> status,
      List<String> subject}) = _$_ProcedureSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<String> get patient;
  @override
  List<String> get encounter;
  @override
  List<String> get based_on;
  @override
  List<SearchToken> get category;
  @override
  List<String> get instantiates_canonical;
  @override
  List<SearchUri> get instantiates_uri;
  @override
  List<String> get location;
  @override
  List<String> get part_of;
  @override
  List<String> get performer;
  @override
  List<SearchToken> get reason_code;
  @override
  List<String> get reason_reference;
  @override
  List<SearchToken> get status;
  @override
  List<String> get subject;
  @override
  _$ProcedureSearchCopyWith<_ProcedureSearch> get copyWith;
}

/// @nodoc
class _$ClinicalImpressionSearchTearOff {
  const _$ClinicalImpressionSearchTearOff();

// ignore: unused_element
  _ClinicalImpressionSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchDate> date,
      List<String> patient,
      List<String> assessor,
      List<String> encounter,
      List<SearchToken> finding_code,
      List<String> finding_ref,
      List<SearchToken> identifier,
      List<String> investigation,
      List<String> previous,
      List<String> problem,
      List<SearchToken> status,
      List<String> subject,
      List<String> supporting_info}) {
    return _ClinicalImpressionSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      date: date,
      patient: patient,
      assessor: assessor,
      encounter: encounter,
      finding_code: finding_code,
      finding_ref: finding_ref,
      identifier: identifier,
      investigation: investigation,
      previous: previous,
      problem: problem,
      status: status,
      subject: subject,
      supporting_info: supporting_info,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ClinicalImpressionSearch = _$ClinicalImpressionSearchTearOff();

/// @nodoc
mixin _$ClinicalImpressionSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated; //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchDate> get date;
  List<String> get patient;
  List<String> get assessor;
  List<String> get encounter;
  List<SearchToken> get finding_code;
  List<String> get finding_ref;
  List<SearchToken> get identifier;
  List<String> get investigation;
  List<String> get previous;
  List<String> get problem;
  List<SearchToken> get status;
  List<String> get subject;
  List<String> get supporting_info;

  $ClinicalImpressionSearchCopyWith<ClinicalImpressionSearch> get copyWith;
}

/// @nodoc
abstract class $ClinicalImpressionSearchCopyWith<$Res> {
  factory $ClinicalImpressionSearchCopyWith(ClinicalImpressionSearch value,
          $Res Function(ClinicalImpressionSearch) then) =
      _$ClinicalImpressionSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchDate> date,
      List<String> patient,
      List<String> assessor,
      List<String> encounter,
      List<SearchToken> finding_code,
      List<String> finding_ref,
      List<SearchToken> identifier,
      List<String> investigation,
      List<String> previous,
      List<String> problem,
      List<SearchToken> status,
      List<String> subject,
      List<String> supporting_info});
}

/// @nodoc
class _$ClinicalImpressionSearchCopyWithImpl<$Res>
    implements $ClinicalImpressionSearchCopyWith<$Res> {
  _$ClinicalImpressionSearchCopyWithImpl(this._value, this._then);

  final ClinicalImpressionSearch _value;
  // ignore: unused_field
  final $Res Function(ClinicalImpressionSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object date = freezed,
    Object patient = freezed,
    Object assessor = freezed,
    Object encounter = freezed,
    Object finding_code = freezed,
    Object finding_ref = freezed,
    Object identifier = freezed,
    Object investigation = freezed,
    Object previous = freezed,
    Object problem = freezed,
    Object status = freezed,
    Object subject = freezed,
    Object supporting_info = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      assessor:
          assessor == freezed ? _value.assessor : assessor as List<String>,
      encounter:
          encounter == freezed ? _value.encounter : encounter as List<String>,
      finding_code: finding_code == freezed
          ? _value.finding_code
          : finding_code as List<SearchToken>,
      finding_ref: finding_ref == freezed
          ? _value.finding_ref
          : finding_ref as List<String>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      investigation: investigation == freezed
          ? _value.investigation
          : investigation as List<String>,
      previous:
          previous == freezed ? _value.previous : previous as List<String>,
      problem: problem == freezed ? _value.problem : problem as List<String>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed ? _value.subject : subject as List<String>,
      supporting_info: supporting_info == freezed
          ? _value.supporting_info
          : supporting_info as List<String>,
    ));
  }
}

/// @nodoc
abstract class _$ClinicalImpressionSearchCopyWith<$Res>
    implements $ClinicalImpressionSearchCopyWith<$Res> {
  factory _$ClinicalImpressionSearchCopyWith(_ClinicalImpressionSearch value,
          $Res Function(_ClinicalImpressionSearch) then) =
      __$ClinicalImpressionSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchDate> date,
      List<String> patient,
      List<String> assessor,
      List<String> encounter,
      List<SearchToken> finding_code,
      List<String> finding_ref,
      List<SearchToken> identifier,
      List<String> investigation,
      List<String> previous,
      List<String> problem,
      List<SearchToken> status,
      List<String> subject,
      List<String> supporting_info});
}

/// @nodoc
class __$ClinicalImpressionSearchCopyWithImpl<$Res>
    extends _$ClinicalImpressionSearchCopyWithImpl<$Res>
    implements _$ClinicalImpressionSearchCopyWith<$Res> {
  __$ClinicalImpressionSearchCopyWithImpl(_ClinicalImpressionSearch _value,
      $Res Function(_ClinicalImpressionSearch) _then)
      : super(_value, (v) => _then(v as _ClinicalImpressionSearch));

  @override
  _ClinicalImpressionSearch get _value =>
      super._value as _ClinicalImpressionSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object date = freezed,
    Object patient = freezed,
    Object assessor = freezed,
    Object encounter = freezed,
    Object finding_code = freezed,
    Object finding_ref = freezed,
    Object identifier = freezed,
    Object investigation = freezed,
    Object previous = freezed,
    Object problem = freezed,
    Object status = freezed,
    Object subject = freezed,
    Object supporting_info = freezed,
  }) {
    return _then(_ClinicalImpressionSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      assessor:
          assessor == freezed ? _value.assessor : assessor as List<String>,
      encounter:
          encounter == freezed ? _value.encounter : encounter as List<String>,
      finding_code: finding_code == freezed
          ? _value.finding_code
          : finding_code as List<SearchToken>,
      finding_ref: finding_ref == freezed
          ? _value.finding_ref
          : finding_ref as List<String>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      investigation: investigation == freezed
          ? _value.investigation
          : investigation as List<String>,
      previous:
          previous == freezed ? _value.previous : previous as List<String>,
      problem: problem == freezed ? _value.problem : problem as List<String>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed ? _value.subject : subject as List<String>,
      supporting_info: supporting_info == freezed
          ? _value.supporting_info
          : supporting_info as List<String>,
    ));
  }
}

/// @nodoc
class _$_ClinicalImpressionSearch extends _ClinicalImpressionSearch {
  _$_ClinicalImpressionSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.date,
      this.patient,
      this.assessor,
      this.encounter,
      this.finding_code,
      this.finding_ref,
      this.identifier,
      this.investigation,
      this.previous,
      this.problem,
      this.status,
      this.subject,
      this.supporting_info})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchDate> date;
  @override
  final List<String> patient;
  @override
  final List<String> assessor;
  @override
  final List<String> encounter;
  @override
  final List<SearchToken> finding_code;
  @override
  final List<String> finding_ref;
  @override
  final List<SearchToken> identifier;
  @override
  final List<String> investigation;
  @override
  final List<String> previous;
  @override
  final List<String> problem;
  @override
  final List<SearchToken> status;
  @override
  final List<String> subject;
  @override
  final List<String> supporting_info;

  @override
  String toString() {
    return 'ClinicalImpressionSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, date: $date, patient: $patient, assessor: $assessor, encounter: $encounter, finding_code: $finding_code, finding_ref: $finding_ref, identifier: $identifier, investigation: $investigation, previous: $previous, problem: $problem, status: $status, subject: $subject, supporting_info: $supporting_info)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ClinicalImpressionSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.assessor, assessor) ||
                const DeepCollectionEquality()
                    .equals(other.assessor, assessor)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.finding_code, finding_code) ||
                const DeepCollectionEquality()
                    .equals(other.finding_code, finding_code)) &&
            (identical(other.finding_ref, finding_ref) ||
                const DeepCollectionEquality()
                    .equals(other.finding_ref, finding_ref)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.investigation, investigation) ||
                const DeepCollectionEquality()
                    .equals(other.investigation, investigation)) &&
            (identical(other.previous, previous) ||
                const DeepCollectionEquality()
                    .equals(other.previous, previous)) &&
            (identical(other.problem, problem) ||
                const DeepCollectionEquality()
                    .equals(other.problem, problem)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.supporting_info, supporting_info) ||
                const DeepCollectionEquality()
                    .equals(other.supporting_info, supporting_info)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(assessor) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(finding_code) ^
      const DeepCollectionEquality().hash(finding_ref) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(investigation) ^
      const DeepCollectionEquality().hash(previous) ^
      const DeepCollectionEquality().hash(problem) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(supporting_info);

  @override
  _$ClinicalImpressionSearchCopyWith<_ClinicalImpressionSearch> get copyWith =>
      __$ClinicalImpressionSearchCopyWithImpl<_ClinicalImpressionSearch>(
          this, _$identity);
}

abstract class _ClinicalImpressionSearch extends ClinicalImpressionSearch {
  _ClinicalImpressionSearch._() : super._();
  factory _ClinicalImpressionSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchDate> date,
      List<String> patient,
      List<String> assessor,
      List<String> encounter,
      List<SearchToken> finding_code,
      List<String> finding_ref,
      List<SearchToken> identifier,
      List<String> investigation,
      List<String> previous,
      List<String> problem,
      List<SearchToken> status,
      List<String> subject,
      List<String> supporting_info}) = _$_ClinicalImpressionSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchDate> get date;
  @override
  List<String> get patient;
  @override
  List<String> get assessor;
  @override
  List<String> get encounter;
  @override
  List<SearchToken> get finding_code;
  @override
  List<String> get finding_ref;
  @override
  List<SearchToken> get identifier;
  @override
  List<String> get investigation;
  @override
  List<String> get previous;
  @override
  List<String> get problem;
  @override
  List<SearchToken> get status;
  @override
  List<String> get subject;
  @override
  List<String> get supporting_info;
  @override
  _$ClinicalImpressionSearchCopyWith<_ClinicalImpressionSearch> get copyWith;
}

/// @nodoc
class _$DetectedIssueSearchTearOff {
  const _$DetectedIssueSearchTearOff();

// ignore: unused_element
  _DetectedIssueSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> author,
      List<SearchToken> code,
      List<SearchDate> identified,
      List<String> implicated}) {
    return _DetectedIssueSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      identifier: identifier,
      patient: patient,
      author: author,
      code: code,
      identified: identified,
      implicated: implicated,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $DetectedIssueSearch = _$DetectedIssueSearchTearOff();

/// @nodoc
mixin _$DetectedIssueSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated; //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get identifier;
  List<String> get patient;
  List<String> get author;
  List<SearchToken> get code;
  List<SearchDate> get identified;
  List<String> get implicated;

  $DetectedIssueSearchCopyWith<DetectedIssueSearch> get copyWith;
}

/// @nodoc
abstract class $DetectedIssueSearchCopyWith<$Res> {
  factory $DetectedIssueSearchCopyWith(
          DetectedIssueSearch value, $Res Function(DetectedIssueSearch) then) =
      _$DetectedIssueSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> author,
      List<SearchToken> code,
      List<SearchDate> identified,
      List<String> implicated});
}

/// @nodoc
class _$DetectedIssueSearchCopyWithImpl<$Res>
    implements $DetectedIssueSearchCopyWith<$Res> {
  _$DetectedIssueSearchCopyWithImpl(this._value, this._then);

  final DetectedIssueSearch _value;
  // ignore: unused_field
  final $Res Function(DetectedIssueSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object author = freezed,
    Object code = freezed,
    Object identified = freezed,
    Object implicated = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      author: author == freezed ? _value.author : author as List<String>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      identified: identified == freezed
          ? _value.identified
          : identified as List<SearchDate>,
      implicated: implicated == freezed
          ? _value.implicated
          : implicated as List<String>,
    ));
  }
}

/// @nodoc
abstract class _$DetectedIssueSearchCopyWith<$Res>
    implements $DetectedIssueSearchCopyWith<$Res> {
  factory _$DetectedIssueSearchCopyWith(_DetectedIssueSearch value,
          $Res Function(_DetectedIssueSearch) then) =
      __$DetectedIssueSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> author,
      List<SearchToken> code,
      List<SearchDate> identified,
      List<String> implicated});
}

/// @nodoc
class __$DetectedIssueSearchCopyWithImpl<$Res>
    extends _$DetectedIssueSearchCopyWithImpl<$Res>
    implements _$DetectedIssueSearchCopyWith<$Res> {
  __$DetectedIssueSearchCopyWithImpl(
      _DetectedIssueSearch _value, $Res Function(_DetectedIssueSearch) _then)
      : super(_value, (v) => _then(v as _DetectedIssueSearch));

  @override
  _DetectedIssueSearch get _value => super._value as _DetectedIssueSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object author = freezed,
    Object code = freezed,
    Object identified = freezed,
    Object implicated = freezed,
  }) {
    return _then(_DetectedIssueSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed ? _value.patient : patient as List<String>,
      author: author == freezed ? _value.author : author as List<String>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      identified: identified == freezed
          ? _value.identified
          : identified as List<SearchDate>,
      implicated: implicated == freezed
          ? _value.implicated
          : implicated as List<String>,
    ));
  }
}

/// @nodoc
class _$_DetectedIssueSearch extends _DetectedIssueSearch {
  _$_DetectedIssueSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.identifier,
      this.patient,
      this.author,
      this.code,
      this.identified,
      this.implicated})
      : super._();

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> identifier;
  @override
  final List<String> patient;
  @override
  final List<String> author;
  @override
  final List<SearchToken> code;
  @override
  final List<SearchDate> identified;
  @override
  final List<String> implicated;

  @override
  String toString() {
    return 'DetectedIssueSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, identifier: $identifier, patient: $patient, author: $author, code: $code, identified: $identified, implicated: $implicated)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DetectedIssueSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.identified, identified) ||
                const DeepCollectionEquality()
                    .equals(other.identified, identified)) &&
            (identical(other.implicated, implicated) ||
                const DeepCollectionEquality()
                    .equals(other.implicated, implicated)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(identified) ^
      const DeepCollectionEquality().hash(implicated);

  @override
  _$DetectedIssueSearchCopyWith<_DetectedIssueSearch> get copyWith =>
      __$DetectedIssueSearchCopyWithImpl<_DetectedIssueSearch>(
          this, _$identity);
}

abstract class _DetectedIssueSearch extends DetectedIssueSearch {
  _DetectedIssueSearch._() : super._();
  factory _DetectedIssueSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> identifier,
      List<String> patient,
      List<String> author,
      List<SearchToken> code,
      List<SearchDate> identified,
      List<String> implicated}) = _$_DetectedIssueSearch;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override //List<SearchToken> searchTag,
//List<SearchUri> searchProfile,
//List<SearchToken> searchSecurity,
//List<String> searchText,
//List<String> searchContent,
//List<SearchString> searchList,
// List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get identifier;
  @override
  List<String> get patient;
  @override
  List<String> get author;
  @override
  List<SearchToken> get code;
  @override
  List<SearchDate> get identified;
  @override
  List<String> get implicated;
  @override
  _$DetectedIssueSearchCopyWith<_DetectedIssueSearch> get copyWith;
}

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'information_tracking.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;
QuestionnaireSearch _$QuestionnaireSearchFromJson(Map<String, dynamic> json) {
  return _QuestionnaireSearch.fromJson(json);
}

/// @nodoc
class _$QuestionnaireSearchTearOff {
  const _$QuestionnaireSearchTearOff();

// ignore: unused_element
  _QuestionnaireSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchString> publisher,
      List<SearchToken> status,
      List<SearchString> title,
      List<SearchString> version}) {
    return _QuestionnaireSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      code: code,
      date: date,
      identifier: identifier,
      publisher: publisher,
      status: status,
      title: title,
      version: version,
    );
  }

// ignore: unused_element
  QuestionnaireSearch fromJson(Map<String, Object> json) {
    return QuestionnaireSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $QuestionnaireSearch = _$QuestionnaireSearchTearOff();

/// @nodoc
mixin _$QuestionnaireSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<SearchString> get publisher;
  List<SearchToken> get status;
  List<SearchString> get title;
  List<SearchString> get version;

  Map<String, dynamic> toJson();
  $QuestionnaireSearchCopyWith<QuestionnaireSearch> get copyWith;
}

/// @nodoc
abstract class $QuestionnaireSearchCopyWith<$Res> {
  factory $QuestionnaireSearchCopyWith(
          QuestionnaireSearch value, $Res Function(QuestionnaireSearch) then) =
      _$QuestionnaireSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchString> publisher,
      List<SearchToken> status,
      List<SearchString> title,
      List<SearchString> version});
}

/// @nodoc
class _$QuestionnaireSearchCopyWithImpl<$Res>
    implements $QuestionnaireSearchCopyWith<$Res> {
  _$QuestionnaireSearchCopyWithImpl(this._value, this._then);

  final QuestionnaireSearch _value;
  // ignore: unused_field
  final $Res Function(QuestionnaireSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object publisher = freezed,
    Object status = freezed,
    Object title = freezed,
    Object version = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      publisher: publisher == freezed
          ? _value.publisher
          : publisher as List<SearchString>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      title: title == freezed ? _value.title : title as List<SearchString>,
      version:
          version == freezed ? _value.version : version as List<SearchString>,
    ));
  }
}

/// @nodoc
abstract class _$QuestionnaireSearchCopyWith<$Res>
    implements $QuestionnaireSearchCopyWith<$Res> {
  factory _$QuestionnaireSearchCopyWith(_QuestionnaireSearch value,
          $Res Function(_QuestionnaireSearch) then) =
      __$QuestionnaireSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchString> publisher,
      List<SearchToken> status,
      List<SearchString> title,
      List<SearchString> version});
}

/// @nodoc
class __$QuestionnaireSearchCopyWithImpl<$Res>
    extends _$QuestionnaireSearchCopyWithImpl<$Res>
    implements _$QuestionnaireSearchCopyWith<$Res> {
  __$QuestionnaireSearchCopyWithImpl(
      _QuestionnaireSearch _value, $Res Function(_QuestionnaireSearch) _then)
      : super(_value, (v) => _then(v as _QuestionnaireSearch));

  @override
  _QuestionnaireSearch get _value => super._value as _QuestionnaireSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object publisher = freezed,
    Object status = freezed,
    Object title = freezed,
    Object version = freezed,
  }) {
    return _then(_QuestionnaireSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      publisher: publisher == freezed
          ? _value.publisher
          : publisher as List<SearchString>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      title: title == freezed ? _value.title : title as List<SearchString>,
      version:
          version == freezed ? _value.version : version as List<SearchString>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_QuestionnaireSearch extends _QuestionnaireSearch {
  _$_QuestionnaireSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.code,
      this.date,
      this.identifier,
      this.publisher,
      this.status,
      this.title,
      this.version})
      : super._();

  factory _$_QuestionnaireSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_QuestionnaireSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchString> publisher;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchString> title;
  @override
  final List<SearchString> version;

  @override
  String toString() {
    return 'QuestionnaireSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, code: $code, date: $date, identifier: $identifier, publisher: $publisher, status: $status, title: $title, version: $version)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _QuestionnaireSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(version);

  @override
  _$QuestionnaireSearchCopyWith<_QuestionnaireSearch> get copyWith =>
      __$QuestionnaireSearchCopyWithImpl<_QuestionnaireSearch>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_QuestionnaireSearchToJson(this);
  }
}

abstract class _QuestionnaireSearch extends QuestionnaireSearch {
  _QuestionnaireSearch._() : super._();
  factory _QuestionnaireSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchString> publisher,
      List<SearchToken> status,
      List<SearchString> title,
      List<SearchString> version}) = _$_QuestionnaireSearch;

  factory _QuestionnaireSearch.fromJson(Map<String, dynamic> json) =
      _$_QuestionnaireSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchString> get publisher;
  @override
  List<SearchToken> get status;
  @override
  List<SearchString> get title;
  @override
  List<SearchString> get version;
  @override
  _$QuestionnaireSearchCopyWith<_QuestionnaireSearch> get copyWith;
}

ProvenanceSearch _$ProvenanceSearchFromJson(Map<String, dynamic> json) {
  return _ProvenanceSearch.fromJson(json);
}

/// @nodoc
class _$ProvenanceSearchTearOff {
  const _$ProvenanceSearchTearOff();

// ignore: unused_element
  _ProvenanceSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> agent,
      List<SearchDate> end,
      List<SearchUri> entity,
      List<SearchToken> entitytype,
      List<SearchReference> location,
      List<SearchReference> patient,
      List<SearchToken> sigtype,
      List<SearchDate> start,
      List<SearchReference> target,
      List<SearchToken> userid}) {
    return _ProvenanceSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      agent: agent,
      end: end,
      entity: entity,
      entitytype: entitytype,
      location: location,
      patient: patient,
      sigtype: sigtype,
      start: start,
      target: target,
      userid: userid,
    );
  }

// ignore: unused_element
  ProvenanceSearch fromJson(Map<String, Object> json) {
    return ProvenanceSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $ProvenanceSearch = _$ProvenanceSearchTearOff();

/// @nodoc
mixin _$ProvenanceSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get agent;
  List<SearchDate> get end;
  List<SearchUri> get entity;
  List<SearchToken> get entitytype;
  List<SearchReference> get location;
  List<SearchReference> get patient;
  List<SearchToken> get sigtype;
  List<SearchDate> get start;
  List<SearchReference> get target;
  List<SearchToken> get userid;

  Map<String, dynamic> toJson();
  $ProvenanceSearchCopyWith<ProvenanceSearch> get copyWith;
}

/// @nodoc
abstract class $ProvenanceSearchCopyWith<$Res> {
  factory $ProvenanceSearchCopyWith(
          ProvenanceSearch value, $Res Function(ProvenanceSearch) then) =
      _$ProvenanceSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> agent,
      List<SearchDate> end,
      List<SearchUri> entity,
      List<SearchToken> entitytype,
      List<SearchReference> location,
      List<SearchReference> patient,
      List<SearchToken> sigtype,
      List<SearchDate> start,
      List<SearchReference> target,
      List<SearchToken> userid});
}

/// @nodoc
class _$ProvenanceSearchCopyWithImpl<$Res>
    implements $ProvenanceSearchCopyWith<$Res> {
  _$ProvenanceSearchCopyWithImpl(this._value, this._then);

  final ProvenanceSearch _value;
  // ignore: unused_field
  final $Res Function(ProvenanceSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object agent = freezed,
    Object end = freezed,
    Object entity = freezed,
    Object entitytype = freezed,
    Object location = freezed,
    Object patient = freezed,
    Object sigtype = freezed,
    Object start = freezed,
    Object target = freezed,
    Object userid = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      agent: agent == freezed ? _value.agent : agent as List<SearchReference>,
      end: end == freezed ? _value.end : end as List<SearchDate>,
      entity: entity == freezed ? _value.entity : entity as List<SearchUri>,
      entitytype: entitytype == freezed
          ? _value.entitytype
          : entitytype as List<SearchToken>,
      location: location == freezed
          ? _value.location
          : location as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      sigtype:
          sigtype == freezed ? _value.sigtype : sigtype as List<SearchToken>,
      start: start == freezed ? _value.start : start as List<SearchDate>,
      target:
          target == freezed ? _value.target : target as List<SearchReference>,
      userid: userid == freezed ? _value.userid : userid as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$ProvenanceSearchCopyWith<$Res>
    implements $ProvenanceSearchCopyWith<$Res> {
  factory _$ProvenanceSearchCopyWith(
          _ProvenanceSearch value, $Res Function(_ProvenanceSearch) then) =
      __$ProvenanceSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> agent,
      List<SearchDate> end,
      List<SearchUri> entity,
      List<SearchToken> entitytype,
      List<SearchReference> location,
      List<SearchReference> patient,
      List<SearchToken> sigtype,
      List<SearchDate> start,
      List<SearchReference> target,
      List<SearchToken> userid});
}

/// @nodoc
class __$ProvenanceSearchCopyWithImpl<$Res>
    extends _$ProvenanceSearchCopyWithImpl<$Res>
    implements _$ProvenanceSearchCopyWith<$Res> {
  __$ProvenanceSearchCopyWithImpl(
      _ProvenanceSearch _value, $Res Function(_ProvenanceSearch) _then)
      : super(_value, (v) => _then(v as _ProvenanceSearch));

  @override
  _ProvenanceSearch get _value => super._value as _ProvenanceSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object agent = freezed,
    Object end = freezed,
    Object entity = freezed,
    Object entitytype = freezed,
    Object location = freezed,
    Object patient = freezed,
    Object sigtype = freezed,
    Object start = freezed,
    Object target = freezed,
    Object userid = freezed,
  }) {
    return _then(_ProvenanceSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      agent: agent == freezed ? _value.agent : agent as List<SearchReference>,
      end: end == freezed ? _value.end : end as List<SearchDate>,
      entity: entity == freezed ? _value.entity : entity as List<SearchUri>,
      entitytype: entitytype == freezed
          ? _value.entitytype
          : entitytype as List<SearchToken>,
      location: location == freezed
          ? _value.location
          : location as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      sigtype:
          sigtype == freezed ? _value.sigtype : sigtype as List<SearchToken>,
      start: start == freezed ? _value.start : start as List<SearchDate>,
      target:
          target == freezed ? _value.target : target as List<SearchReference>,
      userid: userid == freezed ? _value.userid : userid as List<SearchToken>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_ProvenanceSearch extends _ProvenanceSearch {
  _$_ProvenanceSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.agent,
      this.end,
      this.entity,
      this.entitytype,
      this.location,
      this.patient,
      this.sigtype,
      this.start,
      this.target,
      this.userid})
      : super._();

  factory _$_ProvenanceSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_ProvenanceSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchReference> agent;
  @override
  final List<SearchDate> end;
  @override
  final List<SearchUri> entity;
  @override
  final List<SearchToken> entitytype;
  @override
  final List<SearchReference> location;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchToken> sigtype;
  @override
  final List<SearchDate> start;
  @override
  final List<SearchReference> target;
  @override
  final List<SearchToken> userid;

  @override
  String toString() {
    return 'ProvenanceSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, agent: $agent, end: $end, entity: $entity, entitytype: $entitytype, location: $location, patient: $patient, sigtype: $sigtype, start: $start, target: $target, userid: $userid)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ProvenanceSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.agent, agent) ||
                const DeepCollectionEquality().equals(other.agent, agent)) &&
            (identical(other.end, end) ||
                const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.entity, entity) ||
                const DeepCollectionEquality().equals(other.entity, entity)) &&
            (identical(other.entitytype, entitytype) ||
                const DeepCollectionEquality()
                    .equals(other.entitytype, entitytype)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.sigtype, sigtype) ||
                const DeepCollectionEquality()
                    .equals(other.sigtype, sigtype)) &&
            (identical(other.start, start) ||
                const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.target, target) ||
                const DeepCollectionEquality().equals(other.target, target)) &&
            (identical(other.userid, userid) ||
                const DeepCollectionEquality().equals(other.userid, userid)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(agent) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(entity) ^
      const DeepCollectionEquality().hash(entitytype) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(sigtype) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(target) ^
      const DeepCollectionEquality().hash(userid);

  @override
  _$ProvenanceSearchCopyWith<_ProvenanceSearch> get copyWith =>
      __$ProvenanceSearchCopyWithImpl<_ProvenanceSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ProvenanceSearchToJson(this);
  }
}

abstract class _ProvenanceSearch extends ProvenanceSearch {
  _ProvenanceSearch._() : super._();
  factory _ProvenanceSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> agent,
      List<SearchDate> end,
      List<SearchUri> entity,
      List<SearchToken> entitytype,
      List<SearchReference> location,
      List<SearchReference> patient,
      List<SearchToken> sigtype,
      List<SearchDate> start,
      List<SearchReference> target,
      List<SearchToken> userid}) = _$_ProvenanceSearch;

  factory _ProvenanceSearch.fromJson(Map<String, dynamic> json) =
      _$_ProvenanceSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get agent;
  @override
  List<SearchDate> get end;
  @override
  List<SearchUri> get entity;
  @override
  List<SearchToken> get entitytype;
  @override
  List<SearchReference> get location;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchToken> get sigtype;
  @override
  List<SearchDate> get start;
  @override
  List<SearchReference> get target;
  @override
  List<SearchToken> get userid;
  @override
  _$ProvenanceSearchCopyWith<_ProvenanceSearch> get copyWith;
}

QuestionnaireResponseSearch _$QuestionnaireResponseSearchFromJson(
    Map<String, dynamic> json) {
  return _QuestionnaireResponseSearch.fromJson(json);
}

/// @nodoc
class _$QuestionnaireResponseSearchTearOff {
  const _$QuestionnaireResponseSearchTearOff();

// ignore: unused_element
  _QuestionnaireResponseSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> author,
      List<SearchDate> authored,
      List<SearchReference> encounter,
      List<SearchReference> patient,
      List<SearchReference> questionnaire,
      List<SearchReference> source,
      List<SearchToken> status,
      List<SearchReference> subject}) {
    return _QuestionnaireResponseSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      author: author,
      authored: authored,
      encounter: encounter,
      patient: patient,
      questionnaire: questionnaire,
      source: source,
      status: status,
      subject: subject,
    );
  }

// ignore: unused_element
  QuestionnaireResponseSearch fromJson(Map<String, Object> json) {
    return QuestionnaireResponseSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $QuestionnaireResponseSearch = _$QuestionnaireResponseSearchTearOff();

/// @nodoc
mixin _$QuestionnaireResponseSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get author;
  List<SearchDate> get authored;
  List<SearchReference> get encounter;
  List<SearchReference> get patient;
  List<SearchReference> get questionnaire;
  List<SearchReference> get source;
  List<SearchToken> get status;
  List<SearchReference> get subject;

  Map<String, dynamic> toJson();
  $QuestionnaireResponseSearchCopyWith<QuestionnaireResponseSearch>
      get copyWith;
}

/// @nodoc
abstract class $QuestionnaireResponseSearchCopyWith<$Res> {
  factory $QuestionnaireResponseSearchCopyWith(
          QuestionnaireResponseSearch value,
          $Res Function(QuestionnaireResponseSearch) then) =
      _$QuestionnaireResponseSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> author,
      List<SearchDate> authored,
      List<SearchReference> encounter,
      List<SearchReference> patient,
      List<SearchReference> questionnaire,
      List<SearchReference> source,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class _$QuestionnaireResponseSearchCopyWithImpl<$Res>
    implements $QuestionnaireResponseSearchCopyWith<$Res> {
  _$QuestionnaireResponseSearchCopyWithImpl(this._value, this._then);

  final QuestionnaireResponseSearch _value;
  // ignore: unused_field
  final $Res Function(QuestionnaireResponseSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object author = freezed,
    Object authored = freezed,
    Object encounter = freezed,
    Object patient = freezed,
    Object questionnaire = freezed,
    Object source = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      author:
          author == freezed ? _value.author : author as List<SearchReference>,
      authored:
          authored == freezed ? _value.authored : authored as List<SearchDate>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      questionnaire: questionnaire == freezed
          ? _value.questionnaire
          : questionnaire as List<SearchReference>,
      source:
          source == freezed ? _value.source : source as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$QuestionnaireResponseSearchCopyWith<$Res>
    implements $QuestionnaireResponseSearchCopyWith<$Res> {
  factory _$QuestionnaireResponseSearchCopyWith(
          _QuestionnaireResponseSearch value,
          $Res Function(_QuestionnaireResponseSearch) then) =
      __$QuestionnaireResponseSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> author,
      List<SearchDate> authored,
      List<SearchReference> encounter,
      List<SearchReference> patient,
      List<SearchReference> questionnaire,
      List<SearchReference> source,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class __$QuestionnaireResponseSearchCopyWithImpl<$Res>
    extends _$QuestionnaireResponseSearchCopyWithImpl<$Res>
    implements _$QuestionnaireResponseSearchCopyWith<$Res> {
  __$QuestionnaireResponseSearchCopyWithImpl(
      _QuestionnaireResponseSearch _value,
      $Res Function(_QuestionnaireResponseSearch) _then)
      : super(_value, (v) => _then(v as _QuestionnaireResponseSearch));

  @override
  _QuestionnaireResponseSearch get _value =>
      super._value as _QuestionnaireResponseSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object author = freezed,
    Object authored = freezed,
    Object encounter = freezed,
    Object patient = freezed,
    Object questionnaire = freezed,
    Object source = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_QuestionnaireResponseSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      author:
          author == freezed ? _value.author : author as List<SearchReference>,
      authored:
          authored == freezed ? _value.authored : authored as List<SearchDate>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      questionnaire: questionnaire == freezed
          ? _value.questionnaire
          : questionnaire as List<SearchReference>,
      source:
          source == freezed ? _value.source : source as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_QuestionnaireResponseSearch extends _QuestionnaireResponseSearch {
  _$_QuestionnaireResponseSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.author,
      this.authored,
      this.encounter,
      this.patient,
      this.questionnaire,
      this.source,
      this.status,
      this.subject})
      : super._();

  factory _$_QuestionnaireResponseSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_QuestionnaireResponseSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchReference> author;
  @override
  final List<SearchDate> authored;
  @override
  final List<SearchReference> encounter;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> questionnaire;
  @override
  final List<SearchReference> source;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;

  @override
  String toString() {
    return 'QuestionnaireResponseSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, author: $author, authored: $authored, encounter: $encounter, patient: $patient, questionnaire: $questionnaire, source: $source, status: $status, subject: $subject)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _QuestionnaireResponseSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.authored, authored) ||
                const DeepCollectionEquality()
                    .equals(other.authored, authored)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.questionnaire, questionnaire) ||
                const DeepCollectionEquality()
                    .equals(other.questionnaire, questionnaire)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality().equals(other.subject, subject)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(authored) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(questionnaire) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject);

  @override
  _$QuestionnaireResponseSearchCopyWith<_QuestionnaireResponseSearch>
      get copyWith => __$QuestionnaireResponseSearchCopyWithImpl<
          _QuestionnaireResponseSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_QuestionnaireResponseSearchToJson(this);
  }
}

abstract class _QuestionnaireResponseSearch
    extends QuestionnaireResponseSearch {
  _QuestionnaireResponseSearch._() : super._();
  factory _QuestionnaireResponseSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> author,
      List<SearchDate> authored,
      List<SearchReference> encounter,
      List<SearchReference> patient,
      List<SearchReference> questionnaire,
      List<SearchReference> source,
      List<SearchToken> status,
      List<SearchReference> subject}) = _$_QuestionnaireResponseSearch;

  factory _QuestionnaireResponseSearch.fromJson(Map<String, dynamic> json) =
      _$_QuestionnaireResponseSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get author;
  @override
  List<SearchDate> get authored;
  @override
  List<SearchReference> get encounter;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get questionnaire;
  @override
  List<SearchReference> get source;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  _$QuestionnaireResponseSearchCopyWith<_QuestionnaireResponseSearch>
      get copyWith;
}

AuditEventSearch _$AuditEventSearchFromJson(Map<String, dynamic> json) {
  return _AuditEventSearch.fromJson(json);
}

/// @nodoc
class _$AuditEventSearchTearOff {
  const _$AuditEventSearchTearOff();

// ignore: unused_element
  _AuditEventSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> action,
      List<SearchToken> address,
      List<SearchToken> altid,
      List<SearchDate> date,
      List<SearchString> desc,
      List<SearchToken> identity,
      List<SearchString> name,
      @JsonKey(name: 'object-type') List<SearchToken> objectType,
      List<SearchReference> participant,
      List<SearchReference> patient,
      List<SearchUri> policy,
      List<SearchReference> reference,
      List<SearchToken> site,
      List<SearchToken> source,
      List<SearchToken> subtype,
      List<SearchToken> type,
      List<SearchToken> user}) {
    return _AuditEventSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      action: action,
      address: address,
      altid: altid,
      date: date,
      desc: desc,
      identity: identity,
      name: name,
      objectType: objectType,
      participant: participant,
      patient: patient,
      policy: policy,
      reference: reference,
      site: site,
      source: source,
      subtype: subtype,
      type: type,
      user: user,
    );
  }

// ignore: unused_element
  AuditEventSearch fromJson(Map<String, Object> json) {
    return AuditEventSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $AuditEventSearch = _$AuditEventSearchTearOff();

/// @nodoc
mixin _$AuditEventSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get action;
  List<SearchToken> get address;
  List<SearchToken> get altid;
  List<SearchDate> get date;
  List<SearchString> get desc;
  List<SearchToken> get identity;
  List<SearchString> get name;
  @JsonKey(name: 'object-type')
  List<SearchToken> get objectType;
  List<SearchReference> get participant;
  List<SearchReference> get patient;
  List<SearchUri> get policy;
  List<SearchReference> get reference;
  List<SearchToken> get site;
  List<SearchToken> get source;
  List<SearchToken> get subtype;
  List<SearchToken> get type;
  List<SearchToken> get user;

  Map<String, dynamic> toJson();
  $AuditEventSearchCopyWith<AuditEventSearch> get copyWith;
}

/// @nodoc
abstract class $AuditEventSearchCopyWith<$Res> {
  factory $AuditEventSearchCopyWith(
          AuditEventSearch value, $Res Function(AuditEventSearch) then) =
      _$AuditEventSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> action,
      List<SearchToken> address,
      List<SearchToken> altid,
      List<SearchDate> date,
      List<SearchString> desc,
      List<SearchToken> identity,
      List<SearchString> name,
      @JsonKey(name: 'object-type') List<SearchToken> objectType,
      List<SearchReference> participant,
      List<SearchReference> patient,
      List<SearchUri> policy,
      List<SearchReference> reference,
      List<SearchToken> site,
      List<SearchToken> source,
      List<SearchToken> subtype,
      List<SearchToken> type,
      List<SearchToken> user});
}

/// @nodoc
class _$AuditEventSearchCopyWithImpl<$Res>
    implements $AuditEventSearchCopyWith<$Res> {
  _$AuditEventSearchCopyWithImpl(this._value, this._then);

  final AuditEventSearch _value;
  // ignore: unused_field
  final $Res Function(AuditEventSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object action = freezed,
    Object address = freezed,
    Object altid = freezed,
    Object date = freezed,
    Object desc = freezed,
    Object identity = freezed,
    Object name = freezed,
    Object objectType = freezed,
    Object participant = freezed,
    Object patient = freezed,
    Object policy = freezed,
    Object reference = freezed,
    Object site = freezed,
    Object source = freezed,
    Object subtype = freezed,
    Object type = freezed,
    Object user = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      action: action == freezed ? _value.action : action as List<SearchToken>,
      address:
          address == freezed ? _value.address : address as List<SearchToken>,
      altid: altid == freezed ? _value.altid : altid as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      desc: desc == freezed ? _value.desc : desc as List<SearchString>,
      identity:
          identity == freezed ? _value.identity : identity as List<SearchToken>,
      name: name == freezed ? _value.name : name as List<SearchString>,
      objectType: objectType == freezed
          ? _value.objectType
          : objectType as List<SearchToken>,
      participant: participant == freezed
          ? _value.participant
          : participant as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      policy: policy == freezed ? _value.policy : policy as List<SearchUri>,
      reference: reference == freezed
          ? _value.reference
          : reference as List<SearchReference>,
      site: site == freezed ? _value.site : site as List<SearchToken>,
      source: source == freezed ? _value.source : source as List<SearchToken>,
      subtype:
          subtype == freezed ? _value.subtype : subtype as List<SearchToken>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      user: user == freezed ? _value.user : user as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$AuditEventSearchCopyWith<$Res>
    implements $AuditEventSearchCopyWith<$Res> {
  factory _$AuditEventSearchCopyWith(
          _AuditEventSearch value, $Res Function(_AuditEventSearch) then) =
      __$AuditEventSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> action,
      List<SearchToken> address,
      List<SearchToken> altid,
      List<SearchDate> date,
      List<SearchString> desc,
      List<SearchToken> identity,
      List<SearchString> name,
      @JsonKey(name: 'object-type') List<SearchToken> objectType,
      List<SearchReference> participant,
      List<SearchReference> patient,
      List<SearchUri> policy,
      List<SearchReference> reference,
      List<SearchToken> site,
      List<SearchToken> source,
      List<SearchToken> subtype,
      List<SearchToken> type,
      List<SearchToken> user});
}

/// @nodoc
class __$AuditEventSearchCopyWithImpl<$Res>
    extends _$AuditEventSearchCopyWithImpl<$Res>
    implements _$AuditEventSearchCopyWith<$Res> {
  __$AuditEventSearchCopyWithImpl(
      _AuditEventSearch _value, $Res Function(_AuditEventSearch) _then)
      : super(_value, (v) => _then(v as _AuditEventSearch));

  @override
  _AuditEventSearch get _value => super._value as _AuditEventSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object action = freezed,
    Object address = freezed,
    Object altid = freezed,
    Object date = freezed,
    Object desc = freezed,
    Object identity = freezed,
    Object name = freezed,
    Object objectType = freezed,
    Object participant = freezed,
    Object patient = freezed,
    Object policy = freezed,
    Object reference = freezed,
    Object site = freezed,
    Object source = freezed,
    Object subtype = freezed,
    Object type = freezed,
    Object user = freezed,
  }) {
    return _then(_AuditEventSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      action: action == freezed ? _value.action : action as List<SearchToken>,
      address:
          address == freezed ? _value.address : address as List<SearchToken>,
      altid: altid == freezed ? _value.altid : altid as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      desc: desc == freezed ? _value.desc : desc as List<SearchString>,
      identity:
          identity == freezed ? _value.identity : identity as List<SearchToken>,
      name: name == freezed ? _value.name : name as List<SearchString>,
      objectType: objectType == freezed
          ? _value.objectType
          : objectType as List<SearchToken>,
      participant: participant == freezed
          ? _value.participant
          : participant as List<SearchReference>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      policy: policy == freezed ? _value.policy : policy as List<SearchUri>,
      reference: reference == freezed
          ? _value.reference
          : reference as List<SearchReference>,
      site: site == freezed ? _value.site : site as List<SearchToken>,
      source: source == freezed ? _value.source : source as List<SearchToken>,
      subtype:
          subtype == freezed ? _value.subtype : subtype as List<SearchToken>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      user: user == freezed ? _value.user : user as List<SearchToken>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_AuditEventSearch extends _AuditEventSearch {
  _$_AuditEventSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.action,
      this.address,
      this.altid,
      this.date,
      this.desc,
      this.identity,
      this.name,
      @JsonKey(name: 'object-type') this.objectType,
      this.participant,
      this.patient,
      this.policy,
      this.reference,
      this.site,
      this.source,
      this.subtype,
      this.type,
      this.user})
      : super._();

  factory _$_AuditEventSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_AuditEventSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> action;
  @override
  final List<SearchToken> address;
  @override
  final List<SearchToken> altid;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchString> desc;
  @override
  final List<SearchToken> identity;
  @override
  final List<SearchString> name;
  @override
  @JsonKey(name: 'object-type')
  final List<SearchToken> objectType;
  @override
  final List<SearchReference> participant;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchUri> policy;
  @override
  final List<SearchReference> reference;
  @override
  final List<SearchToken> site;
  @override
  final List<SearchToken> source;
  @override
  final List<SearchToken> subtype;
  @override
  final List<SearchToken> type;
  @override
  final List<SearchToken> user;

  @override
  String toString() {
    return 'AuditEventSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, action: $action, address: $address, altid: $altid, date: $date, desc: $desc, identity: $identity, name: $name, objectType: $objectType, participant: $participant, patient: $patient, policy: $policy, reference: $reference, site: $site, source: $source, subtype: $subtype, type: $type, user: $user)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AuditEventSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.altid, altid) ||
                const DeepCollectionEquality().equals(other.altid, altid)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.desc, desc) ||
                const DeepCollectionEquality().equals(other.desc, desc)) &&
            (identical(other.identity, identity) ||
                const DeepCollectionEquality()
                    .equals(other.identity, identity)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.objectType, objectType) ||
                const DeepCollectionEquality()
                    .equals(other.objectType, objectType)) &&
            (identical(other.participant, participant) ||
                const DeepCollectionEquality()
                    .equals(other.participant, participant)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.policy, policy) ||
                const DeepCollectionEquality().equals(other.policy, policy)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.site, site) ||
                const DeepCollectionEquality().equals(other.site, site)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(action) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(altid) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(desc) ^
      const DeepCollectionEquality().hash(identity) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(objectType) ^
      const DeepCollectionEquality().hash(participant) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(policy) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(site) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(user);

  @override
  _$AuditEventSearchCopyWith<_AuditEventSearch> get copyWith =>
      __$AuditEventSearchCopyWithImpl<_AuditEventSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_AuditEventSearchToJson(this);
  }
}

abstract class _AuditEventSearch extends AuditEventSearch {
  _AuditEventSearch._() : super._();
  factory _AuditEventSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> action,
      List<SearchToken> address,
      List<SearchToken> altid,
      List<SearchDate> date,
      List<SearchString> desc,
      List<SearchToken> identity,
      List<SearchString> name,
      @JsonKey(name: 'object-type') List<SearchToken> objectType,
      List<SearchReference> participant,
      List<SearchReference> patient,
      List<SearchUri> policy,
      List<SearchReference> reference,
      List<SearchToken> site,
      List<SearchToken> source,
      List<SearchToken> subtype,
      List<SearchToken> type,
      List<SearchToken> user}) = _$_AuditEventSearch;

  factory _AuditEventSearch.fromJson(Map<String, dynamic> json) =
      _$_AuditEventSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get action;
  @override
  List<SearchToken> get address;
  @override
  List<SearchToken> get altid;
  @override
  List<SearchDate> get date;
  @override
  List<SearchString> get desc;
  @override
  List<SearchToken> get identity;
  @override
  List<SearchString> get name;
  @override
  @JsonKey(name: 'object-type')
  List<SearchToken> get objectType;
  @override
  List<SearchReference> get participant;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchUri> get policy;
  @override
  List<SearchReference> get reference;
  @override
  List<SearchToken> get site;
  @override
  List<SearchToken> get source;
  @override
  List<SearchToken> get subtype;
  @override
  List<SearchToken> get type;
  @override
  List<SearchToken> get user;
  @override
  _$AuditEventSearchCopyWith<_AuditEventSearch> get copyWith;
}

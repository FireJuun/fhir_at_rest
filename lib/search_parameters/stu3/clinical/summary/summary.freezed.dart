// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'summary.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;
AdverseEventSearch _$AdverseEventSearchFromJson(Map<String, dynamic> json) {
  return _AdverseEventSearch.fromJson(json);
}

/// @nodoc
class _$AdverseEventSearchTearOff {
  const _$AdverseEventSearchTearOff();

// ignore: unused_element
  _AdverseEventSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchReference> location,
      List<SearchReference> reaction,
      List<SearchReference> recorder,
      List<SearchToken> seriousness,
      List<SearchReference> study,
      List<SearchReference> subject,
      List<SearchReference> substance,
      List<SearchToken> type}) {
    return _AdverseEventSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      category: category,
      date: date,
      location: location,
      reaction: reaction,
      recorder: recorder,
      seriousness: seriousness,
      study: study,
      subject: subject,
      substance: substance,
      type: type,
    );
  }

// ignore: unused_element
  AdverseEventSearch fromJson(Map<String, Object> json) {
    return AdverseEventSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $AdverseEventSearch = _$AdverseEventSearchTearOff();

/// @nodoc
mixin _$AdverseEventSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get category;
  List<SearchDate> get date;
  List<SearchReference> get location;
  List<SearchReference> get reaction;
  List<SearchReference> get recorder;
  List<SearchToken> get seriousness;
  List<SearchReference> get study;
  List<SearchReference> get subject;
  List<SearchReference> get substance;
  List<SearchToken> get type;

  Map<String, dynamic> toJson();
  $AdverseEventSearchCopyWith<AdverseEventSearch> get copyWith;
}

/// @nodoc
abstract class $AdverseEventSearchCopyWith<$Res> {
  factory $AdverseEventSearchCopyWith(
          AdverseEventSearch value, $Res Function(AdverseEventSearch) then) =
      _$AdverseEventSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchReference> location,
      List<SearchReference> reaction,
      List<SearchReference> recorder,
      List<SearchToken> seriousness,
      List<SearchReference> study,
      List<SearchReference> subject,
      List<SearchReference> substance,
      List<SearchToken> type});
}

/// @nodoc
class _$AdverseEventSearchCopyWithImpl<$Res>
    implements $AdverseEventSearchCopyWith<$Res> {
  _$AdverseEventSearchCopyWithImpl(this._value, this._then);

  final AdverseEventSearch _value;
  // ignore: unused_field
  final $Res Function(AdverseEventSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object category = freezed,
    Object date = freezed,
    Object location = freezed,
    Object reaction = freezed,
    Object recorder = freezed,
    Object seriousness = freezed,
    Object study = freezed,
    Object subject = freezed,
    Object substance = freezed,
    Object type = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      location: location == freezed
          ? _value.location
          : location as List<SearchReference>,
      reaction: reaction == freezed
          ? _value.reaction
          : reaction as List<SearchReference>,
      recorder: recorder == freezed
          ? _value.recorder
          : recorder as List<SearchReference>,
      seriousness: seriousness == freezed
          ? _value.seriousness
          : seriousness as List<SearchToken>,
      study: study == freezed ? _value.study : study as List<SearchReference>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      substance: substance == freezed
          ? _value.substance
          : substance as List<SearchReference>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$AdverseEventSearchCopyWith<$Res>
    implements $AdverseEventSearchCopyWith<$Res> {
  factory _$AdverseEventSearchCopyWith(
          _AdverseEventSearch value, $Res Function(_AdverseEventSearch) then) =
      __$AdverseEventSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchReference> location,
      List<SearchReference> reaction,
      List<SearchReference> recorder,
      List<SearchToken> seriousness,
      List<SearchReference> study,
      List<SearchReference> subject,
      List<SearchReference> substance,
      List<SearchToken> type});
}

/// @nodoc
class __$AdverseEventSearchCopyWithImpl<$Res>
    extends _$AdverseEventSearchCopyWithImpl<$Res>
    implements _$AdverseEventSearchCopyWith<$Res> {
  __$AdverseEventSearchCopyWithImpl(
      _AdverseEventSearch _value, $Res Function(_AdverseEventSearch) _then)
      : super(_value, (v) => _then(v as _AdverseEventSearch));

  @override
  _AdverseEventSearch get _value => super._value as _AdverseEventSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object category = freezed,
    Object date = freezed,
    Object location = freezed,
    Object reaction = freezed,
    Object recorder = freezed,
    Object seriousness = freezed,
    Object study = freezed,
    Object subject = freezed,
    Object substance = freezed,
    Object type = freezed,
  }) {
    return _then(_AdverseEventSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      location: location == freezed
          ? _value.location
          : location as List<SearchReference>,
      reaction: reaction == freezed
          ? _value.reaction
          : reaction as List<SearchReference>,
      recorder: recorder == freezed
          ? _value.recorder
          : recorder as List<SearchReference>,
      seriousness: seriousness == freezed
          ? _value.seriousness
          : seriousness as List<SearchToken>,
      study: study == freezed ? _value.study : study as List<SearchReference>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      substance: substance == freezed
          ? _value.substance
          : substance as List<SearchReference>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_AdverseEventSearch extends _AdverseEventSearch {
  _$_AdverseEventSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.category,
      this.date,
      this.location,
      this.reaction,
      this.recorder,
      this.seriousness,
      this.study,
      this.subject,
      this.substance,
      this.type})
      : super._();

  factory _$_AdverseEventSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_AdverseEventSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> category;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchReference> location;
  @override
  final List<SearchReference> reaction;
  @override
  final List<SearchReference> recorder;
  @override
  final List<SearchToken> seriousness;
  @override
  final List<SearchReference> study;
  @override
  final List<SearchReference> subject;
  @override
  final List<SearchReference> substance;
  @override
  final List<SearchToken> type;

  @override
  String toString() {
    return 'AdverseEventSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, category: $category, date: $date, location: $location, reaction: $reaction, recorder: $recorder, seriousness: $seriousness, study: $study, subject: $subject, substance: $substance, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AdverseEventSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.reaction, reaction) ||
                const DeepCollectionEquality()
                    .equals(other.reaction, reaction)) &&
            (identical(other.recorder, recorder) ||
                const DeepCollectionEquality()
                    .equals(other.recorder, recorder)) &&
            (identical(other.seriousness, seriousness) ||
                const DeepCollectionEquality()
                    .equals(other.seriousness, seriousness)) &&
            (identical(other.study, study) ||
                const DeepCollectionEquality().equals(other.study, study)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality()
                    .equals(other.subject, subject)) &&
            (identical(other.substance, substance) ||
                const DeepCollectionEquality()
                    .equals(other.substance, substance)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(reaction) ^
      const DeepCollectionEquality().hash(recorder) ^
      const DeepCollectionEquality().hash(seriousness) ^
      const DeepCollectionEquality().hash(study) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(substance) ^
      const DeepCollectionEquality().hash(type);

  @override
  _$AdverseEventSearchCopyWith<_AdverseEventSearch> get copyWith =>
      __$AdverseEventSearchCopyWithImpl<_AdverseEventSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_AdverseEventSearchToJson(this);
  }
}

abstract class _AdverseEventSearch extends AdverseEventSearch {
  _AdverseEventSearch._() : super._();
  factory _AdverseEventSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> category,
      List<SearchDate> date,
      List<SearchReference> location,
      List<SearchReference> reaction,
      List<SearchReference> recorder,
      List<SearchToken> seriousness,
      List<SearchReference> study,
      List<SearchReference> subject,
      List<SearchReference> substance,
      List<SearchToken> type}) = _$_AdverseEventSearch;

  factory _AdverseEventSearch.fromJson(Map<String, dynamic> json) =
      _$_AdverseEventSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get category;
  @override
  List<SearchDate> get date;
  @override
  List<SearchReference> get location;
  @override
  List<SearchReference> get reaction;
  @override
  List<SearchReference> get recorder;
  @override
  List<SearchToken> get seriousness;
  @override
  List<SearchReference> get study;
  @override
  List<SearchReference> get subject;
  @override
  List<SearchReference> get substance;
  @override
  List<SearchToken> get type;
  @override
  _$AdverseEventSearchCopyWith<_AdverseEventSearch> get copyWith;
}

AllergyIntoleranceSearch _$AllergyIntoleranceSearchFromJson(
    Map<String, dynamic> json) {
  return _AllergyIntoleranceSearch.fromJson(json);
}

/// @nodoc
class _$AllergyIntoleranceSearchTearOff {
  const _$AllergyIntoleranceSearchTearOff();

// ignore: unused_element
  _AllergyIntoleranceSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> asserter,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      @JsonKey(name: 'last-date')
          List<SearchDate> lastDate,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<SearchReference> patient,
      List<SearchReference> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus}) {
    return _AllergyIntoleranceSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      asserter: asserter,
      category: category,
      clinicalStatus: clinicalStatus,
      code: code,
      criticality: criticality,
      date: date,
      identifier: identifier,
      lastDate: lastDate,
      manifestation: manifestation,
      onset: onset,
      patient: patient,
      recorder: recorder,
      route: route,
      severity: severity,
      type: type,
      verificationStatus: verificationStatus,
    );
  }

// ignore: unused_element
  AllergyIntoleranceSearch fromJson(Map<String, Object> json) {
    return AllergyIntoleranceSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $AllergyIntoleranceSearch = _$AllergyIntoleranceSearchTearOff();

/// @nodoc
mixin _$AllergyIntoleranceSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get asserter;
  List<SearchToken> get category;
  @JsonKey(name: 'clinical-status')
  List<SearchToken> get clinicalStatus;
  List<SearchToken> get code;
  List<SearchToken> get criticality;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  @JsonKey(name: 'last-date')
  List<SearchDate> get lastDate;
  List<SearchToken> get manifestation;
  List<SearchDate> get onset;
  List<SearchReference> get patient;
  List<SearchReference> get recorder;
  List<SearchToken> get route;
  List<SearchToken> get severity;
  List<SearchToken> get type;
  @JsonKey(name: 'verification-status')
  List<SearchToken> get verificationStatus;

  Map<String, dynamic> toJson();
  $AllergyIntoleranceSearchCopyWith<AllergyIntoleranceSearch> get copyWith;
}

/// @nodoc
abstract class $AllergyIntoleranceSearchCopyWith<$Res> {
  factory $AllergyIntoleranceSearchCopyWith(AllergyIntoleranceSearch value,
          $Res Function(AllergyIntoleranceSearch) then) =
      _$AllergyIntoleranceSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> asserter,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      @JsonKey(name: 'last-date')
          List<SearchDate> lastDate,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<SearchReference> patient,
      List<SearchReference> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus});
}

/// @nodoc
class _$AllergyIntoleranceSearchCopyWithImpl<$Res>
    implements $AllergyIntoleranceSearchCopyWith<$Res> {
  _$AllergyIntoleranceSearchCopyWithImpl(this._value, this._then);

  final AllergyIntoleranceSearch _value;
  // ignore: unused_field
  final $Res Function(AllergyIntoleranceSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object asserter = freezed,
    Object category = freezed,
    Object clinicalStatus = freezed,
    Object code = freezed,
    Object criticality = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object lastDate = freezed,
    Object manifestation = freezed,
    Object onset = freezed,
    Object patient = freezed,
    Object recorder = freezed,
    Object route = freezed,
    Object severity = freezed,
    Object type = freezed,
    Object verificationStatus = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      asserter: asserter == freezed
          ? _value.asserter
          : asserter as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinicalStatus: clinicalStatus == freezed
          ? _value.clinicalStatus
          : clinicalStatus as List<SearchToken>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      criticality: criticality == freezed
          ? _value.criticality
          : criticality as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      lastDate:
          lastDate == freezed ? _value.lastDate : lastDate as List<SearchDate>,
      manifestation: manifestation == freezed
          ? _value.manifestation
          : manifestation as List<SearchToken>,
      onset: onset == freezed ? _value.onset : onset as List<SearchDate>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      recorder: recorder == freezed
          ? _value.recorder
          : recorder as List<SearchReference>,
      route: route == freezed ? _value.route : route as List<SearchToken>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      verificationStatus: verificationStatus == freezed
          ? _value.verificationStatus
          : verificationStatus as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$AllergyIntoleranceSearchCopyWith<$Res>
    implements $AllergyIntoleranceSearchCopyWith<$Res> {
  factory _$AllergyIntoleranceSearchCopyWith(_AllergyIntoleranceSearch value,
          $Res Function(_AllergyIntoleranceSearch) then) =
      __$AllergyIntoleranceSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> asserter,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      @JsonKey(name: 'last-date')
          List<SearchDate> lastDate,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<SearchReference> patient,
      List<SearchReference> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus});
}

/// @nodoc
class __$AllergyIntoleranceSearchCopyWithImpl<$Res>
    extends _$AllergyIntoleranceSearchCopyWithImpl<$Res>
    implements _$AllergyIntoleranceSearchCopyWith<$Res> {
  __$AllergyIntoleranceSearchCopyWithImpl(_AllergyIntoleranceSearch _value,
      $Res Function(_AllergyIntoleranceSearch) _then)
      : super(_value, (v) => _then(v as _AllergyIntoleranceSearch));

  @override
  _AllergyIntoleranceSearch get _value =>
      super._value as _AllergyIntoleranceSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object asserter = freezed,
    Object category = freezed,
    Object clinicalStatus = freezed,
    Object code = freezed,
    Object criticality = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object lastDate = freezed,
    Object manifestation = freezed,
    Object onset = freezed,
    Object patient = freezed,
    Object recorder = freezed,
    Object route = freezed,
    Object severity = freezed,
    Object type = freezed,
    Object verificationStatus = freezed,
  }) {
    return _then(_AllergyIntoleranceSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      asserter: asserter == freezed
          ? _value.asserter
          : asserter as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinicalStatus: clinicalStatus == freezed
          ? _value.clinicalStatus
          : clinicalStatus as List<SearchToken>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      criticality: criticality == freezed
          ? _value.criticality
          : criticality as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      lastDate:
          lastDate == freezed ? _value.lastDate : lastDate as List<SearchDate>,
      manifestation: manifestation == freezed
          ? _value.manifestation
          : manifestation as List<SearchToken>,
      onset: onset == freezed ? _value.onset : onset as List<SearchDate>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      recorder: recorder == freezed
          ? _value.recorder
          : recorder as List<SearchReference>,
      route: route == freezed ? _value.route : route as List<SearchToken>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      type: type == freezed ? _value.type : type as List<SearchToken>,
      verificationStatus: verificationStatus == freezed
          ? _value.verificationStatus
          : verificationStatus as List<SearchToken>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_AllergyIntoleranceSearch extends _AllergyIntoleranceSearch {
  _$_AllergyIntoleranceSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.asserter,
      this.category,
      @JsonKey(name: 'clinical-status') this.clinicalStatus,
      this.code,
      this.criticality,
      this.date,
      this.identifier,
      @JsonKey(name: 'last-date') this.lastDate,
      this.manifestation,
      this.onset,
      this.patient,
      this.recorder,
      this.route,
      this.severity,
      this.type,
      @JsonKey(name: 'verification-status') this.verificationStatus})
      : super._();

  factory _$_AllergyIntoleranceSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_AllergyIntoleranceSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchReference> asserter;
  @override
  final List<SearchToken> category;
  @override
  @JsonKey(name: 'clinical-status')
  final List<SearchToken> clinicalStatus;
  @override
  final List<SearchToken> code;
  @override
  final List<SearchToken> criticality;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  @JsonKey(name: 'last-date')
  final List<SearchDate> lastDate;
  @override
  final List<SearchToken> manifestation;
  @override
  final List<SearchDate> onset;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> recorder;
  @override
  final List<SearchToken> route;
  @override
  final List<SearchToken> severity;
  @override
  final List<SearchToken> type;
  @override
  @JsonKey(name: 'verification-status')
  final List<SearchToken> verificationStatus;

  @override
  String toString() {
    return 'AllergyIntoleranceSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, asserter: $asserter, category: $category, clinicalStatus: $clinicalStatus, code: $code, criticality: $criticality, date: $date, identifier: $identifier, lastDate: $lastDate, manifestation: $manifestation, onset: $onset, patient: $patient, recorder: $recorder, route: $route, severity: $severity, type: $type, verificationStatus: $verificationStatus)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AllergyIntoleranceSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.asserter, asserter) ||
                const DeepCollectionEquality()
                    .equals(other.asserter, asserter)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.clinicalStatus, clinicalStatus) ||
                const DeepCollectionEquality()
                    .equals(other.clinicalStatus, clinicalStatus)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.criticality, criticality) ||
                const DeepCollectionEquality()
                    .equals(other.criticality, criticality)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.lastDate, lastDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastDate, lastDate)) &&
            (identical(other.manifestation, manifestation) ||
                const DeepCollectionEquality()
                    .equals(other.manifestation, manifestation)) &&
            (identical(other.onset, onset) ||
                const DeepCollectionEquality().equals(other.onset, onset)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.recorder, recorder) ||
                const DeepCollectionEquality()
                    .equals(other.recorder, recorder)) &&
            (identical(other.route, route) ||
                const DeepCollectionEquality().equals(other.route, route)) &&
            (identical(other.severity, severity) ||
                const DeepCollectionEquality()
                    .equals(other.severity, severity)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(asserter) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(clinicalStatus) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(criticality) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(lastDate) ^
      const DeepCollectionEquality().hash(manifestation) ^
      const DeepCollectionEquality().hash(onset) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(recorder) ^
      const DeepCollectionEquality().hash(route) ^
      const DeepCollectionEquality().hash(severity) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(verificationStatus);

  @override
  _$AllergyIntoleranceSearchCopyWith<_AllergyIntoleranceSearch> get copyWith =>
      __$AllergyIntoleranceSearchCopyWithImpl<_AllergyIntoleranceSearch>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_AllergyIntoleranceSearchToJson(this);
  }
}

abstract class _AllergyIntoleranceSearch extends AllergyIntoleranceSearch {
  _AllergyIntoleranceSearch._() : super._();
  factory _AllergyIntoleranceSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchReference> asserter,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchToken> code,
      List<SearchToken> criticality,
      List<SearchDate> date,
      List<SearchToken> identifier,
      @JsonKey(name: 'last-date')
          List<SearchDate> lastDate,
      List<SearchToken> manifestation,
      List<SearchDate> onset,
      List<SearchReference> patient,
      List<SearchReference> recorder,
      List<SearchToken> route,
      List<SearchToken> severity,
      List<SearchToken> type,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus}) = _$_AllergyIntoleranceSearch;

  factory _AllergyIntoleranceSearch.fromJson(Map<String, dynamic> json) =
      _$_AllergyIntoleranceSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchReference> get asserter;
  @override
  List<SearchToken> get category;
  @override
  @JsonKey(name: 'clinical-status')
  List<SearchToken> get clinicalStatus;
  @override
  List<SearchToken> get code;
  @override
  List<SearchToken> get criticality;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  @JsonKey(name: 'last-date')
  List<SearchDate> get lastDate;
  @override
  List<SearchToken> get manifestation;
  @override
  List<SearchDate> get onset;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get recorder;
  @override
  List<SearchToken> get route;
  @override
  List<SearchToken> get severity;
  @override
  List<SearchToken> get type;
  @override
  @JsonKey(name: 'verification-status')
  List<SearchToken> get verificationStatus;
  @override
  _$AllergyIntoleranceSearchCopyWith<_AllergyIntoleranceSearch> get copyWith;
}

FamilyMemberHistorySearch _$FamilyMemberHistorySearchFromJson(
    Map<String, dynamic> json) {
  return _FamilyMemberHistorySearch.fromJson(json);
}

/// @nodoc
class _$FamilyMemberHistorySearchTearOff {
  const _$FamilyMemberHistorySearchTearOff();

// ignore: unused_element
  _FamilyMemberHistorySearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> definition,
      List<SearchToken> gender,
      List<SearchToken> relationship,
      List<SearchToken> status}) {
    return _FamilyMemberHistorySearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      code: code,
      date: date,
      identifier: identifier,
      patient: patient,
      definition: definition,
      gender: gender,
      relationship: relationship,
      status: status,
    );
  }

// ignore: unused_element
  FamilyMemberHistorySearch fromJson(Map<String, Object> json) {
    return FamilyMemberHistorySearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $FamilyMemberHistorySearch = _$FamilyMemberHistorySearchTearOff();

/// @nodoc
mixin _$FamilyMemberHistorySearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  List<SearchReference> get definition;
  List<SearchToken> get gender;
  List<SearchToken> get relationship;
  List<SearchToken> get status;

  Map<String, dynamic> toJson();
  $FamilyMemberHistorySearchCopyWith<FamilyMemberHistorySearch> get copyWith;
}

/// @nodoc
abstract class $FamilyMemberHistorySearchCopyWith<$Res> {
  factory $FamilyMemberHistorySearchCopyWith(FamilyMemberHistorySearch value,
          $Res Function(FamilyMemberHistorySearch) then) =
      _$FamilyMemberHistorySearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> definition,
      List<SearchToken> gender,
      List<SearchToken> relationship,
      List<SearchToken> status});
}

/// @nodoc
class _$FamilyMemberHistorySearchCopyWithImpl<$Res>
    implements $FamilyMemberHistorySearchCopyWith<$Res> {
  _$FamilyMemberHistorySearchCopyWithImpl(this._value, this._then);

  final FamilyMemberHistorySearch _value;
  // ignore: unused_field
  final $Res Function(FamilyMemberHistorySearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object definition = freezed,
    Object gender = freezed,
    Object relationship = freezed,
    Object status = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      definition: definition == freezed
          ? _value.definition
          : definition as List<SearchReference>,
      gender: gender == freezed ? _value.gender : gender as List<SearchToken>,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as List<SearchToken>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$FamilyMemberHistorySearchCopyWith<$Res>
    implements $FamilyMemberHistorySearchCopyWith<$Res> {
  factory _$FamilyMemberHistorySearchCopyWith(_FamilyMemberHistorySearch value,
          $Res Function(_FamilyMemberHistorySearch) then) =
      __$FamilyMemberHistorySearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> definition,
      List<SearchToken> gender,
      List<SearchToken> relationship,
      List<SearchToken> status});
}

/// @nodoc
class __$FamilyMemberHistorySearchCopyWithImpl<$Res>
    extends _$FamilyMemberHistorySearchCopyWithImpl<$Res>
    implements _$FamilyMemberHistorySearchCopyWith<$Res> {
  __$FamilyMemberHistorySearchCopyWithImpl(_FamilyMemberHistorySearch _value,
      $Res Function(_FamilyMemberHistorySearch) _then)
      : super(_value, (v) => _then(v as _FamilyMemberHistorySearch));

  @override
  _FamilyMemberHistorySearch get _value =>
      super._value as _FamilyMemberHistorySearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object definition = freezed,
    Object gender = freezed,
    Object relationship = freezed,
    Object status = freezed,
  }) {
    return _then(_FamilyMemberHistorySearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      definition: definition == freezed
          ? _value.definition
          : definition as List<SearchReference>,
      gender: gender == freezed ? _value.gender : gender as List<SearchToken>,
      relationship: relationship == freezed
          ? _value.relationship
          : relationship as List<SearchToken>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_FamilyMemberHistorySearch extends _FamilyMemberHistorySearch {
  _$_FamilyMemberHistorySearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.code,
      this.date,
      this.identifier,
      this.patient,
      this.definition,
      this.gender,
      this.relationship,
      this.status})
      : super._();

  factory _$_FamilyMemberHistorySearch.fromJson(Map<String, dynamic> json) =>
      _$_$_FamilyMemberHistorySearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> definition;
  @override
  final List<SearchToken> gender;
  @override
  final List<SearchToken> relationship;
  @override
  final List<SearchToken> status;

  @override
  String toString() {
    return 'FamilyMemberHistorySearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, code: $code, date: $date, identifier: $identifier, patient: $patient, definition: $definition, gender: $gender, relationship: $relationship, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _FamilyMemberHistorySearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.definition, definition) ||
                const DeepCollectionEquality()
                    .equals(other.definition, definition)) &&
            (identical(other.gender, gender) ||
                const DeepCollectionEquality().equals(other.gender, gender)) &&
            (identical(other.relationship, relationship) ||
                const DeepCollectionEquality()
                    .equals(other.relationship, relationship)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(definition) ^
      const DeepCollectionEquality().hash(gender) ^
      const DeepCollectionEquality().hash(relationship) ^
      const DeepCollectionEquality().hash(status);

  @override
  _$FamilyMemberHistorySearchCopyWith<_FamilyMemberHistorySearch>
      get copyWith =>
          __$FamilyMemberHistorySearchCopyWithImpl<_FamilyMemberHistorySearch>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_FamilyMemberHistorySearchToJson(this);
  }
}

abstract class _FamilyMemberHistorySearch extends FamilyMemberHistorySearch {
  _FamilyMemberHistorySearch._() : super._();
  factory _FamilyMemberHistorySearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> definition,
      List<SearchToken> gender,
      List<SearchToken> relationship,
      List<SearchToken> status}) = _$_FamilyMemberHistorySearch;

  factory _FamilyMemberHistorySearch.fromJson(Map<String, dynamic> json) =
      _$_FamilyMemberHistorySearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get definition;
  @override
  List<SearchToken> get gender;
  @override
  List<SearchToken> get relationship;
  @override
  List<SearchToken> get status;
  @override
  _$FamilyMemberHistorySearchCopyWith<_FamilyMemberHistorySearch> get copyWith;
}

ProcedureSearch _$ProcedureSearchFromJson(Map<String, dynamic> json) {
  return _ProcedureSearch.fromJson(json);
}

/// @nodoc
class _$ProcedureSearchTearOff {
  const _$ProcedureSearchTearOff();

// ignore: unused_element
  _ProcedureSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      @JsonKey(name: 'based-on') List<SearchReference> basedOn,
      List<SearchToken> category,
      List<SearchReference> context,
      List<SearchReference> definition,
      List<SearchReference> location,
      @JsonKey(name: 'part-of') List<SearchReference> partOf,
      List<SearchReference> performer,
      List<SearchToken> status,
      List<SearchReference> subject}) {
    return _ProcedureSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      code: code,
      date: date,
      identifier: identifier,
      patient: patient,
      encounter: encounter,
      basedOn: basedOn,
      category: category,
      context: context,
      definition: definition,
      location: location,
      partOf: partOf,
      performer: performer,
      status: status,
      subject: subject,
    );
  }

// ignore: unused_element
  ProcedureSearch fromJson(Map<String, Object> json) {
    return ProcedureSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $ProcedureSearch = _$ProcedureSearchTearOff();

/// @nodoc
mixin _$ProcedureSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  List<SearchReference> get encounter;
  @JsonKey(name: 'based-on')
  List<SearchReference> get basedOn;
  List<SearchToken> get category;
  List<SearchReference> get context;
  List<SearchReference> get definition;
  List<SearchReference> get location;
  @JsonKey(name: 'part-of')
  List<SearchReference> get partOf;
  List<SearchReference> get performer;
  List<SearchToken> get status;
  List<SearchReference> get subject;

  Map<String, dynamic> toJson();
  $ProcedureSearchCopyWith<ProcedureSearch> get copyWith;
}

/// @nodoc
abstract class $ProcedureSearchCopyWith<$Res> {
  factory $ProcedureSearchCopyWith(
          ProcedureSearch value, $Res Function(ProcedureSearch) then) =
      _$ProcedureSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      @JsonKey(name: 'based-on') List<SearchReference> basedOn,
      List<SearchToken> category,
      List<SearchReference> context,
      List<SearchReference> definition,
      List<SearchReference> location,
      @JsonKey(name: 'part-of') List<SearchReference> partOf,
      List<SearchReference> performer,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class _$ProcedureSearchCopyWithImpl<$Res>
    implements $ProcedureSearchCopyWith<$Res> {
  _$ProcedureSearchCopyWithImpl(this._value, this._then);

  final ProcedureSearch _value;
  // ignore: unused_field
  final $Res Function(ProcedureSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object encounter = freezed,
    Object basedOn = freezed,
    Object category = freezed,
    Object context = freezed,
    Object definition = freezed,
    Object location = freezed,
    Object partOf = freezed,
    Object performer = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      basedOn: basedOn == freezed
          ? _value.basedOn
          : basedOn as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      context: context == freezed
          ? _value.context
          : context as List<SearchReference>,
      definition: definition == freezed
          ? _value.definition
          : definition as List<SearchReference>,
      location: location == freezed
          ? _value.location
          : location as List<SearchReference>,
      partOf:
          partOf == freezed ? _value.partOf : partOf as List<SearchReference>,
      performer: performer == freezed
          ? _value.performer
          : performer as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$ProcedureSearchCopyWith<$Res>
    implements $ProcedureSearchCopyWith<$Res> {
  factory _$ProcedureSearchCopyWith(
          _ProcedureSearch value, $Res Function(_ProcedureSearch) then) =
      __$ProcedureSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      @JsonKey(name: 'based-on') List<SearchReference> basedOn,
      List<SearchToken> category,
      List<SearchReference> context,
      List<SearchReference> definition,
      List<SearchReference> location,
      @JsonKey(name: 'part-of') List<SearchReference> partOf,
      List<SearchReference> performer,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class __$ProcedureSearchCopyWithImpl<$Res>
    extends _$ProcedureSearchCopyWithImpl<$Res>
    implements _$ProcedureSearchCopyWith<$Res> {
  __$ProcedureSearchCopyWithImpl(
      _ProcedureSearch _value, $Res Function(_ProcedureSearch) _then)
      : super(_value, (v) => _then(v as _ProcedureSearch));

  @override
  _ProcedureSearch get _value => super._value as _ProcedureSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object encounter = freezed,
    Object basedOn = freezed,
    Object category = freezed,
    Object context = freezed,
    Object definition = freezed,
    Object location = freezed,
    Object partOf = freezed,
    Object performer = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_ProcedureSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      basedOn: basedOn == freezed
          ? _value.basedOn
          : basedOn as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      context: context == freezed
          ? _value.context
          : context as List<SearchReference>,
      definition: definition == freezed
          ? _value.definition
          : definition as List<SearchReference>,
      location: location == freezed
          ? _value.location
          : location as List<SearchReference>,
      partOf:
          partOf == freezed ? _value.partOf : partOf as List<SearchReference>,
      performer: performer == freezed
          ? _value.performer
          : performer as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_ProcedureSearch extends _ProcedureSearch {
  _$_ProcedureSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.code,
      this.date,
      this.identifier,
      this.patient,
      this.encounter,
      @JsonKey(name: 'based-on') this.basedOn,
      this.category,
      this.context,
      this.definition,
      this.location,
      @JsonKey(name: 'part-of') this.partOf,
      this.performer,
      this.status,
      this.subject})
      : super._();

  factory _$_ProcedureSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_ProcedureSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> encounter;
  @override
  @JsonKey(name: 'based-on')
  final List<SearchReference> basedOn;
  @override
  final List<SearchToken> category;
  @override
  final List<SearchReference> context;
  @override
  final List<SearchReference> definition;
  @override
  final List<SearchReference> location;
  @override
  @JsonKey(name: 'part-of')
  final List<SearchReference> partOf;
  @override
  final List<SearchReference> performer;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;

  @override
  String toString() {
    return 'ProcedureSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, code: $code, date: $date, identifier: $identifier, patient: $patient, encounter: $encounter, basedOn: $basedOn, category: $category, context: $context, definition: $definition, location: $location, partOf: $partOf, performer: $performer, status: $status, subject: $subject)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ProcedureSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.basedOn, basedOn) ||
                const DeepCollectionEquality()
                    .equals(other.basedOn, basedOn)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.context, context) ||
                const DeepCollectionEquality()
                    .equals(other.context, context)) &&
            (identical(other.definition, definition) ||
                const DeepCollectionEquality()
                    .equals(other.definition, definition)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.partOf, partOf) ||
                const DeepCollectionEquality().equals(other.partOf, partOf)) &&
            (identical(other.performer, performer) ||
                const DeepCollectionEquality()
                    .equals(other.performer, performer)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality().equals(other.subject, subject)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(basedOn) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(context) ^
      const DeepCollectionEquality().hash(definition) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(partOf) ^
      const DeepCollectionEquality().hash(performer) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject);

  @override
  _$ProcedureSearchCopyWith<_ProcedureSearch> get copyWith =>
      __$ProcedureSearchCopyWithImpl<_ProcedureSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ProcedureSearchToJson(this);
  }
}

abstract class _ProcedureSearch extends ProcedureSearch {
  _ProcedureSearch._() : super._();
  factory _ProcedureSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> encounter,
      @JsonKey(name: 'based-on') List<SearchReference> basedOn,
      List<SearchToken> category,
      List<SearchReference> context,
      List<SearchReference> definition,
      List<SearchReference> location,
      @JsonKey(name: 'part-of') List<SearchReference> partOf,
      List<SearchReference> performer,
      List<SearchToken> status,
      List<SearchReference> subject}) = _$_ProcedureSearch;

  factory _ProcedureSearch.fromJson(Map<String, dynamic> json) =
      _$_ProcedureSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get encounter;
  @override
  @JsonKey(name: 'based-on')
  List<SearchReference> get basedOn;
  @override
  List<SearchToken> get category;
  @override
  List<SearchReference> get context;
  @override
  List<SearchReference> get definition;
  @override
  List<SearchReference> get location;
  @override
  @JsonKey(name: 'part-of')
  List<SearchReference> get partOf;
  @override
  List<SearchReference> get performer;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  _$ProcedureSearchCopyWith<_ProcedureSearch> get copyWith;
}

ConditionSearch _$ConditionSearchFromJson(Map<String, dynamic> json) {
  return _ConditionSearch.fromJson(json);
}

/// @nodoc
class _$ConditionSearchTearOff {
  const _$ConditionSearchTearOff();

// ignore: unused_element
  _ConditionSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'abatement-age')
          List<SearchQuantity> abatementAge,
      @JsonKey(name: 'abatement-boolean')
          List<SearchToken> abatementBoolean,
      @JsonKey(name: 'abatement-date')
          List<SearchDate> abatementDate,
      @JsonKey(name: 'abatement-string')
          List<SearchString> abatementString,
      @JsonKey(name: 'asserted-date')
          List<SearchDate> assertedDate,
      List<SearchReference> asserter,
      @JsonKey(name: 'body-site')
          List<SearchToken> bodySite,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchReference> context,
      List<SearchReference> encounter,
      List<SearchToken> evidence,
      @JsonKey(name: 'evidence-detail')
          List<SearchReference> evidenceDetail,
      @JsonKey(name: 'onset-age')
          List<SearchQuantity> onsetAge,
      @JsonKey(name: 'onset-date')
          List<SearchDate> onsetDate,
      @JsonKey(name: 'onset-info')
          List<SearchString> onsetInfo,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<SearchReference> subject,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus}) {
    return _ConditionSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      code: code,
      identifier: identifier,
      patient: patient,
      abatementAge: abatementAge,
      abatementBoolean: abatementBoolean,
      abatementDate: abatementDate,
      abatementString: abatementString,
      assertedDate: assertedDate,
      asserter: asserter,
      bodySite: bodySite,
      category: category,
      clinicalStatus: clinicalStatus,
      context: context,
      encounter: encounter,
      evidence: evidence,
      evidenceDetail: evidenceDetail,
      onsetAge: onsetAge,
      onsetDate: onsetDate,
      onsetInfo: onsetInfo,
      severity: severity,
      stage: stage,
      subject: subject,
      verificationStatus: verificationStatus,
    );
  }

// ignore: unused_element
  ConditionSearch fromJson(Map<String, Object> json) {
    return ConditionSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $ConditionSearch = _$ConditionSearchTearOff();

/// @nodoc
mixin _$ConditionSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  @JsonKey(name: 'abatement-age')
  List<SearchQuantity> get abatementAge;
  @JsonKey(name: 'abatement-boolean')
  List<SearchToken> get abatementBoolean;
  @JsonKey(name: 'abatement-date')
  List<SearchDate> get abatementDate;
  @JsonKey(name: 'abatement-string')
  List<SearchString> get abatementString;
  @JsonKey(name: 'asserted-date')
  List<SearchDate> get assertedDate;
  List<SearchReference> get asserter;
  @JsonKey(name: 'body-site')
  List<SearchToken> get bodySite;
  List<SearchToken> get category;
  @JsonKey(name: 'clinical-status')
  List<SearchToken> get clinicalStatus;
  List<SearchReference> get context;
  List<SearchReference> get encounter;
  List<SearchToken> get evidence;
  @JsonKey(name: 'evidence-detail')
  List<SearchReference> get evidenceDetail;
  @JsonKey(name: 'onset-age')
  List<SearchQuantity> get onsetAge;
  @JsonKey(name: 'onset-date')
  List<SearchDate> get onsetDate;
  @JsonKey(name: 'onset-info')
  List<SearchString> get onsetInfo;
  List<SearchToken> get severity;
  List<SearchToken> get stage;
  List<SearchReference> get subject;
  @JsonKey(name: 'verification-status')
  List<SearchToken> get verificationStatus;

  Map<String, dynamic> toJson();
  $ConditionSearchCopyWith<ConditionSearch> get copyWith;
}

/// @nodoc
abstract class $ConditionSearchCopyWith<$Res> {
  factory $ConditionSearchCopyWith(
          ConditionSearch value, $Res Function(ConditionSearch) then) =
      _$ConditionSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'abatement-age')
          List<SearchQuantity> abatementAge,
      @JsonKey(name: 'abatement-boolean')
          List<SearchToken> abatementBoolean,
      @JsonKey(name: 'abatement-date')
          List<SearchDate> abatementDate,
      @JsonKey(name: 'abatement-string')
          List<SearchString> abatementString,
      @JsonKey(name: 'asserted-date')
          List<SearchDate> assertedDate,
      List<SearchReference> asserter,
      @JsonKey(name: 'body-site')
          List<SearchToken> bodySite,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchReference> context,
      List<SearchReference> encounter,
      List<SearchToken> evidence,
      @JsonKey(name: 'evidence-detail')
          List<SearchReference> evidenceDetail,
      @JsonKey(name: 'onset-age')
          List<SearchQuantity> onsetAge,
      @JsonKey(name: 'onset-date')
          List<SearchDate> onsetDate,
      @JsonKey(name: 'onset-info')
          List<SearchString> onsetInfo,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<SearchReference> subject,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus});
}

/// @nodoc
class _$ConditionSearchCopyWithImpl<$Res>
    implements $ConditionSearchCopyWith<$Res> {
  _$ConditionSearchCopyWithImpl(this._value, this._then);

  final ConditionSearch _value;
  // ignore: unused_field
  final $Res Function(ConditionSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object abatementAge = freezed,
    Object abatementBoolean = freezed,
    Object abatementDate = freezed,
    Object abatementString = freezed,
    Object assertedDate = freezed,
    Object asserter = freezed,
    Object bodySite = freezed,
    Object category = freezed,
    Object clinicalStatus = freezed,
    Object context = freezed,
    Object encounter = freezed,
    Object evidence = freezed,
    Object evidenceDetail = freezed,
    Object onsetAge = freezed,
    Object onsetDate = freezed,
    Object onsetInfo = freezed,
    Object severity = freezed,
    Object stage = freezed,
    Object subject = freezed,
    Object verificationStatus = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      abatementAge: abatementAge == freezed
          ? _value.abatementAge
          : abatementAge as List<SearchQuantity>,
      abatementBoolean: abatementBoolean == freezed
          ? _value.abatementBoolean
          : abatementBoolean as List<SearchToken>,
      abatementDate: abatementDate == freezed
          ? _value.abatementDate
          : abatementDate as List<SearchDate>,
      abatementString: abatementString == freezed
          ? _value.abatementString
          : abatementString as List<SearchString>,
      assertedDate: assertedDate == freezed
          ? _value.assertedDate
          : assertedDate as List<SearchDate>,
      asserter: asserter == freezed
          ? _value.asserter
          : asserter as List<SearchReference>,
      bodySite:
          bodySite == freezed ? _value.bodySite : bodySite as List<SearchToken>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinicalStatus: clinicalStatus == freezed
          ? _value.clinicalStatus
          : clinicalStatus as List<SearchToken>,
      context: context == freezed
          ? _value.context
          : context as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      evidence:
          evidence == freezed ? _value.evidence : evidence as List<SearchToken>,
      evidenceDetail: evidenceDetail == freezed
          ? _value.evidenceDetail
          : evidenceDetail as List<SearchReference>,
      onsetAge: onsetAge == freezed
          ? _value.onsetAge
          : onsetAge as List<SearchQuantity>,
      onsetDate: onsetDate == freezed
          ? _value.onsetDate
          : onsetDate as List<SearchDate>,
      onsetInfo: onsetInfo == freezed
          ? _value.onsetInfo
          : onsetInfo as List<SearchString>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      stage: stage == freezed ? _value.stage : stage as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      verificationStatus: verificationStatus == freezed
          ? _value.verificationStatus
          : verificationStatus as List<SearchToken>,
    ));
  }
}

/// @nodoc
abstract class _$ConditionSearchCopyWith<$Res>
    implements $ConditionSearchCopyWith<$Res> {
  factory _$ConditionSearchCopyWith(
          _ConditionSearch value, $Res Function(_ConditionSearch) then) =
      __$ConditionSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'abatement-age')
          List<SearchQuantity> abatementAge,
      @JsonKey(name: 'abatement-boolean')
          List<SearchToken> abatementBoolean,
      @JsonKey(name: 'abatement-date')
          List<SearchDate> abatementDate,
      @JsonKey(name: 'abatement-string')
          List<SearchString> abatementString,
      @JsonKey(name: 'asserted-date')
          List<SearchDate> assertedDate,
      List<SearchReference> asserter,
      @JsonKey(name: 'body-site')
          List<SearchToken> bodySite,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchReference> context,
      List<SearchReference> encounter,
      List<SearchToken> evidence,
      @JsonKey(name: 'evidence-detail')
          List<SearchReference> evidenceDetail,
      @JsonKey(name: 'onset-age')
          List<SearchQuantity> onsetAge,
      @JsonKey(name: 'onset-date')
          List<SearchDate> onsetDate,
      @JsonKey(name: 'onset-info')
          List<SearchString> onsetInfo,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<SearchReference> subject,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus});
}

/// @nodoc
class __$ConditionSearchCopyWithImpl<$Res>
    extends _$ConditionSearchCopyWithImpl<$Res>
    implements _$ConditionSearchCopyWith<$Res> {
  __$ConditionSearchCopyWithImpl(
      _ConditionSearch _value, $Res Function(_ConditionSearch) _then)
      : super(_value, (v) => _then(v as _ConditionSearch));

  @override
  _ConditionSearch get _value => super._value as _ConditionSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object code = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object abatementAge = freezed,
    Object abatementBoolean = freezed,
    Object abatementDate = freezed,
    Object abatementString = freezed,
    Object assertedDate = freezed,
    Object asserter = freezed,
    Object bodySite = freezed,
    Object category = freezed,
    Object clinicalStatus = freezed,
    Object context = freezed,
    Object encounter = freezed,
    Object evidence = freezed,
    Object evidenceDetail = freezed,
    Object onsetAge = freezed,
    Object onsetDate = freezed,
    Object onsetInfo = freezed,
    Object severity = freezed,
    Object stage = freezed,
    Object subject = freezed,
    Object verificationStatus = freezed,
  }) {
    return _then(_ConditionSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      code: code == freezed ? _value.code : code as List<SearchToken>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      abatementAge: abatementAge == freezed
          ? _value.abatementAge
          : abatementAge as List<SearchQuantity>,
      abatementBoolean: abatementBoolean == freezed
          ? _value.abatementBoolean
          : abatementBoolean as List<SearchToken>,
      abatementDate: abatementDate == freezed
          ? _value.abatementDate
          : abatementDate as List<SearchDate>,
      abatementString: abatementString == freezed
          ? _value.abatementString
          : abatementString as List<SearchString>,
      assertedDate: assertedDate == freezed
          ? _value.assertedDate
          : assertedDate as List<SearchDate>,
      asserter: asserter == freezed
          ? _value.asserter
          : asserter as List<SearchReference>,
      bodySite:
          bodySite == freezed ? _value.bodySite : bodySite as List<SearchToken>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      clinicalStatus: clinicalStatus == freezed
          ? _value.clinicalStatus
          : clinicalStatus as List<SearchToken>,
      context: context == freezed
          ? _value.context
          : context as List<SearchReference>,
      encounter: encounter == freezed
          ? _value.encounter
          : encounter as List<SearchReference>,
      evidence:
          evidence == freezed ? _value.evidence : evidence as List<SearchToken>,
      evidenceDetail: evidenceDetail == freezed
          ? _value.evidenceDetail
          : evidenceDetail as List<SearchReference>,
      onsetAge: onsetAge == freezed
          ? _value.onsetAge
          : onsetAge as List<SearchQuantity>,
      onsetDate: onsetDate == freezed
          ? _value.onsetDate
          : onsetDate as List<SearchDate>,
      onsetInfo: onsetInfo == freezed
          ? _value.onsetInfo
          : onsetInfo as List<SearchString>,
      severity:
          severity == freezed ? _value.severity : severity as List<SearchToken>,
      stage: stage == freezed ? _value.stage : stage as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
      verificationStatus: verificationStatus == freezed
          ? _value.verificationStatus
          : verificationStatus as List<SearchToken>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_ConditionSearch extends _ConditionSearch {
  _$_ConditionSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.code,
      this.identifier,
      this.patient,
      @JsonKey(name: 'abatement-age') this.abatementAge,
      @JsonKey(name: 'abatement-boolean') this.abatementBoolean,
      @JsonKey(name: 'abatement-date') this.abatementDate,
      @JsonKey(name: 'abatement-string') this.abatementString,
      @JsonKey(name: 'asserted-date') this.assertedDate,
      this.asserter,
      @JsonKey(name: 'body-site') this.bodySite,
      this.category,
      @JsonKey(name: 'clinical-status') this.clinicalStatus,
      this.context,
      this.encounter,
      this.evidence,
      @JsonKey(name: 'evidence-detail') this.evidenceDetail,
      @JsonKey(name: 'onset-age') this.onsetAge,
      @JsonKey(name: 'onset-date') this.onsetDate,
      @JsonKey(name: 'onset-info') this.onsetInfo,
      this.severity,
      this.stage,
      this.subject,
      @JsonKey(name: 'verification-status') this.verificationStatus})
      : super._();

  factory _$_ConditionSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_ConditionSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchToken> code;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  @JsonKey(name: 'abatement-age')
  final List<SearchQuantity> abatementAge;
  @override
  @JsonKey(name: 'abatement-boolean')
  final List<SearchToken> abatementBoolean;
  @override
  @JsonKey(name: 'abatement-date')
  final List<SearchDate> abatementDate;
  @override
  @JsonKey(name: 'abatement-string')
  final List<SearchString> abatementString;
  @override
  @JsonKey(name: 'asserted-date')
  final List<SearchDate> assertedDate;
  @override
  final List<SearchReference> asserter;
  @override
  @JsonKey(name: 'body-site')
  final List<SearchToken> bodySite;
  @override
  final List<SearchToken> category;
  @override
  @JsonKey(name: 'clinical-status')
  final List<SearchToken> clinicalStatus;
  @override
  final List<SearchReference> context;
  @override
  final List<SearchReference> encounter;
  @override
  final List<SearchToken> evidence;
  @override
  @JsonKey(name: 'evidence-detail')
  final List<SearchReference> evidenceDetail;
  @override
  @JsonKey(name: 'onset-age')
  final List<SearchQuantity> onsetAge;
  @override
  @JsonKey(name: 'onset-date')
  final List<SearchDate> onsetDate;
  @override
  @JsonKey(name: 'onset-info')
  final List<SearchString> onsetInfo;
  @override
  final List<SearchToken> severity;
  @override
  final List<SearchToken> stage;
  @override
  final List<SearchReference> subject;
  @override
  @JsonKey(name: 'verification-status')
  final List<SearchToken> verificationStatus;

  @override
  String toString() {
    return 'ConditionSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, code: $code, identifier: $identifier, patient: $patient, abatementAge: $abatementAge, abatementBoolean: $abatementBoolean, abatementDate: $abatementDate, abatementString: $abatementString, assertedDate: $assertedDate, asserter: $asserter, bodySite: $bodySite, category: $category, clinicalStatus: $clinicalStatus, context: $context, encounter: $encounter, evidence: $evidence, evidenceDetail: $evidenceDetail, onsetAge: $onsetAge, onsetDate: $onsetDate, onsetInfo: $onsetInfo, severity: $severity, stage: $stage, subject: $subject, verificationStatus: $verificationStatus)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ConditionSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.abatementAge, abatementAge) ||
                const DeepCollectionEquality()
                    .equals(other.abatementAge, abatementAge)) &&
            (identical(other.abatementBoolean, abatementBoolean) ||
                const DeepCollectionEquality()
                    .equals(other.abatementBoolean, abatementBoolean)) &&
            (identical(other.abatementDate, abatementDate) ||
                const DeepCollectionEquality()
                    .equals(other.abatementDate, abatementDate)) &&
            (identical(other.abatementString, abatementString) ||
                const DeepCollectionEquality()
                    .equals(other.abatementString, abatementString)) &&
            (identical(other.assertedDate, assertedDate) ||
                const DeepCollectionEquality()
                    .equals(other.assertedDate, assertedDate)) &&
            (identical(other.asserter, asserter) ||
                const DeepCollectionEquality()
                    .equals(other.asserter, asserter)) &&
            (identical(other.bodySite, bodySite) ||
                const DeepCollectionEquality()
                    .equals(other.bodySite, bodySite)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.clinicalStatus, clinicalStatus) ||
                const DeepCollectionEquality()
                    .equals(other.clinicalStatus, clinicalStatus)) &&
            (identical(other.context, context) ||
                const DeepCollectionEquality()
                    .equals(other.context, context)) &&
            (identical(other.encounter, encounter) ||
                const DeepCollectionEquality()
                    .equals(other.encounter, encounter)) &&
            (identical(other.evidence, evidence) || const DeepCollectionEquality().equals(other.evidence, evidence)) &&
            (identical(other.evidenceDetail, evidenceDetail) || const DeepCollectionEquality().equals(other.evidenceDetail, evidenceDetail)) &&
            (identical(other.onsetAge, onsetAge) || const DeepCollectionEquality().equals(other.onsetAge, onsetAge)) &&
            (identical(other.onsetDate, onsetDate) || const DeepCollectionEquality().equals(other.onsetDate, onsetDate)) &&
            (identical(other.onsetInfo, onsetInfo) || const DeepCollectionEquality().equals(other.onsetInfo, onsetInfo)) &&
            (identical(other.severity, severity) || const DeepCollectionEquality().equals(other.severity, severity)) &&
            (identical(other.stage, stage) || const DeepCollectionEquality().equals(other.stage, stage)) &&
            (identical(other.subject, subject) || const DeepCollectionEquality().equals(other.subject, subject)) &&
            (identical(other.verificationStatus, verificationStatus) || const DeepCollectionEquality().equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(abatementAge) ^
      const DeepCollectionEquality().hash(abatementBoolean) ^
      const DeepCollectionEquality().hash(abatementDate) ^
      const DeepCollectionEquality().hash(abatementString) ^
      const DeepCollectionEquality().hash(assertedDate) ^
      const DeepCollectionEquality().hash(asserter) ^
      const DeepCollectionEquality().hash(bodySite) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(clinicalStatus) ^
      const DeepCollectionEquality().hash(context) ^
      const DeepCollectionEquality().hash(encounter) ^
      const DeepCollectionEquality().hash(evidence) ^
      const DeepCollectionEquality().hash(evidenceDetail) ^
      const DeepCollectionEquality().hash(onsetAge) ^
      const DeepCollectionEquality().hash(onsetDate) ^
      const DeepCollectionEquality().hash(onsetInfo) ^
      const DeepCollectionEquality().hash(severity) ^
      const DeepCollectionEquality().hash(stage) ^
      const DeepCollectionEquality().hash(subject) ^
      const DeepCollectionEquality().hash(verificationStatus);

  @override
  _$ConditionSearchCopyWith<_ConditionSearch> get copyWith =>
      __$ConditionSearchCopyWithImpl<_ConditionSearch>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ConditionSearchToJson(this);
  }
}

abstract class _ConditionSearch extends ConditionSearch {
  _ConditionSearch._() : super._();
  factory _ConditionSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchToken> code,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      @JsonKey(name: 'abatement-age')
          List<SearchQuantity> abatementAge,
      @JsonKey(name: 'abatement-boolean')
          List<SearchToken> abatementBoolean,
      @JsonKey(name: 'abatement-date')
          List<SearchDate> abatementDate,
      @JsonKey(name: 'abatement-string')
          List<SearchString> abatementString,
      @JsonKey(name: 'asserted-date')
          List<SearchDate> assertedDate,
      List<SearchReference> asserter,
      @JsonKey(name: 'body-site')
          List<SearchToken> bodySite,
      List<SearchToken> category,
      @JsonKey(name: 'clinical-status')
          List<SearchToken> clinicalStatus,
      List<SearchReference> context,
      List<SearchReference> encounter,
      List<SearchToken> evidence,
      @JsonKey(name: 'evidence-detail')
          List<SearchReference> evidenceDetail,
      @JsonKey(name: 'onset-age')
          List<SearchQuantity> onsetAge,
      @JsonKey(name: 'onset-date')
          List<SearchDate> onsetDate,
      @JsonKey(name: 'onset-info')
          List<SearchString> onsetInfo,
      List<SearchToken> severity,
      List<SearchToken> stage,
      List<SearchReference> subject,
      @JsonKey(name: 'verification-status')
          List<SearchToken> verificationStatus}) = _$_ConditionSearch;

  factory _ConditionSearch.fromJson(Map<String, dynamic> json) =
      _$_ConditionSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchToken> get code;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  @JsonKey(name: 'abatement-age')
  List<SearchQuantity> get abatementAge;
  @override
  @JsonKey(name: 'abatement-boolean')
  List<SearchToken> get abatementBoolean;
  @override
  @JsonKey(name: 'abatement-date')
  List<SearchDate> get abatementDate;
  @override
  @JsonKey(name: 'abatement-string')
  List<SearchString> get abatementString;
  @override
  @JsonKey(name: 'asserted-date')
  List<SearchDate> get assertedDate;
  @override
  List<SearchReference> get asserter;
  @override
  @JsonKey(name: 'body-site')
  List<SearchToken> get bodySite;
  @override
  List<SearchToken> get category;
  @override
  @JsonKey(name: 'clinical-status')
  List<SearchToken> get clinicalStatus;
  @override
  List<SearchReference> get context;
  @override
  List<SearchReference> get encounter;
  @override
  List<SearchToken> get evidence;
  @override
  @JsonKey(name: 'evidence-detail')
  List<SearchReference> get evidenceDetail;
  @override
  @JsonKey(name: 'onset-age')
  List<SearchQuantity> get onsetAge;
  @override
  @JsonKey(name: 'onset-date')
  List<SearchDate> get onsetDate;
  @override
  @JsonKey(name: 'onset-info')
  List<SearchString> get onsetInfo;
  @override
  List<SearchToken> get severity;
  @override
  List<SearchToken> get stage;
  @override
  List<SearchReference> get subject;
  @override
  @JsonKey(name: 'verification-status')
  List<SearchToken> get verificationStatus;
  @override
  _$ConditionSearchCopyWith<_ConditionSearch> get copyWith;
}

DetectedIssueSearch _$DetectedIssueSearchFromJson(Map<String, dynamic> json) {
  return _DetectedIssueSearch.fromJson(json);
}

/// @nodoc
class _$DetectedIssueSearchTearOff {
  const _$DetectedIssueSearchTearOff();

// ignore: unused_element
  _DetectedIssueSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> author,
      List<SearchToken> category,
      List<SearchReference> implicated}) {
    return _DetectedIssueSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      date: date,
      identifier: identifier,
      patient: patient,
      author: author,
      category: category,
      implicated: implicated,
    );
  }

// ignore: unused_element
  DetectedIssueSearch fromJson(Map<String, Object> json) {
    return DetectedIssueSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $DetectedIssueSearch = _$DetectedIssueSearchTearOff();

/// @nodoc
mixin _$DetectedIssueSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchDate> get date;
  List<SearchToken> get identifier;
  List<SearchReference> get patient;
  List<SearchReference> get author;
  List<SearchToken> get category;
  List<SearchReference> get implicated;

  Map<String, dynamic> toJson();
  $DetectedIssueSearchCopyWith<DetectedIssueSearch> get copyWith;
}

/// @nodoc
abstract class $DetectedIssueSearchCopyWith<$Res> {
  factory $DetectedIssueSearchCopyWith(
          DetectedIssueSearch value, $Res Function(DetectedIssueSearch) then) =
      _$DetectedIssueSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> author,
      List<SearchToken> category,
      List<SearchReference> implicated});
}

/// @nodoc
class _$DetectedIssueSearchCopyWithImpl<$Res>
    implements $DetectedIssueSearchCopyWith<$Res> {
  _$DetectedIssueSearchCopyWithImpl(this._value, this._then);

  final DetectedIssueSearch _value;
  // ignore: unused_field
  final $Res Function(DetectedIssueSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object author = freezed,
    Object category = freezed,
    Object implicated = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      author:
          author == freezed ? _value.author : author as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      implicated: implicated == freezed
          ? _value.implicated
          : implicated as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$DetectedIssueSearchCopyWith<$Res>
    implements $DetectedIssueSearchCopyWith<$Res> {
  factory _$DetectedIssueSearchCopyWith(_DetectedIssueSearch value,
          $Res Function(_DetectedIssueSearch) then) =
      __$DetectedIssueSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> author,
      List<SearchToken> category,
      List<SearchReference> implicated});
}

/// @nodoc
class __$DetectedIssueSearchCopyWithImpl<$Res>
    extends _$DetectedIssueSearchCopyWithImpl<$Res>
    implements _$DetectedIssueSearchCopyWith<$Res> {
  __$DetectedIssueSearchCopyWithImpl(
      _DetectedIssueSearch _value, $Res Function(_DetectedIssueSearch) _then)
      : super(_value, (v) => _then(v as _DetectedIssueSearch));

  @override
  _DetectedIssueSearch get _value => super._value as _DetectedIssueSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object date = freezed,
    Object identifier = freezed,
    Object patient = freezed,
    Object author = freezed,
    Object category = freezed,
    Object implicated = freezed,
  }) {
    return _then(_DetectedIssueSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      author:
          author == freezed ? _value.author : author as List<SearchReference>,
      category:
          category == freezed ? _value.category : category as List<SearchToken>,
      implicated: implicated == freezed
          ? _value.implicated
          : implicated as List<SearchReference>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_DetectedIssueSearch extends _DetectedIssueSearch {
  _$_DetectedIssueSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.date,
      this.identifier,
      this.patient,
      this.author,
      this.category,
      this.implicated})
      : super._();

  factory _$_DetectedIssueSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_DetectedIssueSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchDate> date;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> author;
  @override
  final List<SearchToken> category;
  @override
  final List<SearchReference> implicated;

  @override
  String toString() {
    return 'DetectedIssueSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, date: $date, identifier: $identifier, patient: $patient, author: $author, category: $category, implicated: $implicated)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DetectedIssueSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.implicated, implicated) ||
                const DeepCollectionEquality()
                    .equals(other.implicated, implicated)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(implicated);

  @override
  _$DetectedIssueSearchCopyWith<_DetectedIssueSearch> get copyWith =>
      __$DetectedIssueSearchCopyWithImpl<_DetectedIssueSearch>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_DetectedIssueSearchToJson(this);
  }
}

abstract class _DetectedIssueSearch extends DetectedIssueSearch {
  _DetectedIssueSearch._() : super._();
  factory _DetectedIssueSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchToken> identifier,
      List<SearchReference> patient,
      List<SearchReference> author,
      List<SearchToken> category,
      List<SearchReference> implicated}) = _$_DetectedIssueSearch;

  factory _DetectedIssueSearch.fromJson(Map<String, dynamic> json) =
      _$_DetectedIssueSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchDate> get date;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get author;
  @override
  List<SearchToken> get category;
  @override
  List<SearchReference> get implicated;
  @override
  _$DetectedIssueSearchCopyWith<_DetectedIssueSearch> get copyWith;
}

ClinicalImpressionSearch _$ClinicalImpressionSearchFromJson(
    Map<String, dynamic> json) {
  return _ClinicalImpressionSearch.fromJson(json);
}

/// @nodoc
class _$ClinicalImpressionSearchTearOff {
  const _$ClinicalImpressionSearchTearOff();

// ignore: unused_element
  _ClinicalImpressionSearch call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchReference> patient,
      List<SearchReference> action,
      List<SearchReference> assessor,
      List<SearchReference> context,
      @JsonKey(name: 'finding-code') List<SearchToken> findingCode,
      @JsonKey(name: 'finding-ref') List<SearchReference> findingRef,
      List<SearchToken> identifier,
      List<SearchReference> investigation,
      List<SearchReference> previous,
      List<SearchReference> problem,
      List<SearchToken> status,
      List<SearchReference> subject}) {
    return _ClinicalImpressionSearch(
      searchId: searchId,
      searchLastUpdated: searchLastUpdated,
      searchTag: searchTag,
      searchProfile: searchProfile,
      searchSecurity: searchSecurity,
      searchText: searchText,
      searchContent: searchContent,
      searchList: searchList,
      date: date,
      patient: patient,
      action: action,
      assessor: assessor,
      context: context,
      findingCode: findingCode,
      findingRef: findingRef,
      identifier: identifier,
      investigation: investigation,
      previous: previous,
      problem: problem,
      status: status,
      subject: subject,
    );
  }

// ignore: unused_element
  ClinicalImpressionSearch fromJson(Map<String, Object> json) {
    return ClinicalImpressionSearch.fromJson(json);
  }
}

/// @nodoc
// ignore: unused_element
const $ClinicalImpressionSearch = _$ClinicalImpressionSearchTearOff();

/// @nodoc
mixin _$ClinicalImpressionSearch {
  List<Id> get searchId;
  List<SearchDate> get searchLastUpdated;
  List<SearchToken> get searchTag;
  List<SearchUri> get searchProfile;
  List<SearchToken> get searchSecurity;
  List<SearchString> get searchText;
  List<SearchString> get searchContent;
  List<Id> get searchList; //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchDate> get date;
  List<SearchReference> get patient;
  List<SearchReference> get action;
  List<SearchReference> get assessor;
  List<SearchReference> get context;
  @JsonKey(name: 'finding-code')
  List<SearchToken> get findingCode;
  @JsonKey(name: 'finding-ref')
  List<SearchReference> get findingRef;
  List<SearchToken> get identifier;
  List<SearchReference> get investigation;
  List<SearchReference> get previous;
  List<SearchReference> get problem;
  List<SearchToken> get status;
  List<SearchReference> get subject;

  Map<String, dynamic> toJson();
  $ClinicalImpressionSearchCopyWith<ClinicalImpressionSearch> get copyWith;
}

/// @nodoc
abstract class $ClinicalImpressionSearchCopyWith<$Res> {
  factory $ClinicalImpressionSearchCopyWith(ClinicalImpressionSearch value,
          $Res Function(ClinicalImpressionSearch) then) =
      _$ClinicalImpressionSearchCopyWithImpl<$Res>;
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchReference> patient,
      List<SearchReference> action,
      List<SearchReference> assessor,
      List<SearchReference> context,
      @JsonKey(name: 'finding-code') List<SearchToken> findingCode,
      @JsonKey(name: 'finding-ref') List<SearchReference> findingRef,
      List<SearchToken> identifier,
      List<SearchReference> investigation,
      List<SearchReference> previous,
      List<SearchReference> problem,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class _$ClinicalImpressionSearchCopyWithImpl<$Res>
    implements $ClinicalImpressionSearchCopyWith<$Res> {
  _$ClinicalImpressionSearchCopyWithImpl(this._value, this._then);

  final ClinicalImpressionSearch _value;
  // ignore: unused_field
  final $Res Function(ClinicalImpressionSearch) _then;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object date = freezed,
    Object patient = freezed,
    Object action = freezed,
    Object assessor = freezed,
    Object context = freezed,
    Object findingCode = freezed,
    Object findingRef = freezed,
    Object identifier = freezed,
    Object investigation = freezed,
    Object previous = freezed,
    Object problem = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_value.copyWith(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      action:
          action == freezed ? _value.action : action as List<SearchReference>,
      assessor: assessor == freezed
          ? _value.assessor
          : assessor as List<SearchReference>,
      context: context == freezed
          ? _value.context
          : context as List<SearchReference>,
      findingCode: findingCode == freezed
          ? _value.findingCode
          : findingCode as List<SearchToken>,
      findingRef: findingRef == freezed
          ? _value.findingRef
          : findingRef as List<SearchReference>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      investigation: investigation == freezed
          ? _value.investigation
          : investigation as List<SearchReference>,
      previous: previous == freezed
          ? _value.previous
          : previous as List<SearchReference>,
      problem: problem == freezed
          ? _value.problem
          : problem as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

/// @nodoc
abstract class _$ClinicalImpressionSearchCopyWith<$Res>
    implements $ClinicalImpressionSearchCopyWith<$Res> {
  factory _$ClinicalImpressionSearchCopyWith(_ClinicalImpressionSearch value,
          $Res Function(_ClinicalImpressionSearch) then) =
      __$ClinicalImpressionSearchCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchReference> patient,
      List<SearchReference> action,
      List<SearchReference> assessor,
      List<SearchReference> context,
      @JsonKey(name: 'finding-code') List<SearchToken> findingCode,
      @JsonKey(name: 'finding-ref') List<SearchReference> findingRef,
      List<SearchToken> identifier,
      List<SearchReference> investigation,
      List<SearchReference> previous,
      List<SearchReference> problem,
      List<SearchToken> status,
      List<SearchReference> subject});
}

/// @nodoc
class __$ClinicalImpressionSearchCopyWithImpl<$Res>
    extends _$ClinicalImpressionSearchCopyWithImpl<$Res>
    implements _$ClinicalImpressionSearchCopyWith<$Res> {
  __$ClinicalImpressionSearchCopyWithImpl(_ClinicalImpressionSearch _value,
      $Res Function(_ClinicalImpressionSearch) _then)
      : super(_value, (v) => _then(v as _ClinicalImpressionSearch));

  @override
  _ClinicalImpressionSearch get _value =>
      super._value as _ClinicalImpressionSearch;

  @override
  $Res call({
    Object searchId = freezed,
    Object searchLastUpdated = freezed,
    Object searchTag = freezed,
    Object searchProfile = freezed,
    Object searchSecurity = freezed,
    Object searchText = freezed,
    Object searchContent = freezed,
    Object searchList = freezed,
    Object date = freezed,
    Object patient = freezed,
    Object action = freezed,
    Object assessor = freezed,
    Object context = freezed,
    Object findingCode = freezed,
    Object findingRef = freezed,
    Object identifier = freezed,
    Object investigation = freezed,
    Object previous = freezed,
    Object problem = freezed,
    Object status = freezed,
    Object subject = freezed,
  }) {
    return _then(_ClinicalImpressionSearch(
      searchId: searchId == freezed ? _value.searchId : searchId as List<Id>,
      searchLastUpdated: searchLastUpdated == freezed
          ? _value.searchLastUpdated
          : searchLastUpdated as List<SearchDate>,
      searchTag: searchTag == freezed
          ? _value.searchTag
          : searchTag as List<SearchToken>,
      searchProfile: searchProfile == freezed
          ? _value.searchProfile
          : searchProfile as List<SearchUri>,
      searchSecurity: searchSecurity == freezed
          ? _value.searchSecurity
          : searchSecurity as List<SearchToken>,
      searchText: searchText == freezed
          ? _value.searchText
          : searchText as List<SearchString>,
      searchContent: searchContent == freezed
          ? _value.searchContent
          : searchContent as List<SearchString>,
      searchList:
          searchList == freezed ? _value.searchList : searchList as List<Id>,
      date: date == freezed ? _value.date : date as List<SearchDate>,
      patient: patient == freezed
          ? _value.patient
          : patient as List<SearchReference>,
      action:
          action == freezed ? _value.action : action as List<SearchReference>,
      assessor: assessor == freezed
          ? _value.assessor
          : assessor as List<SearchReference>,
      context: context == freezed
          ? _value.context
          : context as List<SearchReference>,
      findingCode: findingCode == freezed
          ? _value.findingCode
          : findingCode as List<SearchToken>,
      findingRef: findingRef == freezed
          ? _value.findingRef
          : findingRef as List<SearchReference>,
      identifier: identifier == freezed
          ? _value.identifier
          : identifier as List<SearchToken>,
      investigation: investigation == freezed
          ? _value.investigation
          : investigation as List<SearchReference>,
      previous: previous == freezed
          ? _value.previous
          : previous as List<SearchReference>,
      problem: problem == freezed
          ? _value.problem
          : problem as List<SearchReference>,
      status: status == freezed ? _value.status : status as List<SearchToken>,
      subject: subject == freezed
          ? _value.subject
          : subject as List<SearchReference>,
    ));
  }
}

@JsonSerializable()

/// @nodoc
class _$_ClinicalImpressionSearch extends _ClinicalImpressionSearch {
  _$_ClinicalImpressionSearch(
      {this.searchId,
      this.searchLastUpdated,
      this.searchTag,
      this.searchProfile,
      this.searchSecurity,
      this.searchText,
      this.searchContent,
      this.searchList,
      this.date,
      this.patient,
      this.action,
      this.assessor,
      this.context,
      @JsonKey(name: 'finding-code') this.findingCode,
      @JsonKey(name: 'finding-ref') this.findingRef,
      this.identifier,
      this.investigation,
      this.previous,
      this.problem,
      this.status,
      this.subject})
      : super._();

  factory _$_ClinicalImpressionSearch.fromJson(Map<String, dynamic> json) =>
      _$_$_ClinicalImpressionSearchFromJson(json);

  @override
  final List<Id> searchId;
  @override
  final List<SearchDate> searchLastUpdated;
  @override
  final List<SearchToken> searchTag;
  @override
  final List<SearchUri> searchProfile;
  @override
  final List<SearchToken> searchSecurity;
  @override
  final List<SearchString> searchText;
  @override
  final List<SearchString> searchContent;
  @override
  final List<Id> searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  final List<SearchDate> date;
  @override
  final List<SearchReference> patient;
  @override
  final List<SearchReference> action;
  @override
  final List<SearchReference> assessor;
  @override
  final List<SearchReference> context;
  @override
  @JsonKey(name: 'finding-code')
  final List<SearchToken> findingCode;
  @override
  @JsonKey(name: 'finding-ref')
  final List<SearchReference> findingRef;
  @override
  final List<SearchToken> identifier;
  @override
  final List<SearchReference> investigation;
  @override
  final List<SearchReference> previous;
  @override
  final List<SearchReference> problem;
  @override
  final List<SearchToken> status;
  @override
  final List<SearchReference> subject;

  @override
  String toString() {
    return 'ClinicalImpressionSearch(searchId: $searchId, searchLastUpdated: $searchLastUpdated, searchTag: $searchTag, searchProfile: $searchProfile, searchSecurity: $searchSecurity, searchText: $searchText, searchContent: $searchContent, searchList: $searchList, date: $date, patient: $patient, action: $action, assessor: $assessor, context: $context, findingCode: $findingCode, findingRef: $findingRef, identifier: $identifier, investigation: $investigation, previous: $previous, problem: $problem, status: $status, subject: $subject)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ClinicalImpressionSearch &&
            (identical(other.searchId, searchId) ||
                const DeepCollectionEquality()
                    .equals(other.searchId, searchId)) &&
            (identical(other.searchLastUpdated, searchLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.searchLastUpdated, searchLastUpdated)) &&
            (identical(other.searchTag, searchTag) ||
                const DeepCollectionEquality()
                    .equals(other.searchTag, searchTag)) &&
            (identical(other.searchProfile, searchProfile) ||
                const DeepCollectionEquality()
                    .equals(other.searchProfile, searchProfile)) &&
            (identical(other.searchSecurity, searchSecurity) ||
                const DeepCollectionEquality()
                    .equals(other.searchSecurity, searchSecurity)) &&
            (identical(other.searchText, searchText) ||
                const DeepCollectionEquality()
                    .equals(other.searchText, searchText)) &&
            (identical(other.searchContent, searchContent) ||
                const DeepCollectionEquality()
                    .equals(other.searchContent, searchContent)) &&
            (identical(other.searchList, searchList) ||
                const DeepCollectionEquality()
                    .equals(other.searchList, searchList)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.patient, patient) ||
                const DeepCollectionEquality()
                    .equals(other.patient, patient)) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)) &&
            (identical(other.assessor, assessor) ||
                const DeepCollectionEquality()
                    .equals(other.assessor, assessor)) &&
            (identical(other.context, context) ||
                const DeepCollectionEquality()
                    .equals(other.context, context)) &&
            (identical(other.findingCode, findingCode) ||
                const DeepCollectionEquality()
                    .equals(other.findingCode, findingCode)) &&
            (identical(other.findingRef, findingRef) ||
                const DeepCollectionEquality()
                    .equals(other.findingRef, findingRef)) &&
            (identical(other.identifier, identifier) ||
                const DeepCollectionEquality()
                    .equals(other.identifier, identifier)) &&
            (identical(other.investigation, investigation) ||
                const DeepCollectionEquality()
                    .equals(other.investigation, investigation)) &&
            (identical(other.previous, previous) ||
                const DeepCollectionEquality()
                    .equals(other.previous, previous)) &&
            (identical(other.problem, problem) ||
                const DeepCollectionEquality()
                    .equals(other.problem, problem)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.subject, subject) ||
                const DeepCollectionEquality().equals(other.subject, subject)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(searchId) ^
      const DeepCollectionEquality().hash(searchLastUpdated) ^
      const DeepCollectionEquality().hash(searchTag) ^
      const DeepCollectionEquality().hash(searchProfile) ^
      const DeepCollectionEquality().hash(searchSecurity) ^
      const DeepCollectionEquality().hash(searchText) ^
      const DeepCollectionEquality().hash(searchContent) ^
      const DeepCollectionEquality().hash(searchList) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(patient) ^
      const DeepCollectionEquality().hash(action) ^
      const DeepCollectionEquality().hash(assessor) ^
      const DeepCollectionEquality().hash(context) ^
      const DeepCollectionEquality().hash(findingCode) ^
      const DeepCollectionEquality().hash(findingRef) ^
      const DeepCollectionEquality().hash(identifier) ^
      const DeepCollectionEquality().hash(investigation) ^
      const DeepCollectionEquality().hash(previous) ^
      const DeepCollectionEquality().hash(problem) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(subject);

  @override
  _$ClinicalImpressionSearchCopyWith<_ClinicalImpressionSearch> get copyWith =>
      __$ClinicalImpressionSearchCopyWithImpl<_ClinicalImpressionSearch>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$_$_ClinicalImpressionSearchToJson(this);
  }
}

abstract class _ClinicalImpressionSearch extends ClinicalImpressionSearch {
  _ClinicalImpressionSearch._() : super._();
  factory _ClinicalImpressionSearch(
      {List<Id> searchId,
      List<SearchDate> searchLastUpdated,
      List<SearchToken> searchTag,
      List<SearchUri> searchProfile,
      List<SearchToken> searchSecurity,
      List<SearchString> searchText,
      List<SearchString> searchContent,
      List<Id> searchList,
      List<SearchDate> date,
      List<SearchReference> patient,
      List<SearchReference> action,
      List<SearchReference> assessor,
      List<SearchReference> context,
      @JsonKey(name: 'finding-code') List<SearchToken> findingCode,
      @JsonKey(name: 'finding-ref') List<SearchReference> findingRef,
      List<SearchToken> identifier,
      List<SearchReference> investigation,
      List<SearchReference> previous,
      List<SearchReference> problem,
      List<SearchToken> status,
      List<SearchReference> subject}) = _$_ClinicalImpressionSearch;

  factory _ClinicalImpressionSearch.fromJson(Map<String, dynamic> json) =
      _$_ClinicalImpressionSearch.fromJson;

  @override
  List<Id> get searchId;
  @override
  List<SearchDate> get searchLastUpdated;
  @override
  List<SearchToken> get searchTag;
  @override
  List<SearchUri> get searchProfile;
  @override
  List<SearchToken> get searchSecurity;
  @override
  List<SearchString> get searchText;
  @override
  List<SearchString> get searchContent;
  @override
  List<Id> get searchList;
  @override //List<SearchString> searchHas,
//List<SearchToken> searchType,
  List<SearchDate> get date;
  @override
  List<SearchReference> get patient;
  @override
  List<SearchReference> get action;
  @override
  List<SearchReference> get assessor;
  @override
  List<SearchReference> get context;
  @override
  @JsonKey(name: 'finding-code')
  List<SearchToken> get findingCode;
  @override
  @JsonKey(name: 'finding-ref')
  List<SearchReference> get findingRef;
  @override
  List<SearchToken> get identifier;
  @override
  List<SearchReference> get investigation;
  @override
  List<SearchReference> get previous;
  @override
  List<SearchReference> get problem;
  @override
  List<SearchToken> get status;
  @override
  List<SearchReference> get subject;
  @override
  _$ClinicalImpressionSearchCopyWith<_ClinicalImpressionSearch> get copyWith;
}
